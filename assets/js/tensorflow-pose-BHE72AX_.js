import{o as Ve,e as le,h as de,i as Cr,E as xt,A as _d,c as ds,m as os,j as gt,k as mt,l as it,n as ls,p as Pl,B as Sb,q as Td,u as Rd,v as Cb,L as Ad,w as We,x as Ce,y as Pd,z as $d,T as Or,G as ua,H as gp,I as Ed,J as An,R as Nb,K as Ib,N as kb,O as Xo,P as _b,Q as Pn,U as Dd,V as Od,W as ba,X as yp,Y as ec,Z as tc,_ as rc,$ as Fd,a0 as Ld,a1 as Tb,a2 as nc,a3 as Ye,a4 as zd,a5 as Rb,a6 as Yt,a7 as Er,a8 as Et,a9 as Bd,aa as Wd,ab as Vd,ac as Ud,ad as sc,ae as oi,af as Ab,ag as Md,ah as Pb,ai as ic,aj as $b,ak as ln,al as Eb,am as an,an as wp,ao as $l,ap as Db,aq as Ob,ar as Fb,as as Lb,at as zb,au as Bb,av as Wb,aw as ac,ax as vp,ay as oc,az as Qe,aA as Yo,aB as Hd,aC as uc,aD as Vb,aE as Gd,aF as El,aG as Ub,aH as Mb,aI as jd,aJ as Hb,aK as Gb,aL as jb,aM as Kb,aN as qb,aO as Xb,aP as Yb,aQ as Qb,aR as Zb,aS as Jb,aT as Kd,aU as gr,aV as ex,aW as tx,aX as rx,aY as nx,aZ as sx,a_ as ix,a$ as qd,b0 as ax,b1 as ox,b2 as ux,b3 as lx,b4 as cx,b5 as hx,b6 as px,b7 as dx,b8 as fx,b9 as mx,ba as gx,bb as yx,bc as wx,bd as vx,be as bx,bf as fs,bg as xx,bh as Xd,bi as Sx,bj as Cx,bk as Nx,bl as Ix,bm as kx,bn as _x,bo as Tx,bp as Rx,bq as Ax,br as Px,bs as $x,bt as Ex,bu as Dx,bv as Ox,bw as Fx,bx as Lx,by as zx,bz as Bx,bA as Wx,bB as Vx,bC as Ux,bD as Mx,bE as Hx,bF as Gx,bG as jx,bH as Kx,bI as qx,bJ as Dl,bK as ui,bL as Xx,bM as Yx,bN as Qx,bO as Zx,bP as Jx,bQ as e1,bR as t1,bS as r1,bT as n1,bU as s1,bV as cs,bW as i1,bX as a1,bY as o1,bZ as u1,b_ as l1,b$ as c1,c0 as h1,c1 as p1,c2 as d1,c3 as f1,c4 as m1,c5 as g1,c6 as y1,c7 as w1,c8 as v1,c9 as b1,ca as x1,cb as S1,cc as C1,cd as N1,ce as I1,cf as k1,cg as _1,ch as T1,ci as R1,cj as Yd,ck as Qd,cl as A1,cm as P1,cn as $1,co as E1,cp as D1,cq as O1,cr as F1,cs as L1,ct as z1,cu as B1,cv as W1,cw as V1,cx as U1,cy as M1,cz as H1,cA as G1,cB as j1,cC as K1,cD as q1,cE as X1,cF as Y1,cG as Q1,cH as Z1,cI as J1,cJ as e2,cK as t2,cL as r2,cM as n2,cN as s2,cO as i2,cP as a2,cQ as o2,cR as u2,cS as l2,cT as c2,cU as h2,cV as Zd,cW as p2,cX as pa,cY as d2,cZ as f2,c_ as m2,c$ as g2,d0 as y2,t as si,d1 as Rn,d2 as w2,d3 as v2,d4 as b2,d5 as x2,d6 as S2,d7 as C2,d8 as N2,d9 as xa,da as I2,db as k2,dc as lc,dd as _2,de as on,a as tt,df as Vo,d as Dt,dg as Jd,dh as da,di as T2,dj as R2,dk as ai,dl as gl,dm as bp,dn as cc,dp as xp,dq as A2,dr as P2,ds as $2,dt as E2,du as D2,dv as O2,dw as F2,dx as L2,dy as z2,dz as B2,dA as W2,dB as V2,dC as U2,dD as M2,dE as H2,dF as G2,dG as j2,dH as K2,dI as Sp,dJ as q2,dK as X2,dL as fa,dM as Cp,dN as Y2,dO as Q2,dP as Z2,dQ as J2,dR as eS,dS as tS,dT as hc,dU as ys,dV as Sa,dW as Ca,dX as pc,dY as rS,dZ as nS,d_ as sS,d$ as iS,e0 as aS,e1 as oS,e2 as uS,e3 as lS,e4 as cS,e5 as hS,e6 as pS,e7 as dS,e8 as fS,e9 as mS,ea as Na,eb as gS,ec as Qo,ed as yS,ee as wS,ef as vS,eg as bS,eh as xS,ei as SS,ej as CS,ek as ef,el as tf,em as rf,en as NS,eo as IS,ep as kS,eq as _S,er as TS,es as RS,et as AS,eu as PS,ev as $S,ew as ES,ex as ma,ey as DS,ez as OS,eA as FS,eB as LS,eC as Ia,eD as zS,eE as BS,eF as WS,eG as dc,eH as VS,eI as US,eJ as MS,eK as HS,eL as GS,eM as nf,eN as jS,eO as KS,eP as qS,eQ as XS,eR as YS,eS as QS,eT as ZS,eU as JS,eV as fc,eW as eC,eX as tC,eY as rC,eZ as nC,e_ as sC,e$ as iC,f0 as aC,f1 as oC,f2 as uC,f3 as lC,f4 as cC,f5 as hC,f6 as pC,f7 as dC,f8 as fC,f9 as mC,fa as gC,fb as yC,fc as wC,fd as vC,fe as bC,ff as xC,fg as SC,fh as CC,fi as NC,fj as IC,fk as kC,fl as _C,fm as TC,fn as RC,fo as AC,fp as PC,fq as $C,fr as EC,fs as DC,ft as OC,fu as FC,fv as LC,fw as zC,fx as BC,fy as WC,fz as VC,fA as UC,fB as MC,fC as HC,fD as GC,fE as jC,fF as KC,fG as qC,fH as XC,fI as YC,fJ as QC,fK as ZC,fL as JC,fM as eN,fN as tN,fO as rN,fP as nN,fQ as sN,fR as iN,fS as aN,fT as oN,fU as uN,fV as lN,fW as cN,fX as hN,fY as pN,fZ as dN,f_ as fN,f$ as mN,g0 as gN,g1 as yN,g2 as wN,g3 as vN,g4 as bN,g5 as xN,g6 as SN,g7 as CN,g8 as NN,g9 as IN,ga as kN,gb as mc,gc as _N,gd as TN,ge as RN,gf as AN,gg as PN,gh as $N,gi as EN,gj as DN,gk as ON,gl as FN,gm as LN,gn as zN,go as BN,gp as WN,gq as VN,gr as UN,gs as MN,gt as HN,gu as GN,gv as jN,gw as KN,gx as qN,gy as XN,gz as YN,gA as QN,gB as ZN,gC as JN,gD as e3,gE as t3,gF as r3,gG as n3,g as Uo,gH as gc,f as sf,gI as ga,r as s3}from"./register_all_kernels-BcsGZHQr.js";import{c as ii}from"./commonjsHelpers-CE1G-McA.js";import{h as i3,f as a3,i as o3,c as u3,a as yl,o as l3}from"../index-C51a6HNj.js";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(r){le(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),le(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const t=r.map((i,o)=>de(i,`tensors${o}`,"addN")),e=t[0];t.forEach(i=>{if(i.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(i=>{if(!Cr(i.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return xt.runKernel(_d,s)}const h3=Ve({addN_:c3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(r,t,e,s,i,o){const u=de(r,"forgetBias","basicLSTMCell"),l=de(t,"lstmKernel","basicLSTMCell"),p=de(e,"lstmBias","basicLSTMCell"),d=de(s,"data","basicLSTMCell"),f=de(i,"c","basicLSTMCell"),m=de(o,"h","basicLSTMCell"),w=ds([d,m],1),x=os(w,l),C=gt(x,p),I=C.shape[0],k=C.shape[1]/4,P=[I,k],O=mt(C,[0,0],P),z=mt(C,[0,k],P),F=mt(C,[0,k*2],P),V=mt(C,[0,k*3],P),G=gt(it(ls(O),Pl(z)),it(f,ls(gt(u,F)))),M=it(Pl(G),ls(V));return[G,M]}const d3=Ve({basicLSTMCell_:p3});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3(r,t){const e=de(r,"x","bitwiseAnd"),s=de(t,"y","bitwiseAnd");if(!Cr(e.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${s.shape}`);if(e.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${s.dtype}`);const i={a:e,b:s};return xt.runKernel(Sb,i)}const m3=Ve({bitwiseAnd_:f3});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3(r,t){const e=de(r,"s0","broadcastArgs","int32"),s=de(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:e,s1:s};return xt.runKernel(Td,i)}const y3=Ve({broadcastArgs_:g3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(r){const e={x:de(r,"x","diag")};return xt.runKernel(Rd,e)}const v3=Ve({diag_:w3});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b3(r,t){const e=de(r,"x","ensureShape","string_or_numeric");if(!Cb(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return r}const x3=Ve({ensureShape_:b3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");const s={start:r,stop:t,num:e};return xt.runKernel(Ad,{},s)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lo=2147483648;function C3(r,t,e="left"){const s=de(r,"sortedSequence","searchSorted"),i=de(t,"values","searchSorted"),o=s.shape[s.shape.length-1],u=i.shape[i.shape.length-1],l=We(s,[-1,o]),p=We(i,[-1,u]);if(l.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(l.shape[0]!==p.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ce(p.shape)>=Lo)throw new Error(`values tensor size must less than ${Lo}`);if(l.shape[1]>=Lo)throw new Error(`trailing dim_size must less than ${Lo} for int32 output type, was ${l.shape[1]}`);const d={sortedSequence:l,values:p},f={side:e};return xt.runKernel(Pd,d,f)}const yc=Ve({searchSorted_:C3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(r,t){return yc(r,t,"left")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(r,t,e,s,i=!1){const u={x:de(r,"x","maxPoolWithArgmax")},l={filterSize:t,strides:e,pad:s,includeBatchInIndex:i},p=xt.runKernel($d,u,l);return{result:p[0],indexes:p[1]}}const k3=Ve({maxPoolWithArgmax_:I3});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let s=de(r,"x","meshgrid",r instanceof Or?r.dtype:"float32");if(t===void 0)return[s];let i=de(t,"y","meshgrid",t instanceof Or?t.dtype:"float32");const o=Ce(s.shape),u=Ce(i.shape);return e==="xy"?(s=We(s,[1,-1]),i=We(i,[-1,1]),[os(ua([u,1],s.dtype),s),os(i,ua([1,o],i.dtype))]):(s=We(s,[-1,1]),i=We(i,[1,-1]),[os(s,ua([1,u],s.dtype)),os(ua([o,1],i.dtype),i)])}function T3(r,t,e,s){const i=de(t,"data","multiRNNCell"),o=gp(e,"c","multiRNNCell"),u=gp(s,"h","multiRNNCell");let l=i;const p=[];for(let m=0;m<r.length;m++){const w=r[m](l,o[m],u[m]);p.push(w[0]),p.push(w[1]),l=w[1]}const d=[],f=[];for(let m=0;m<p.length;m+=2)d.push(p[m]),f.push(p[m+1]);return[d,f]}const R3=Ve({multiRNNCell_:T3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A3(r,t,e,s=!1){const i=de(r,"logits","multinomial"),o=i.size,u=i.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(u>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${u}`);e=e||Math.random();const p={logits:u===1?We(i,[1,-1]):i},d={numSamples:t,seed:e,normalized:s},f=xt.runKernel(Ed,p,d);return u===1?We(f,[f.size]):f}const P3=Ve({multinomial_:A3});function $3(r,t){const e=de(r,"v1","outerProduct"),s=de(t,"v2","outerProduct");le(e.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${s.rank}.`);const i=We(e,[-1,1]),o=We(s,[1,-1]);return os(i,o)}const E3=Ve({outerProduct_:$3});function D3(r,t,e=0){return le(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),An(r,[t],e)}const O3=Ve({pad1d_:D3});function F3(r,t,e=0){return le(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),An(r,t,e)}const L3=Ve({pad2d_:F3});function z3(r,t,e=0){return le(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),An(r,t,e)}const B3=Ve({pad3d_:z3});function W3(r,t,e=0){return le(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),An(r,t,e)}const V3=Ve({pad4d_:W3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3(r,t,e,s){const i=r.map((f,m)=>de(f,`tensors${m}`,"raggedGather","int32")),o=de(t,"paramsDenseValues","raggedGather"),u=de(e,"indices","raggedGather","int32"),l={paramsNestedSplits:i,paramsDenseValues:o,indices:u},p={outputRaggedRank:s},d=xt.runKernel(Nb,l,p);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}const M3=Ve({raggedGather_:U3});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3(r,t,e){const s=de(r,"starts","raggedRange"),i=de(t,"limits","raggedRange",s.dtype),o=de(e,"deltas","raggedRange",s.dtype),u={starts:s,limits:i,deltas:o},l=xt.runKernel(Ib,u);return{rtNestedSplits:l[0],rtDenseValues:l[1]}}const G3=Ve({raggedRange_:H3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(r,t,e,s,i){const o=de(r,"shape","raggedTensorToTensor","int32"),u=de(t,"values","raggedTensorToTensor"),l=de(e,"defaultValue","raggedTensorToTensor",u.dtype),p=s.map((m,w)=>de(m,`tensors${w}`,"raggedTensorToTensor","int32")),d={shape:o,values:u,defaultValue:l,rowPartitionTensors:p},f={rowPartitionTypes:i};return xt.runKernel(kb,d,f)}const K3=Ve({raggedTensorToTensor_:j3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3(r,t,e){Xo(r);const s=Ce(r);let i=null;if(e==null||e==="float32")i=new Float32Array(s);else if(e==="int32")i=new Int32Array(s);else if(e==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${e}`);for(let o=0;o<s;o++)i[o]=t();return xt.makeTensor(i,r,e)}const X3=Ve({rand_:q3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3(r,t,e=1,s="float32",i){if(Xo(r),e==null&&(e=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new _b(t,e,s,i),u=Pn(r,s);for(let l=0;l<u.values.length;l++)u.values[l]=o.nextValue();return u.toTensor()}const Q3=Ve({randomGamma_:Y3});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(r,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Dd(r,0,1,t,e)}const J3=Ve({randomStandardNormal_:Z3});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(r,t,e,s){return Od(r,t,e,"int32",s)}const tI=Ve({randomUniformInt_:eI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(r){const t=de(r,"x","reverse");return le(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ba(t,0)}const nI=Ve({reverse1d_:rI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(r,t){const e=de(r,"x","reverse");return le(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),ba(e,t)}const iI=Ve({reverse2d_:sI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(r,t){const e=de(r,"x","reverse");return le(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),ba(e,t)}const oI=Ve({reverse3d_:aI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(r,t){const e=de(r,"x","reverse");return le(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),ba(e,t)}const lI=Ve({reverse4d_:uI});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cI(r,t){const e=de(r,"x","setdiff1d"),s=de(t,"y","setdiff1d");le(e.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${s.dtype}).`),le(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),le(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await e.data(),o=await s.data(),u=new Set(o);let l=0;for(let f=0;f<i.length;f++)u.has(i[f])||l++;const p=new yp([l],e.dtype),d=new yp([l],"int32");for(let f=0,m=0;f<i.length;f++)u.has(i[f])||(p.values[m]=i[f],d.values[m]=f,m++);return[p.toTensor(),d.toTensor()]}const hI=cI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(r,t,e){if(ec(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=tc(r,e);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return rc(r,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(r,t,e){if(ec(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=tc(r,e);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return rc(r,t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(r,t,e){if(ec(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=tc(r,e);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,rc(r,t,s,e)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(r,t,e){const s=de(r,"tensor","tensorScatterupdate"),i=de(t,"indices","tensorScatterupdate","int32"),o=de(e,"updates","tensorScatterupdate");if(Fd(o,i,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const u={tensor:s,indices:i,updates:o},l={};return xt.runKernel(Ld,u,l)}const gI=Ve({tensorScatterUpdate_:mI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(r,t){return yc(r,t,"right")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wI(r){const t=de(r,"condition","whereAsync","bool"),e=await t.data(),s=Tb(t.shape,e);return r!==t&&t.dispose(),s}const af=wI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vI(r,t,e){const s=de(r,"tensor","boolMask"),i=de(t,"mask","boolMask","bool"),o=e??0,u=i.rank,l=s.shape;le(u>0,()=>"mask cannot be scalar"),nc(l.slice(o,o+u),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let p=1;for(let I=o;I<o+u;I++)p*=l[I];const d=l.slice(0,o).concat([p],l.slice(o+u)),f=We(s,d),m=We(i,[-1]),w=await af(m),x=Ye(w,[1]),C=zd(f,x,o);return r!==s&&s.dispose(),t!==i&&i.dispose(),x.dispose(),f.dispose(),m.dispose(),w.dispose(),C}const bI=vI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(r,t,e,s,i=!0){const o=de(r,"v","movingAverage"),u=de(t,"x","movingAverage"),l=de(e,"decay","movingAverage");Rb(o,u),le(Cr(o.shape,u.shape),()=>"Shape mismatch in v and x");const p=Yt(1),d=Er(p,l);let f=it(Er(u,o),d);if(i){le(s!=null,()=>"When using zeroDebias: true, step is required.");const m=de(s,"step","movingAverage");f=Et(f,Er(p,Bd(l,m)))}return gt(o,f)}const SI=Ve({movingAverage_:xI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(r,t,e){Xo(e);const s=de(r,"indices","scatterND","int32"),i=de(t,"updates","scatterND");Fd(i,s,e);const o={indices:s,updates:i},u={shape:e};return xt.runKernel(Wd,o,u)}const NI=Ve({scatterND_:CI});function II(r,t,e,s){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);const i=r.rank>0?r.shape[0]:1,o=r.rank>1?r.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);const u=t.size;if(!(t.rank===0||t.rank===1&&u===i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(r,t,e,s=0){Xo(e);const i=de(r,"sparseIndices","sparseToDense","int32"),o=de(t,"sparseValues","sparseToDense","string_or_numeric"),u=de(s,"defaultValue","sparseToDense",o.dtype);II(i,o,e,u);const l={sparseIndices:i,sparseValues:o,defaultValue:u},p={outputShape:e};return xt.runKernel(Vd,l,p)}const _I=Ve({sparseToDense_:kI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(r,t){const e=de(t,"indices","gatherND","int32"),i={params:de(r,"x","gatherND","string_or_numeric"),indices:e};return xt.runKernel(Ud,i)}const RI=Ve({gatherND_:TI});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function AI(r,t,e=1){const s=de(r,"predictions","inTopK"),i=de(t,"targets","inTopK");le(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),le(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),nc(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];le(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);const u=await s.data(),l=await i.data(),[p,d]=[u.length/o,o],f=sc("bool",p);for(let m=0;m<p;m++){const w=m*d,x=u.subarray(w,w+d),C=[];for(let I=0;I<x.length;I++)C.push({value:x[I],index:I});C.sort((I,k)=>k.value-I.value),f[m]=0;for(let I=0;I<e;I++)if(C[I].index===l[m]){f[m]=1;break}}return r!==s&&s.dispose(),t!==i&&i.dispose(),oi(f,i.shape,"bool")}const PI=AI;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $I({x:r,filter:t,strides:e,pad:s,dataFormat:i="NHWC",dilations:o=[1,1],dimRoundingMode:u,bias:l,activation:p="linear",preluActivationWeights:d,leakyreluAlpha:f}){if(Ab(xt.state.gradientDepth,p)===!1){let V=Md(r,t,e,s,i,o,u);return l!=null&&(V=gt(V,l)),Pb(V,p,d,f)}const m=de(r,"x","depthwiseConv2d","float32"),w=de(t,"filter","depthwiseConv2d","float32");let x=m,C=!1;m.rank===3&&(C=!0,x=We(m,[1,m.shape[0],m.shape[1],m.shape[2]])),le(x.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x.rank}.`),le(w.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${w.rank}.`),le(x.shape[3]===w.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${x.shape[3]}) must match the inChannels dimension in filter ${w.shape[2]}.`),o==null&&(o=[1,1]),le(ic(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),$b("fused depthwiseConv2d",s,u);const I=ln(x.shape,w.shape,e,o,s,u,!0);let k;l!=null&&(k=de(l,"bias","fused conv2d"),[k]=Eb(k,m),an(I.outShape,k.shape));let P;d!=null&&(P=de(d,"prelu weights","fused depthwiseConv2d"));const O=(V,G)=>{le(Db(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[M,Y,K,J]=G,ne=Ob(V,K,p),me=Fb(Y.shape,ne,M,e,s,o,u),ce=Lb(Y,ne,M.shape,e,s,o,u);if(J!=null){const ye=zb(k,ne);return[me,ce,ye]}return[me,ce]},z={x,filter:w,bias:k,preluActivationWeights:P},F={strides:e,pad:s,dataFormat:i,dilations:o,dimRoundingMode:u,activation:p,leakyreluAlpha:f};return l==null?wp((G,M,Y)=>{let K=xt.runKernel($l,z,F);return Y([M,G,K]),C&&(K=We(K,[K.shape[1],K.shape[2],K.shape[3]])),{value:K,gradFunc:O}})(x,w):wp((G,M,Y,K)=>{let J=xt.runKernel($l,z,F);return K([M,G,J,Y]),C&&(J=We(J,[J.shape[1],J.shape[2],J.shape[3]])),{value:J,gradFunc:O}})(x,w,k)}const EI=Ve({fusedDepthwiseConv2d_:$I});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DI=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Bb,depthwiseConv2d:EI,matMul:Wb},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OI="model",FI=".json",LI=".weights.bin";function Np(r){return new Promise(t=>setTimeout(t)).then(r)}class ms{constructor(t){if(!Qe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ms.URL_SCHEME)&&(t=t.slice(ms.URL_SCHEME.length)),(t==null||t.length===0)&&(t=OI),this.modelJsonFileName=t+FI,this.weightDataFileName=t+LI}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=Yo.join(t.weightData),s=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=Hd(t,i),u=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=u,await Np(()=>l.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const p=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;p.download=this.weightDataFileName,p.href=s,await Np(()=>p.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:uc(t)}}}}ms.URL_SCHEME="downloads://";class zI{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const s=new FileReader;s.onload=i=>{const o=JSON.parse(i.target.result),u=o.modelTopology;if(u==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:u});return}const p=ac(o,d=>this.loadWeights(d));t(p)},s.onerror=i=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const e=[],s=[];for(const u of t)e.push(...u.weights),s.push(...u.paths);const i=this.checkManifestAndWeightFiles(t),o=s.map(u=>this.loadWeightsFile(u,i[u]));return Promise.all(o).then(u=>[e,u])}loadWeightsFile(t,e){return new Promise((s,i)=>{const o=new FileReader;o.onload=u=>{const l=u.target.result;s(l)},o.onerror=u=>i(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],s=this.weightsFiles.map(o=>vp(o.name)),i={};for(const o of t)o.paths.forEach(u=>{const l=vp(u);if(e.indexOf(l)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${l}'`);if(e.push(l),s.indexOf(l)===-1)throw new Error(`Weight file with basename '${l}' is not provided.`);i[u]=this.weightsFiles[s.indexOf(l)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const BI=r=>Qe().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ms.URL_SCHEME)?WI(r.slice(ms.URL_SCHEME.length)):null;oc.registerSaveRouter(BI);function WI(r="model"){return new ms(r)}function VI(r){return new zI(r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(r,t,e,s){u(r),e=e??0,s=s??1,l(e,s);let i=0;const o=p=>(p.then(d=>{const f=e+ ++i/r.length*(s-e);return t(f),d}),p);function u(p){le(p!=null&&Array.isArray(p)&&p.length>0,()=>"promises must be a none empty array")}function l(p,d){le(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${p}`),le(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),le(d>=p,()=>`startFraction must be no more than endFraction, but got startFraction ${p} and endFraction ${d}`)}return Promise.all(r.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function of(r,t){t==null&&(t={});const e=t.fetchFunc==null?Qe().platform.fetch:t.fetchFunc,s=r.map(m=>e(m,t.requestInit,{isBinary:!0})),l=(t.onProgress==null?await Promise.all(s):await Ip(s,t.onProgress,0,.5)).map(m=>m.arrayBuffer());return t.onProgress==null?await Promise.all(l):await Ip(l,t.onProgress,.5,1)}function UI(r,t){var e;const s=t.fetchFunc==null?Qe().platform.fetch:t.fetchFunc;let i=0,o;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async u=>{for(var l;i<r.length;){o||(o=(await s(r[i],t.requestInit,{isBinary:!0})).body.getReader());const{done:p,value:d}=await o.read();if(p){i++,o=void 0,(l=t.onProgress)===null||l===void 0||l.call(t,i/r.length);continue}u.enqueue(d);return}u.close()}})}async function MI(r,t="",e,s){return uf(u=>of(u,{requestInit:s}))(r,t,e)}function uf(r){return async(t,e="",s)=>{const i=t.map(()=>!1),o={},u=s!=null?s.map(()=>!1):[],l=[];if(t.forEach((x,C)=>{let I=0;x.weights.forEach(k=>{const P="quantization"in k?k.quantization.dtype:k.dtype,O=Vb[P]*Ce(k.shape),z=()=>{i[C]=!0,o[C]==null&&(o[C]=[]),o[C].push({manifestEntry:k,groupOffset:I,sizeBytes:O})};s!=null?s.forEach((F,V)=>{F===k.name&&(z(),u[V]=!0)}):z(),l.push(k.name),I+=O})}),!u.every(x=>x)){const x=s.filter((C,I)=>!u[I]);throw new Error(`Could not find weights in manifest with names: ${x.join(", ")}. 
Manifest JSON has weights with names: ${l.join(", ")}.`)}const p=i.reduce((x,C,I)=>(C&&x.push(I),x),[]),d=[];p.forEach(x=>{t[x].paths.forEach(C=>{const I=e+(e.endsWith("/")?"":"/")+C;d.push(I)})});const f=await r(d),m={};let w=0;return p.forEach(x=>{const C=t[x].paths.length,I=new Yo(f.slice(w,w+C));o[x].forEach(P=>{const O=I.slice(P.groupOffset,P.groupOffset+P.sizeBytes),z=Gd(O,[P.manifestEntry]);for(const F in z)m[F]=z[F]}),w+=C}),m}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HI="application/octet-stream",GI="application/json";class wc{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(le(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Qe().platform.fetch,le(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&le(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],i=Hd(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(i)],{type:GI}),"model.json"),t.weightData!=null){const u=Yo.join(t.weightData);e.body.append("model.weights.bin",new Blob([u],{type:HI}),"model.weights.bin")}const o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:uc(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let u=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?u+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":u+=" Please make sure the server is serving valid JSON for this request.",new Error(u)}const s=e.modelTopology,i=e.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return ac(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=El(t.weightsManifest),i=()=>UI(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=jI(e),o=this.weightPathPrefix||s,u=[],l=[];for(const p of t)for(const d of p.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):u.push(o+d+i);return this.weightUrlConverter&&u.push(...await Promise.all(l)),u}async loadWeights(t){const e=await this.getWeightUrls(t),s=El(t),i=await of(e,this.loadOptions);return[s,i]}}wc.URL_SCHEME_REGEX=/^https?:\/\//;function jI(r){const t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),s=r.substring(0,t),i=e>t?r.substring(e):"";return[s+"/",i]}function Ol(r){return r.match(wc.URL_SCHEME_REGEX)!=null}const lf=(r,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(s=>Ol(s)):e=Ol(r),e)return vc(r,t)}return null};oc.registerSaveRouter(lf);oc.registerLoadRouter(lf);function vc(r,t){return new wc(r,t)}function KI(r,t){return vc(r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wl{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class cf{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class qI{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function XI(r,t,e,s){const i=arguments;return new qI(hf(...i))}function hf(r,t,e,s){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new wl(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wl({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wl({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:s}))}function YI(r){return new cf(r)}function QI(r){return new cf(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pf=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Yo,browserFiles:VI,browserHTTPRequest:KI,concatenateArrayBuffers:Ub,copyModel:Mb,decodeWeights:Gd,decodeWeightsStream:jd,encodeWeights:Hb,fromMemory:XI,fromMemorySync:hf,getLoadHandlers:Gb,getModelArtifactsForJSON:ac,getModelArtifactsForJSONSync:jb,getModelArtifactsInfoForJSON:uc,getSaveHandlers:Kb,getWeightSpecs:El,http:vc,isHTTPScheme:Ol,listModels:qb,loadWeights:MI,moveModel:Xb,registerLoadRouter:Yb,registerSaveRouter:Qb,removeModel:Zb,weightsLoaderFactory:uf,withSaveHandler:YI,withSaveHandlerSync:QI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZI={};function df(r){return ZI[r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v(r,t,e,s,i){const o=t.inputParams[r];if(o&&o.inputIndexStart!==void 0){const l=o.inputIndexStart,p=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?l+1:o.inputIndexEnd,d=l<0?t.inputNames.length+l:l;if(o.type==="tensor")return Nt(t.inputNames[d],e,s,i);if(o.type==="tensors"){const w=t.inputs.slice(l,p);return t.inputNames.slice(l,p).filter((C,I)=>{var k;return((k=w[I])===null||k===void 0?void 0:k.op)!=="NoOp"}).map(C=>Nt(C,e,s,i))}const f=Nt(t.inputNames[d],e,s,i),m=f.dataSync();return o.type==="number"?m[0]:Jb(f.shape,m)}const u=t.attrParams[r];return u&&u.value}function Nt(r,t,e,s){const[i,o]=Xt(r,e);if(s!=null){const l=s.getHashTableHandleByName(i);if(l!=null)return l}const u=e.currentContextIds.find(l=>!!t[Mo(i,l)]);return u!==void 0?t[Mo(i,u)][o]:void 0}function kp(r,t,e){return t[Mo(r,e.currentContextId)]}function nn(r,t){const[e,s,i]=Xt(r,t);return[Mo(e,t&&t.currentContextId),s,i]}function Mo(r,t){return t?`${r}-${t}`:r}function Xt(r,t){if(r==="")return["",0,void 0];const e=t!=null&&t.parseNodeNameCache!=null;if(e){const o=t.parseNodeNameCache.get(r);if(o!=null)return o}const s=r.split(":");let i;if(s.length===1)i=[r,0,void 0];else{const o=s[0],u=s.length===3?s[1]:void 0,l=Number(s[s.length-1]);i=[o,l,u]}return e&&t.parseNodeNameCache.set(r,i),i}function Bo(r,t,e){let s=v("pad",r,t,e);if(s==="explicit"){s=v("explicitPaddings",r,t,e);const i=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)i[o][0]=s[o*2],i[o][1]=s[o*2+1];return i}return s}function sn(r){return r.kept?r:Kd(r)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JI=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ek=Object.freeze(Object.defineProperty({__proto__:null,json:JI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tk=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],rk=Object.freeze(Object.defineProperty({__proto__:null,json:tk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nk=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],sk=Object.freeze(Object.defineProperty({__proto__:null,json:nk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ik=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],ak=Object.freeze(Object.defineProperty({__proto__:null,json:ik},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ok=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],uk=Object.freeze(Object.defineProperty({__proto__:null,json:ok},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lk=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ck=Object.freeze(Object.defineProperty({__proto__:null,json:lk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],pk=Object.freeze(Object.defineProperty({__proto__:null,json:hk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dk=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],fk=Object.freeze(Object.defineProperty({__proto__:null,json:dk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gk=Object.freeze(Object.defineProperty({__proto__:null,json:mk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yk=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],wk=Object.freeze(Object.defineProperty({__proto__:null,json:yk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],bk=Object.freeze(Object.defineProperty({__proto__:null,json:vk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xk=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Sk=Object.freeze(Object.defineProperty({__proto__:null,json:xk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Nk=Object.freeze(Object.defineProperty({__proto__:null,json:Ck},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],kk=Object.freeze(Object.defineProperty({__proto__:null,json:Ik},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Tk=Object.freeze(Object.defineProperty({__proto__:null,json:_k},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Ak=Object.freeze(Object.defineProperty({__proto__:null,json:Rk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pk=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],$k=Object.freeze(Object.defineProperty({__proto__:null,json:Pk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ek=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Dk=Object.freeze(Object.defineProperty({__proto__:null,json:Ek},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Fk=Object.freeze(Object.defineProperty({__proto__:null,json:Ok},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _p{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[ek,rk,sk,ak,uk,ck,pk,fk,gk,wk,bk,Sk,Nk,kk,Tk,Ak,$k,Dk,Fk],e=[].concat(...t.map(s=>s.json));this.opMappers=e.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(t,e={}){const s=t.node,i=[],o=[],u=[],l=s.reduce((I,k)=>(I[k.name]=this.mapNode(k),k.op.startsWith("Placeholder")?i.push(I[k.name]):k.op==="Const"?o.push(I[k.name]):(k.input==null||k.input.length===0)&&u.push(I[k.name]),I),{});let p=[];const d=[];let f={},m={};e!=null&&(f=this.mapSignatureEntries(e.inputs),m=this.mapSignatureEntries(e.outputs));const w=Object.keys(l);w.forEach(I=>{const k=l[I];k.inputNames.forEach((P,O)=>{const[z,,F]=nn(P),V=l[z];if(V.outputs!=null){const G=V.outputs.indexOf(F);if(G!==-1){const M=`${z}:${G}`;k.inputNames[O]=M}}k.inputs.push(V),V.children.push(k)})}),Object.keys(m).length===0?w.forEach(I=>{const k=l[I];k.children.length===0&&d.push(k)}):Object.keys(m).forEach(I=>{const[k]=nn(I),P=l[k];P!=null&&(P.signatureKey=m[I],d.push(P))}),Object.keys(f).length>0?Object.keys(f).forEach(I=>{const[k]=nn(I),P=l[k];P&&(P.signatureKey=f[I],p.push(P))}):p=i;let x={};t.library!=null&&t.library.function!=null&&(x=t.library.function.reduce((I,k)=>(I[k.signature.name]=this.mapFunction(k),I),{}));const C={nodes:l,inputs:p,outputs:d,weights:o,placeholders:i,signature:e,functions:x};return u.length>0&&(C.initNodes=u),C}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){const e=df(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(s.inputParams=e.inputs.reduce((i,o)=>(i[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},i),{})),e.attrs!=null&&(s.attrParams=e.attrs.reduce((i,o)=>{const u=o.type;let l;switch(o.type){case"string":l=Fl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Fl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":l=Ml(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ml(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":l=zl(t.attr,o.tfName,o.defaultValue||0),l===void 0&&o.tfDeprecatedName&&(l=zl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":l=Ul(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ul(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":l=Ll(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Ll(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":l=Gl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Gl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":l=Vl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Vl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":l=Hl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Hl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":l=Bl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Bl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":l=Wl(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Wl(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":l=Tp(t.attr,o.tfName,o.defaultValue),l===void 0&&o.tfDeprecatedName&&(l=Tp(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return i[o.name]={value:l,type:u},i},{})),s}mapFunction(t){const e=t.nodeDef,s=[],i=[];let o={};e!=null&&(o=e.reduce((m,w)=>(m[w.name]=this.mapNode(w),w.op==="Const"&&i.push(m[w.name]),m),{}));const u=[],l=[];t.signature.inputArg.forEach(m=>{const[w]=nn(m.name),x={name:w,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bc(m.type),type:"dtype"}},children:[]};x.signatureKey=m.name,u.push(x),o[w]=x}),Object.keys(o).forEach(m=>{const w=o[m];w.inputNames.forEach((x,C)=>{const[I,,k]=nn(x),P=o[I];if(P.outputs!=null){const O=P.outputs.indexOf(k);if(O!==-1){const z=`${I}:${O}`;w.inputNames[C]=z}}w.inputs.push(P),P.children.push(w)})});const d=t.ret;t.signature.outputArg.forEach(m=>{const[w,x]=nn(d[m.name]),C=o[w];C!=null&&(C.defaultOutput=x,l.push(C))});const f=this.mapArgsToSignature(t);return{nodes:o,inputs:u,outputs:l,weights:i,placeholders:s,signature:f}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return e!=null&&(s=e[s]),{name:s,dtype:t.type}}}function Lk(r){const t=Qe().global;if(typeof t.atob<"u")return t.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ff(r,t){const e=Array.isArray(r)?String.fromCharCode.apply(null,r):Lk(r);return t?e:e.toLowerCase()}function Fl(r,t,e,s=!1){const i=r[t];return i!=null?ff(i.s,s):e}function Ll(r,t,e){const s=r[t];return s?s.b:e}function zl(r,t,e){const s=r[t]||{},i=s.i!=null?s.i:s.f!=null?s.f:e;return typeof i=="number"?i:parseInt(i,10)}function bc(r){switch(typeof r=="string"&&(r=gr[r]),r){case gr.DT_FLOAT:case gr.DT_HALF:return"float32";case gr.DT_INT32:case gr.DT_INT64:case gr.DT_INT8:case gr.DT_UINT8:return"int32";case gr.DT_BOOL:return"bool";case gr.DT_DOUBLE:return"float32";case gr.DT_STRING:return"string";case gr.DT_COMPLEX64:case gr.DT_COMPLEX128:return"complex64";default:return null}}function Tp(r,t,e){const s=r[t];return s&&s.func?s.func.name:e}function Bl(r,t,e){const s=r[t];return s&&s.type?bc(s.type):e}function Wl(r,t,e){const s=r[t];return s&&s.list&&s.list.type?s.list.type.map(i=>bc(i)):e}function mf(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Vl(r,t,e){const s=r[t];return s&&s.shape?mf(s.shape):e}function Ul(r,t,e){const s=r[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):e}function Ml(r,t,e,s=!1){const i=r[t];return i&&i.list&&i.list.s?i.list.s.map(o=>ff(o,s)):e}function Hl(r,t,e){const s=r[t];return s&&s.list&&s.list.shape?s.list.shape.map(i=>mf(i)):e}function Gl(r,t,e){const s=r[t];return s&&s.list&&s.list.b?s.list.b:e}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zk{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(i=>this.getInput(i)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((i,o)=>(i[o]=this.getAttr(o),i),{}))}getInput(t){return Nt(t,this.tensorMap,this.context)}getAttr(t,e){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Nt(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return zl(this.node.rawAttrs,t,e);if(s.s!=null)return Fl(this.node.rawAttrs,t,e);if(s.b!=null)return Ll(this.node.rawAttrs,t,e);if(s.shape!=null)return Vl(this.node.rawAttrs,t,e);if(s.type!=null)return Bl(this.node.rawAttrs,t,e);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Ul(this.node.rawAttrs,t,e);if(s.list.s!=null)return Ml(this.node.rawAttrs,t,e);if(s.list.shape!=null)return Hl(this.node.rawAttrs,t,e);if(s.list.b!=null)return Gl(this.node.rawAttrs,t,e);if(s.list.type!=null)return Wl(this.node.rawAttrs,t,e)}return e}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const It=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:ex,abs:tx,acos:rx,acosh:nx,add:gt,addN:h3,all:sx,any:ix,argMax:qd,argMin:ax,asin:ox,asinh:ux,atan:lx,atan2:cx,atanh:hx,avgPool:px,avgPool3d:dx,basicLSTMCell:d3,batchNorm:fx,batchNorm2d:mx,batchNorm3d:gx,batchNorm4d:yx,batchToSpaceND:wx,bincount:vx,bitwiseAnd:m3,booleanMaskAsync:bI,broadcastArgs:y3,broadcastTo:bx,buffer:Pn,cast:fs,ceil:xx,clipByValue:Xd,clone:Kd,complex:Sx,concat:ds,concat1d:Cx,concat2d:Nx,concat3d:Ix,concat4d:kx,conv1d:_x,conv2d:Tx,conv2dTranspose:Rx,conv3d:Ax,conv3dTranspose:Px,cos:$x,cosh:Ex,cosineWindow:Dx,cumprod:Ox,cumsum:Fx,denseBincount:Lx,depthToSpace:zx,depthwiseConv2d:Md,diag:v3,dilation2d:Bx,div:Et,divNoNan:Wx,dot:Vx,dropout:Ux,einsum:Mx,elu:Hx,enclosingPowerOfTwo:Gx,ensureShape:x3,equal:jx,erf:Kx,euclideanNorm:qx,exp:Dl,expandDims:ui,expm1:Xx,eye:Yx,fft:Qx,fill:Zx,floor:Jx,floorDiv:e1,fused:DI,gather:zd,gatherND:RI,greater:t1,greaterEqual:r1,ifft:n1,imag:s1,image:cs,inTopKAsync:PI,irfft:i1,isFinite:a1,isInf:o1,isNaN:u1,leakyRelu:l1,less:c1,lessEqual:h1,linalg:p1,linspace:S3,localResponseNormalization:d1,log:f1,log1p:m1,logSigmoid:g1,logSoftmax:y1,logSumExp:w1,logicalAnd:v1,logicalNot:b1,logicalOr:x1,logicalXor:S1,losses:C1,lowerBound:N3,matMul:os,max:N1,maxPool:I1,maxPool3d:k1,maxPoolWithArgmax:k3,maximum:_1,mean:T1,meshgrid:_3,min:R1,minimum:Yd,mirrorPad:Qd,mod:A1,moments:P1,movingAverage:SI,mul:it,multiRNNCell:R3,multinomial:P3,neg:$1,norm:E1,notEqual:D1,oneHot:O1,ones:ua,onesLike:F1,op:Ve,outerProduct:E3,pad:An,pad1d:O3,pad2d:L3,pad3d:B3,pad4d:V3,pool:L1,pow:Bd,prelu:z1,print:B1,prod:W1,raggedGather:M3,raggedRange:G3,raggedTensorToTensor:K3,rand:X3,randomGamma:Q3,randomNormal:Dd,randomStandardNormal:J3,randomUniform:Od,randomUniformInt:tI,range:V1,real:U1,reciprocal:M1,relu:H1,relu6:G1,reshape:We,reverse:ba,reverse1d:nI,reverse2d:iI,reverse3d:oI,reverse4d:lI,rfft:j1,round:K1,rsqrt:q1,scalar:Yt,scatterND:NI,searchSorted:yc,selu:X1,separableConv2d:Y1,setdiff1dAsync:hI,sigmoid:ls,sign:Q1,signal:Z1,sin:J1,sinh:e2,slice:mt,slice1d:t2,slice2d:r2,slice3d:n2,slice4d:s2,softmax:i2,softplus:a2,spaceToBatchND:o2,sparse:u2,sparseToDense:_I,spectral:l2,split:c2,sqrt:h2,square:Zd,squaredDifference:p2,squeeze:Ye,stack:pa,step:d2,stridedSlice:f2,string:m2,sub:Er,sum:g2,tan:y2,tanh:Pl,tensor:oi,tensor1d:si,tensor2d:Rn,tensor3d:w2,tensor4d:pI,tensor5d:dI,tensor6d:fI,tensorScatterUpdate:gI,tile:v2,topk:b2,transpose:x2,truncatedNormal:S2,unique:C2,unsortedSegmentSum:N2,unstack:xa,upperBound:yI,variable:I2,where:k2,whereAsync:af,zeros:lc,zerosLike:_2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bk=(r,t,e,s=It)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(v("a",r,t,e),v("b",r,t,e))];case"AddN":return[s.addN(v("tensors",r,t,e))];case"FloorMod":case"Mod":return[s.mod(v("a",r,t,e),v("b",r,t,e))];case"Mul":return[s.mul(v("a",r,t,e),v("b",r,t,e))];case"RealDiv":case"Div":return[s.div(v("a",r,t,e),v("b",r,t,e))];case"DivNoNan":return[s.divNoNan(v("a",r,t,e),v("b",r,t,e))];case"FloorDiv":return[s.floorDiv(v("a",r,t,e),v("b",r,t,e))];case"Sub":return[s.sub(v("a",r,t,e),v("b",r,t,e))];case"Minimum":return[s.minimum(v("a",r,t,e),v("b",r,t,e))];case"Maximum":return[s.maximum(v("a",r,t,e),v("b",r,t,e))];case"Pow":return[s.pow(v("a",r,t,e),v("b",r,t,e))];case"SquaredDifference":return[s.squaredDifference(v("a",r,t,e),v("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wk=(r,t,e,s=It)=>{switch(r.op){case"Abs":case"ComplexAbs":return[s.abs(v("x",r,t,e))];case"Acos":return[s.acos(v("x",r,t,e))];case"Acosh":return[s.acosh(v("x",r,t,e))];case"Asin":return[s.asin(v("x",r,t,e))];case"Asinh":return[s.asinh(v("x",r,t,e))];case"Atan":return[s.atan(v("x",r,t,e))];case"Atan2":return[s.atan2(v("x",r,t,e),v("y",r,t,e))];case"Atanh":return[s.atanh(v("x",r,t,e))];case"Ceil":return[s.ceil(v("x",r,t,e))];case"Complex":return[s.complex(v("real",r,t,e),v("imag",r,t,e))];case"Cos":return[s.cos(v("x",r,t,e))];case"Cosh":return[s.cosh(v("x",r,t,e))];case"Elu":return[s.elu(v("x",r,t,e))];case"Erf":return[s.erf(v("x",r,t,e))];case"Exp":return[s.exp(v("x",r,t,e))];case"Expm1":return[s.expm1(v("x",r,t,e))];case"Floor":return[s.floor(v("x",r,t,e))];case"Log":return[s.log(v("x",r,t,e))];case"Log1p":return[s.log1p(v("x",r,t,e))];case"Imag":return[s.imag(v("x",r,t,e))];case"Neg":return[s.neg(v("x",r,t,e))];case"Reciprocal":return[s.reciprocal(v("x",r,t,e))];case"Real":return[s.real(v("x",r,t,e))];case"Relu":return[s.relu(v("x",r,t,e))];case"Round":return[s.round(v("x",r,t,e))];case"Selu":return[s.selu(v("x",r,t,e))];case"Sigmoid":return[s.sigmoid(v("x",r,t,e))];case"Sin":return[s.sin(v("x",r,t,e))];case"Sign":return[s.sign(v("x",r,t,e))];case"Sinh":return[s.sinh(v("x",r,t,e))];case"Softplus":return[s.softplus(v("x",r,t,e))];case"Sqrt":return[s.sqrt(v("x",r,t,e))];case"Square":return[s.square(v("x",r,t,e))];case"Tanh":return[s.tanh(v("x",r,t,e))];case"Tan":return[s.tan(v("x",r,t,e))];case"ClipByValue":return[s.clipByValue(v("x",r,t,e),v("clipValueMin",r,t,e),v("clipValueMax",r,t,e))];case"Relu6":return[s.relu6(v("x",r,t,e))];case"Rsqrt":return[s.rsqrt(Nt(r.inputNames[0],t,e))];case"LeakyRelu":return[s.leakyRelu(v("x",r,t,e),v("alpha",r,t,e))];case"Prelu":return[s.prelu(v("x",r,t,e),v("alpha",r,t,e))];case"IsNan":return[s.isNaN(Nt(r.inputNames[0],t,e))];case"IsInf":return[s.isInf(Nt(r.inputNames[0],t,e))];case"IsFinite":return[s.isFinite(Nt(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){le(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let s=0;s<r.length;s++){const i=r[s],o=t[s];le(i<0||o<0||i===o,()=>e+` Shapes ${r} and ${t} must match`)}}}function Rp(r){return!(typeof r=="number"||r.some(t=>t<0))}function aa(r,t,e){let s=jl(r,e);const i=!Rp(s);if(i&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&t.forEach(o=>{s=jl(o.shape,s)}),!Rp(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function jl(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);const e=[];for(let s=0;s<r.length;++s){const i=r[s],o=t[s];if(i>=0&&o>=0&&i!==o)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[s]=i>=0?i:o}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vk{constructor(t,e,s,i,o,u,l){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=o,this.dynamicSize=u,this.clearAfterRead=l,this.tensors=[],this.closed_=!1,this.idTensor=Yt(0),on(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),yr(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,on(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,i)=>this.write(s,e[i]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let i=0;i<this.size();i++)t.push(i)}if(t.length===0)return oi([],[0].concat(this.elementShape));const s=this.readMany(t);return yr(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),pa(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return oi([],[0].concat(this.elementShape));const e=[];for(let i=0;i<this.size();i++)e.push(i);const s=this.readMany(e);return yr(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ds(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,xa(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0;const i=t.map(p=>(s+=p,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:e.size/s,u=[];tt(()=>{e=We(e,[1,s,o]);for(let p=0;p<t.length;++p){const f=[0,p===0?0:i[p-1],0],m=[1,t[p],o];u[p]=We(mt(e,f,m),this.elementShape)}return u});const l=[];for(let p=0;p<t.length;p++)l[p]=p;this.writeMany(l,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gs{get id(){return this.idTensor.id}constructor(t,e,s,i=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t?.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);yr(e,o.shape,"TensorList shape mismatch: "),on(o)}),this.idTensor=Yt(0),this.maxNumElements=i,on(this.idTensor)}copy(){return new gs([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);yr(t,this.elementShape,"TensorList shape mismatch: ");const i=aa(this.elementShape,this.tensors,t);return tt(()=>{const o=this.tensors.map(u=>We(u,i));return pa(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=aa(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,yr(i.shape,t,"TensorList shape mismatch: "),We(i,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(yr(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");on(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new gs([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)e.tensors[s]=this.tensors[s];return e}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);yr(this.tensors[t].shape,e,"TensorList shape mismatch: ");const i=aa(this.elementShape,this.tensors,e);return We(this.tensors[t],i)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);yr(this.elementShape,e.shape,"TensorList shape mismatch: "),on(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);yr(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=aa(this.elementShape,this.tensors,s);return t.length===0?oi([],[0].concat(i)):tt(()=>{const o=t.map(u=>We(this.tensors[u],i));return pa(o,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);yr(this.elementShape,e,"TensorList shape mismatch: ");const s=aa(this.elementShape,this.tensors,e);return this.size()===0?oi([],[0].concat(s)):tt(()=>{const i=this.tensors.map(o=>We(o,s));return ds(i,0)})}}function Uk(r,t,e){const s=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);const i=r.shape.slice(1);yr(i,t,"TensorList shape mismatch: ");const o=xa(r);return new gs(o,t,s)}function Mk(r,t,e,s){return new gs([],r,t,s)}function Hk(r,t,e,s){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);const i=Math.max(...t);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const o=new gs([],e,r.dtype,s),u=xa(r,0);return t.forEach((l,p)=>{o.setItem(l,u[p])}),o}function Gk(r,t,e){let s=0;const i=t.map(f=>(s+=f,s));if(s!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${r.shape}`);const o=r.shape.slice(1),u=jl(o,e),l=s===0?0:r.size/s,p=tt(()=>{const f=[];r=We(r,[1,s,l]);for(let m=0;m<t.length;++m){const x=[0,m===0?0:i[m-1],0],C=[1,t[m],l];f[m]=We(mt(r,x,C),u)}return r.dispose(),f}),d=new gs([],e,r.dtype,t.length);for(let f=0;f<p.length;f++)d.setItem(f,p[f]);return d}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jk=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{const s=v("thenBranch",r,t,e),i=v("elseBranch",r,t,e),o=v("cond",r,t,e),u=v("args",r,t,e);return(await o.data())[0]?e.functionMap[s].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap):e.functionMap[i].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{const s=v("body",r,t,e),i=v("cond",r,t,e),o=v("args",r,t,e),u=await e.functionMap[i].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap),l=o.map(f=>f.id);let p=await u[0].data();u.forEach(f=>{!f.kept&&l.indexOf(f.id)===-1&&f.dispose()});let d=o;for(;p[0];){const f=d;d=await e.functionMap[s].executeFunctionAsync(d,e.tensorArrayMap,e.tensorListMap);const m=d.map(x=>x.id);f.forEach(x=>{!x.kept&&l.indexOf(x.id)===-1&&m.indexOf(x.id)===-1&&x.dispose()});const w=await e.functionMap[i].executeFunctionAsync(d,e.tensorArrayMap,e.tensorListMap);p=await w[0].data(),w.forEach(x=>{!x.kept&&l.indexOf(x.id)===-1&&m.indexOf(x.id)===-1&&x.dispose()})}return d}case"LoopCond":{const s=v("pred",r,t,e);return[sn(s)]}case"Switch":{const s=v("pred",r,t,e);let i=v("data",r,t,e);return i.kept||(i=sn(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=r.inputNames.find(i=>Nt(i,t,e)!==void 0);if(s){const i=Nt(s,t,e);return[sn(i)]}return}case"Enter":{const s=v("frameName",r,t,e),i=v("tensor",r,t,e);return e.enterFrame(s),[sn(i)]}case"Exit":{const s=v("tensor",r,t,e);return e.exitFrame(),[sn(s)]}case"NextIteration":{const s=v("tensor",r,t,e);return e.nextIteration(),[sn(s)]}case"TensorArrayV3":{const s=v("size",r,t,e),i=v("dtype",r,t,e),o=v("elementShape",r,t,e),u=v("dynamicSize",r,t,e),l=v("clearAfterRead",r,t,e),p=v("identicalElementShapes",r,t,e),d=v("name",r,t,e),f=new Vk(d,i,s,o,p,u,l);return e.addTensorArray(f),[f.idTensor,Yt(1)]}case"TensorArrayWriteV3":{const s=v("tensorArrayId",r,t,e),i=v("index",r,t,e),o=v("tensor",r,t,e),u=e.getTensorArray(s.id);return u.write(i,o),[u.idTensor]}case"TensorArrayReadV3":{const s=v("tensorArrayId",r,t,e),i=v("index",r,t,e);return[e.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=v("tensorArrayId",r,t,e),i=v("indices",r,t,e),o=v("dtype",r,t,e);return[e.getTensorArray(s.id).gather(i,o)]}case"TensorArrayScatterV3":{const s=v("tensorArrayId",r,t,e),i=v("indices",r,t,e),o=v("tensor",r,t,e),u=e.getTensorArray(s.id);return u.scatter(i,o),[u.idTensor]}case"TensorArrayConcatV3":{const s=v("tensorArrayId",r,t,e),i=e.getTensorArray(s.id),o=v("dtype",r,t,e);return[i.concat(o)]}case"TensorArraySplitV3":{const s=v("tensorArrayId",r,t,e),i=v("tensor",r,t,e),o=v("lengths",r,t,e),u=e.getTensorArray(s.id);return u.split(o,i),[u.idTensor]}case"TensorArraySizeV3":{const s=v("tensorArrayId",r,t,e),i=e.getTensorArray(s.id);return[Yt(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=v("tensorArrayId",r,t,e),i=e.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=v("tensorListId",r,t,e),i=v("index",r,t,e),o=v("tensor",r,t,e),u=e.getTensorList(s.id);return u.setItem(i,o),[u.idTensor]}case"TensorListGetItem":{const s=v("tensorListId",r,t,e),i=v("index",r,t,e),o=v("elementShape",r,t,e),u=v("elementDType",r,t,e);return[e.getTensorList(s.id).getItem(i,o,u)]}case"TensorListScatterV2":case"TensorListScatter":{const s=v("indices",r,t,e),i=v("tensor",r,t,e),o=v("elementShape",r,t,e),u=v("numElements",r,t,e),l=Hk(i,s,o,u);return e.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=v("elementShape",r,t,e),i=v("elementDType",r,t,e);let o;r.op==="TensorListReserve"?o="numElements":o="maxNumElements";const u=v(o,r,t,e),l=r.op==="TensorListReserve"?-1:u,p=Mk(s,i,u,l);return e.addTensorList(p),[p.idTensor]}case"TensorListGather":{const s=v("tensorListId",r,t,e),i=v("indices",r,t,e),o=v("elementShape",r,t,e),u=v("elementDType",r,t,e);return[e.getTensorList(s.id).gather(i,u,o)]}case"TensorListStack":{const s=v("tensorListId",r,t,e),i=v("elementShape",r,t,e),o=v("elementDType",r,t,e),u=v("numElements",r,t,e);return[e.getTensorList(s.id).stack(i,o,u)]}case"TensorListFromTensor":{const s=v("tensor",r,t,e),i=v("elementShape",r,t,e),o=v("elementDType",r,t,e),u=Uk(s,i,o);return e.addTensorList(u),[u.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=v("tensorListId",r,t,e),i=e.getTensorList(s.id),o=v("dtype",r,t,e),u=v("elementShape",r,t,e);return[i.concat(o,u)]}case"TensorListPushBack":{const s=v("tensorListId",r,t,e),i=v("tensor",r,t,e),o=e.getTensorList(s.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const s=v("tensorListId",r,t,e),i=v("elementShape",r,t,e),o=v("elementDType",r,t,e);return[e.getTensorList(s.id).popBack(i,o)]}case"TensorListSplit":{const s=v("tensor",r,t,e),i=v("elementShape",r,t,e),o=v("lengths",r,t,e),u=Gk(s,o,i);return e.addTensorList(u),[u.idTensor]}case"TensorListLength":{const s=v("tensorListId",r,t,e),i=e.getTensorList(s.id);return[Yt(i.size(),"int32")]}case"TensorListResize":{const s=v("tensorListId",r,t,e),i=v("size",r,t,e),u=e.getTensorList(s.id).resize(i);return e.addTensorList(u),[u.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(r,t,e){const[s,i]=v("fusedOps",r,t,e),o=s==="biasadd",u=!o,l=i==="prelu",p=s==="fusedbatchnorm",d=v("numArgs",r,t,e);if(o){if(l&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&o&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const f=v("strides",r,t,e),m=Bo(r,t,e),w=v("dataFormat",r,t,e).toUpperCase(),x=v("dilations",r,t,e);let[C,I]=v("args",r,t,e);u&&(I=C,C=void 0);const k=v("leakyreluAlpha",r,t,e);return{stride:f,pad:m,dataFormat:w,dilations:x,biasArg:C,preluArg:I,activationFunc:i,leakyreluAlpha:k}}const Kk=(r,t,e,s=It)=>{switch(r.op){case"Conv1D":{const i=v("stride",r,t,e),o=v("pad",r,t,e),u=v("dataFormat",r,t,e).toUpperCase(),l=v("dilation",r,t,e);return[s.conv1d(v("x",r,t,e),v("filter",r,t,e),i,o,u,l)]}case"Conv2D":{const i=v("strides",r,t,e),o=Bo(r,t,e),u=v("dataFormat",r,t,e).toUpperCase(),l=v("dilations",r,t,e);return[s.conv2d(v("x",r,t,e),v("filter",r,t,e),[i[1],i[2]],o,u,[l[1],l[2]])]}case"_FusedConv2D":{const{stride:i,pad:o,dataFormat:u,dilations:l,biasArg:p,preluArg:d,activationFunc:f,leakyreluAlpha:m}=Ap(r,t,e);return[s.fused.conv2d({x:v("x",r,t,e),filter:v("filter",r,t,e),strides:[i[1],i[2]],pad:o,dataFormat:u,dilations:[l[1],l[2]],bias:p,activation:f,preluActivationWeights:d,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:o,dataFormat:u,dilations:l,biasArg:p,preluArg:d,activationFunc:f,leakyreluAlpha:m}=Ap(r,t,e);return[s.fused.depthwiseConv2d({x:v("x",r,t,e),filter:v("filter",r,t,e),strides:[i[1],i[2]],pad:o,dataFormat:u,dilations:[l[1],l[2]],bias:p,activation:f,preluActivationWeights:d,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=v("outputShape",r,t,e),o=v("strides",r,t,e),u=Bo(r,t,e);return[s.conv2dTranspose(v("x",r,t,e),v("filter",r,t,e),i,[o[1],o[2]],u)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=v("strides",r,t,e),o=Bo(r,t,e),u=v("dilations",r,t,e),l=v("dataFormat",r,t,e).toUpperCase();return[s.depthwiseConv2d(v("input",r,t,e),v("filter",r,t,e),[i[1],i[2]],o,l,[u[1],u[2]])]}case"Conv3D":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("dataFormat",r,t,e).toUpperCase(),l=v("dilations",r,t,e);return[s.conv3d(v("x",r,t,e),v("filter",r,t,e),[i[1],i[2],i[3]],o,u,[l[1],l[2],l[3]])]}case"AvgPool":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("kernelSize",r,t,e);return[s.avgPool(v("x",r,t,e),[u[1],u[2]],[i[1],i[2]],o)]}case"MaxPool":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("kernelSize",r,t,e);return[s.maxPool(v("x",r,t,e),[u[1],u[2]],[i[1],i[2]],o)]}case"MaxPoolWithArgmax":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("kernelSize",r,t,e),l=v("includeBatchInIndex",r,t,e),{result:p,indexes:d}=s.maxPoolWithArgmax(v("x",r,t,e),[u[1],u[2]],[i[1],i[2]],o,l);return[p,d]}case"AvgPool3D":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("kernelSize",r,t,e);return[s.avgPool3d(v("x",r,t,e),[u[1],u[2],u[3]],[i[1],i[2],i[3]],o)]}case"MaxPool3D":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("kernelSize",r,t,e);return[s.maxPool3d(v("x",r,t,e),[u[1],u[2],u[3]],[i[1],i[2],i[3]],o)]}case"Dilation2D":{const i=v("strides",r,t,e),o=v("pad",r,t,e),u=v("dilations",r,t,e),l=i[1],p=i[2],d=u[1],f=u[2];return[s.dilation2d(v("x",r,t,e),v("filter",r,t,e),[l,p],o,[d,f],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qk=(r,t,e,s=It)=>{switch(r.op){case"Fill":{const i=v("shape",r,t,e),o=v("dtype",r,t,e),u=v("value",r,t,e);return[s.fill(i,u,o)]}case"LinSpace":{const i=v("start",r,t,e),o=v("stop",r,t,e),u=v("num",r,t,e);return[s.linspace(i,o,u)]}case"Multinomial":{const i=v("logits",r,t,e),o=v("numSamples",r,t,e),u=v("seed",r,t,e);return[s.multinomial(i,o,u)]}case"OneHot":{const i=v("indices",r,t,e),o=v("depth",r,t,e),u=v("onValue",r,t,e),l=v("offValue",r,t,e),p=v("dtype",r,t,e);return[s.oneHot(i,o,u,l,p)]}case"Ones":return[s.ones(v("shape",r,t,e),v("dtype",r,t,e))];case"OnesLike":return[s.onesLike(v("x",r,t,e))];case"RandomStandardNormal":return[s.randomStandardNormal(v("shape",r,t,e),v("dtype",r,t,e),v("seed",r,t,e))];case"RandomUniform":return[s.randomUniform(v("shape",r,t,e),v("minval",r,t,e),v("maxval",r,t,e),v("dtype",r,t,e))];case"RandomUniformInt":return[s.randomUniformInt(v("shape",r,t,e),v("minval",r,t,e),v("maxval",r,t,e),v("seed",r,t,e))];case"Range":{const i=v("start",r,t,e),o=v("stop",r,t,e),u=v("step",r,t,e);return[s.range(i,o,u,v("dtype",r,t,e))]}case"TruncatedNormal":{const i=v("shape",r,t,e),o=v("mean",r,t,e),u=v("stdDev",r,t,e),l=v("seed",r,t,e);return[s.truncatedNormal(i,o,u,v("dtype",r,t,e),l)]}case"Zeros":return[s.zeros(v("shape",r,t,e),v("dtype",r,t,e))];case"ZerosLike":return[s.zerosLike(v("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(r,t,e){const s=v("boxes",r,t,e),i=v("scores",r,t,e),o=v("maxOutputSize",r,t,e),u=v("iouThreshold",r,t,e),l=v("scoreThreshold",r,t,e),p=v("softNmsSigma",r,t,e);return{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:p}}const Xk=async(r,t,e,s,i=It)=>{switch(r.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:u,maxOutputSize:l,iouThreshold:p,scoreThreshold:d,softNmsSigma:f}=vl(r,t,e),m=await i.image.nonMaxSuppressionWithScoreAsync(o,u,l,p,d,f);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:u,maxOutputSize:l,iouThreshold:p,scoreThreshold:d}=vl(r,t,e),f=v("padToMaxOutputSize",r,t,e),m=await i.image.nonMaxSuppressionPaddedAsync(o,u,l,p,d,f);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:u,maxOutputSize:l,iouThreshold:p,scoreThreshold:d}=vl(r,t,e);return[await i.image.nonMaxSuppressionAsync(o,u,l,p,d)]}case"Where":{const o=i.cast(v("condition",r,t,e),"bool"),u=[await i.whereAsync(o)];return o.dispose(),u}case"ListDiff":return i.setdiff1dAsync(v("x",r,t,e),v("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=(r,t,e,s=It)=>{switch(r.op){case"LowerBound":{const i=v("sortedSequence",r,t,e),o=v("values",r,t,e);return[s.lowerBound(i,o)]}case"TopKV2":{const i=v("x",r,t,e),o=v("k",r,t,e),u=v("sorted",r,t,e),l=s.topk(i,o,u);return[l.values,l.indices]}case"UpperBound":{const i=v("sortedSequence",r,t,e),o=v("values",r,t,e);return[s.upperBound(i,o)]}case"Unique":{const i=v("x",r,t,e),o=s.unique(i);return[o.values,o.indices]}case"UniqueV2":{const i=v("x",r,t,e),o=v("axis",r,t,e),u=s.unique(i,o);return[u.values,u.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=(r,t,e,s=It)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":const i=v("default",r,t,e);return[Nt(r.name,t,e)||i];case"Placeholder":return[Nt(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const f=v("x",r,t,e);return[sn(f)]}case"IdentityN":return v("x",r,t,e).map(f=>sn(f));case"Snapshot":const o=v("x",r,t,e);return[sn(o)];case"Shape":return[s.tensor1d(v("x",r,t,e).shape,"int32")];case"ShapeN":return v("x",r,t,e).map(f=>s.tensor1d(f.shape));case"Size":return[s.scalar(v("x",r,t,e).size,"int32")];case"Rank":return[s.scalar(v("x",r,t,e).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const u=v("x",r,t,e),l=v("data",r,t,e),p=v("message",r,t,e),d=v("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(p);for(let f=0;f<l.length;f++)console.log(Array.prototype.slice.call(l[f].dataSync()).slice(0,d));return[u];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zk{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Yt(0),this.tensorMap=new Map,on(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Yt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),tt(()=>{const i=xa(e),o=s.length,u=i.length;le(o===u,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${u} elements.`);for(let l=0;l<o;l++){const p=s[l],d=i[l];on(d),this.tensorMap.set(p,d)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return tt(()=>{const i=[];for(let o=0;o<s.length;o++){const u=s[o],l=this.findWithDefault(u,e);i.push(l)}return pa(i)})}findWithDefault(t,e){const s=this.tensorMap.get(t);return s??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jk=async(r,t,e,s)=>{switch(r.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(r.name);if(i!=null)return[i];{const o=v("keyDType",r,t,e),u=v("valueDType",r,t,e),l=new Zk(o,u);return s.addHashTable(r.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=v("tableHandle",r,t,e,s),o=v("keys",r,t,e),u=v("values",r,t,e);return[await s.getHashTableById(i.id).import(o,u)]}case"LookupTableFind":case"LookupTableFindV2":{const i=v("tableHandle",r,t,e,s),o=v("keys",r,t,e),u=v("defaultValue",r,t,e);return[await s.getHashTableById(i.id).find(o,u)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=v("tableHandle",r,t,e,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e_=(r,t,e,s=It)=>{switch(r.op){case"ResizeBilinear":{const i=v("images",r,t,e),o=v("size",r,t,e),u=v("alignCorners",r,t,e),l=v("halfPixelCenters",r,t,e);return[s.image.resizeBilinear(i,[o[0],o[1]],u,l)]}case"ResizeNearestNeighbor":{const i=v("images",r,t,e),o=v("size",r,t,e),u=v("alignCorners",r,t,e),l=v("halfPixelCenters",r,t,e);return[s.image.resizeNearestNeighbor(i,[o[0],o[1]],u,l)]}case"CropAndResize":{const i=v("image",r,t,e),o=v("boxes",r,t,e),u=v("boxInd",r,t,e),l=v("cropSize",r,t,e),p=v("method",r,t,e),d=v("extrapolationValue",r,t,e);return[s.image.cropAndResize(i,o,u,l,p,d)]}case"ImageProjectiveTransformV3":{const i=v("images",r,t,e),o=v("transforms",r,t,e),u=v("outputShape",r,t,e),l=v("fillValue",r,t,e),p=v("interpolation",r,t,e),d=v("fillMode",r,t,e);return[s.image.transform(i,o,p.toLowerCase(),d.toLowerCase(),l,u)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t_=(r,t,e,s=It)=>{switch(r.op){case"Equal":return[s.equal(v("a",r,t,e),v("b",r,t,e))];case"NotEqual":return[s.notEqual(v("a",r,t,e),v("b",r,t,e))];case"Greater":return[s.greater(v("a",r,t,e),v("b",r,t,e))];case"GreaterEqual":return[s.greaterEqual(v("a",r,t,e),v("b",r,t,e))];case"Less":return[s.less(v("a",r,t,e),v("b",r,t,e))];case"LessEqual":return[s.lessEqual(v("a",r,t,e),v("b",r,t,e))];case"LogicalAnd":return[s.logicalAnd(v("a",r,t,e),v("b",r,t,e))];case"LogicalNot":return[s.logicalNot(v("a",r,t,e))];case"LogicalOr":return[s.logicalOr(v("a",r,t,e),v("b",r,t,e))];case"Select":case"SelectV2":return[s.where(v("condition",r,t,e),v("a",r,t,e),v("b",r,t,e))];case"BitwiseAnd":return[s.bitwiseAnd(v("a",r,t,e),v("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_=(r,t,e,s=It)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(v("a",r,t,e),v("b",r,t,e),v("transposeA",r,t,e),v("transposeB",r,t,e))];case"Einsum":return[s.einsum(v("equation",r,t,e),...v("tensors",r,t,e))];case"Transpose":return[s.transpose(v("x",r,t,e),v("perm",r,t,e))];case"_FusedMatMul":const[i,o]=v("fusedOps",r,t,e),u=i==="biasadd",l=o==="prelu",p=v("numArgs",r,t,e),d=v("leakyreluAlpha",r,t,e);if(u){if(l&&p!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&p!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[f,m]=v("args",r,t,e);return[s.fused.matMul({a:v("a",r,t,e),b:v("b",r,t,e),transposeA:v("transposeA",r,t,e),transposeB:v("transposeB",r,t,e),bias:f,activation:o,preluActivationWeights:m,leakyreluAlpha:d})];case"MatrixBandPart":return[s.linalg.bandPart(v("a",r,t,e),v("numLower",r,t,e),v("numUpper",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_=(r,t,e,s=It)=>{switch(r.op){case"EuclideanNorm":return[s.euclideanNorm(v("x",r,t,e),v("axis",r,t,e),v("keepDims",r,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(v("x",r,t,e),v("mean",r,t,e),v("variance",r,t,e),v("offset",r,t,e),v("scale",r,t,e),v("epsilon",r,t,e))];case"FusedBatchNormV3":return[s.batchNorm(v("x",r,t,e),v("mean",r,t,e),v("variance",r,t,e),v("offset",r,t,e),v("scale",r,t,e),v("epsilon",r,t,e))];case"LRN":return[s.localResponseNormalization(v("x",r,t,e),v("radius",r,t,e),v("bias",r,t,e),v("alpha",r,t,e),v("beta",r,t,e))];case"Softmax":return[s.softmax(v("x",r,t,e))];case"LogSoftmax":return[s.logSoftmax(v("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s_=(r,t,e,s=It)=>{switch(r.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:o}=s.raggedGather(v("paramsNestedSplits",r,t,e),v("paramsDenseValues",r,t,e),v("indices",r,t,e),v("outputRaggedRank",r,t,e));return i.concat(o)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:o}=s.raggedRange(v("starts",r,t,e),v("limits",r,t,e),v("splits",r,t,e));return[i,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(v("shape",r,t,e),v("values",r,t,e),v("defaultValue",r,t,e),v("rowPartitionTensors",r,t,e),v("rowPartitionTypes",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_=(r,t,e,s=It)=>{switch(r.op){case"Max":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.max(v("x",r,t,e),l,p)]}case"Mean":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.mean(v("x",r,t,e),l,p)]}case"Min":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.min(v("x",r,t,e),l,p)]}case"Sum":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.sum(v("x",r,t,e),l,p)]}case"All":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.all(v("x",r,t,e),l,p)]}case"Any":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.any(v("x",r,t,e),l,p)]}case"ArgMax":{const l=v("axis",r,t,e);return[s.argMax(v("x",r,t,e),l)]}case"ArgMin":{const l=v("axis",r,t,e);return[s.argMin(v("x",r,t,e),l)]}case"Prod":{const l=v("axis",r,t,e),p=v("keepDims",r,t,e);return[s.prod(v("x",r,t,e),l,p)]}case"Cumprod":{const l=v("axis",r,t,e),p=v("exclusive",r,t,e),d=v("reverse",r,t,e);return[s.cumprod(v("x",r,t,e),l,p,d)]}case"Cumsum":{const l=v("axis",r,t,e),p=v("exclusive",r,t,e),d=v("reverse",r,t,e);return[s.cumsum(v("x",r,t,e),l,p,d)]}case"Bincount":const i=v("x",r,t,e),o=v("weights",r,t,e),u=v("size",r,t,e);return[s.bincount(i,o,u)];case"DenseBincount":{const l=v("x",r,t,e),p=v("weights",r,t,e),d=v("size",r,t,e),f=v("binaryOutput",r,t,e);return[s.denseBincount(l,p,d,f)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a_=(r,t,e,s=It)=>{switch(r.op){case"ConcatV2":case"Concat":{const i=v("n",r,t,e),o=v("axis",r,t,e);let u=v("tensors",r,t,e);return u=u.slice(0,i),[s.concat(u,o)]}case"Gather":{const i=v("x",r,t,e),o=v("indices",r,t,e);return[s.gather(i,s.cast(o,"int32"),0)]}case"GatherV2":{const i=v("axis",r,t,e),o=v("batchDims",r,t,e),u=v("x",r,t,e),l=v("indices",r,t,e);return[s.gather(u,s.cast(l,"int32"),i,o)]}case"Reverse":{const i=v("dims",r,t,e),o=[];for(let l=0;l<i.length;l++)i[l]&&o.push(l);const u=v("x",r,t,e);return[s.reverse(u,o)]}case"ReverseV2":{const i=v("axis",r,t,e),o=v("x",r,t,e);return[s.reverse(o,i)]}case"Slice":{const i=v("begin",r,t,e),o=v("size",r,t,e);return[s.slice(v("x",r,t,e),i,o)]}case"StridedSlice":{const i=v("begin",r,t,e),o=v("end",r,t,e),u=v("strides",r,t,e),l=v("beginMask",r,t,e),p=v("endMask",r,t,e),d=v("ellipsisMask",r,t,e),f=v("newAxisMask",r,t,e),m=v("shrinkAxisMask",r,t,e),w=v("x",r,t,e);return[s.stridedSlice(w,i,o,u,l,p,d,f,m)]}case"Pack":return tt(()=>{const i=v("axis",r,t,e),o=v("tensors",r,t,e),u=o[0].shape,l=s.squeeze(o[0]).shape,p=o.map(d=>{const f=Cr(d.shape,u);if(!f&&!Cr(s.squeeze(d).shape,l))throw new Error("the input tensors shape does not match");return f?d:s.reshape(d,u)});return[s.stack(p,i)]});case"Unpack":{const i=v("axis",r,t,e),o=v("tensor",r,t,e);return s.unstack(o,i)}case"Tile":{const i=v("reps",r,t,e);return[s.tile(v("x",r,t,e),i)]}case"Split":case"SplitV":{const i=v("axis",r,t,e),o=v("numOrSizeSplits",r,t,e),u=v("x",r,t,e);return s.split(u,o,i)}case"ScatterNd":{const i=v("indices",r,t,e),o=v("values",r,t,e),u=v("shape",r,t,e);return[s.scatterND(i,o,u)]}case"GatherNd":{const i=v("x",r,t,e),o=v("indices",r,t,e);return[s.gatherND(i,o)]}case"SparseToDense":{const i=v("sparseIndices",r,t,e),o=v("outputShape",r,t,e),u=v("sparseValues",r,t,e),l=v("defaultValue",r,t,e);return[s.sparseToDense(i,u,o,u.dtype===l.dtype?l:s.cast(l,u.dtype))]}case"TensorScatterUpdate":{const i=v("indices",r,t,e),o=v("values",r,t,e),u=v("tensor",r,t,e);return[s.tensorScatterUpdate(u,i,o)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o_=(r,t,e,s=It)=>{switch(r.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:o,emptyRowIndicator:u,reverseIndexMap:l}=s.sparse.sparseFillEmptyRows(v("indices",r,t,e),v("values",r,t,e),v("denseShape",r,t,e),v("defaultValue",r,t,e));return[i,o,u,l]}case"SparseReshape":{const{outputIndices:i,outputShape:o}=s.sparse.sparseReshape(v("inputIndices",r,t,e),v("inputShape",r,t,e),v("newShape",r,t,e));return[i,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(v("data",r,t,e),v("indices",r,t,e),v("segmentIds",r,t,e))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(v("data",r,t,e),v("indices",r,t,e),v("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_=(r,t,e,s=It)=>{switch(r.op){case"FFT":return[s.fft(v("x",r,t,e))];case"IFFT":return[s.ifft(v("x",r,t,e))];case"RFFT":return[s.rfft(v("x",r,t,e))];case"IRFFT":return[s.irfft(v("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l_=(r,t,e,s=It)=>{switch(r.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(v("input",r,t,e),v("pattern",r,t,e),v("rewrite",r,t,e),v("replaceGlobal",r,t,e))];case"StringNGrams":{const{nGrams:i,nGramsSplits:o}=s.string.stringNGrams(v("data",r,t,e),v("dataSplits",r,t,e),v("separator",r,t,e),v("nGramWidths",r,t,e),v("leftPad",r,t,e),v("rightPad",r,t,e),v("padWidth",r,t,e),v("preserveShortSequences",r,t,e));return[i,o]}case"StringSplit":{const{indices:i,values:o,shape:u}=s.string.stringSplit(v("input",r,t,e),v("delimiter",r,t,e),v("skipEmpty",r,t,e));return[i,o,u]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(v("input",r,t,e),v("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c_=(r,t,e,s=It)=>{switch(r.op){case"Cast":return[s.cast(v("x",r,t,e),v("dtype",r,t,e))];case"ExpandDims":{const i=v("axis",r,t,e);return[s.expandDims(v("x",r,t,e),i)]}case"Squeeze":{const i=v("axis",r,t,e);return[s.squeeze(v("x",r,t,e),i)]}case"Reshape":return[s.reshape(v("x",r,t,e),v("shape",r,t,e))];case"EnsureShape":return[s.ensureShape(v("x",r,t,e),v("shape",r,t,e))];case"MirrorPad":return[s.mirrorPad(v("x",r,t,e),v("padding",r,t,e),v("mode",r,t,e))];case"PadV2":case"Pad":return[s.pad(v("x",r,t,e),v("padding",r,t,e),v("constantValue",r,t,e))];case"SpaceToBatchND":{const i=v("blockShape",r,t,e),o=v("paddings",r,t,e);return[s.spaceToBatchND(v("x",r,t,e),i,o)]}case"BatchToSpaceND":{const i=v("blockShape",r,t,e),o=v("crops",r,t,e);return[s.batchToSpaceND(v("x",r,t,e),i,o)]}case"DepthToSpace":{const i=v("blockSize",r,t,e),o=v("dataFormat",r,t,e).toUpperCase();return[s.depthToSpace(v("x",r,t,e),i,o)]}case"BroadcastTo":return[s.broadcastTo(v("x",r,t,e),v("shape",r,t,e))];case"BroadcastArgs":return[s.broadcastArgs(v("s0",r,t,e),v("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pp(r,t,e,s,i=tt){const o=((u,l,p)=>{switch(u.category){case"arithmetic":return i(()=>Bk(u,l,p));case"basic_math":return i(()=>Wk(u,l,p));case"control":return jk(u,l,p);case"convolution":return i(()=>Kk(u,l,p));case"creation":return i(()=>qk(u,l,p));case"dynamic":return Xk(u,l,p);case"evaluation":return i(()=>Yk(u,l,p));case"image":return i(()=>e_(u,l,p));case"graph":return i(()=>Qk(u,l,p));case"logical":return i(()=>t_(u,l,p));case"matrices":return i(()=>r_(u,l,p));case"normalization":return i(()=>n_(u,l,p));case"ragged":return i(()=>s_(u,l,p));case"reduction":return i(()=>i_(u,l,p));case"slice_join":return i(()=>a_(u,l,p));case"sparse":return i(()=>o_(u,l,p));case"spectral":return i(()=>u_(u,l,p));case"string":return i(()=>l_(u,l,p));case"transformation":return i(()=>c_(u,l,p));case"hash_table":return Jk(u,l,p,s);case"custom":const d=df(u.op);if(d&&d.customExecutor)return d.customExecutor(new zk(u,l,p));throw TypeError(`Custom op ${u.op} is not registered.`);default:throw TypeError(`Unknown op '${u.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return Vo(o)?o.then(u=>[].concat(u)):[].concat(o)}class $p{constructor(t={},e={},s={},i={},o){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=i,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ep(r,t,e,s){const i=new Set,o=[];let u=null,l=null;const p=new Set,d=new Set(Object.keys(r).map(w=>Xt(w)[0]));s=s||[];const f=new Set(s.map(w=>Xt(w.name)[0])),m=[...t];for(;m.length>0;){const w=m.pop();if((is(w)||w_(w)||v_(w))&&u==null&&(u=w,l=u.children.map(x=>x.name).filter(x=>i.has(x))),i.add(w.name),e[w.name]==null&&!d.has(w.name)&&!f.has(w.name)){if(w.inputs.length===0){o.push(w.name);continue}w.inputs.forEach(x=>{p.has(x.name)||(p.add(x.name),m.push(x))})}}return{inputs:r,outputs:t,usedNodes:i,missingInputs:o,dynamicNode:u,syncInputs:l}}function h_(r,t){const{usedNodes:e,inputs:s}=t,i=Object.keys(s).map(k=>Xt(k)[0]).map(k=>r.nodes[k]),o=r.initNodes||[],u=k=>e.has(typeof k=="string"?k:k.name);function l(k){return[...new Map(k.map(P=>[P.name,P])).values()]}const p=l([...i,...r.weights,...o]).filter(u),d=l([...p,...Object.values(r.nodes)]).filter(u),f=new Map(d.map(k=>[k.name,k])),m={};for(const k of d){m[k.name]=m[k.name]||0;for(const P of k.children)u(P)||(m[P.name]=Number.POSITIVE_INFINITY),m[P.name]=(m[P.name]||0)+1}const w=Object.entries(m).filter(([,k])=>k===0).map(([k])=>k),x=[...w];for(;w.length>0;){const k=w.pop(),P=f.get(k);for(const O of P.children.filter(u))--m[O.name]===0&&(x.push(O.name),w.push(O.name))}const C=x.map(k=>f.get(k)),I=p_(C,p);return d_(I,p),I}function p_(r,t){const e=new Map(r.map(u=>[u.name,u])),s=t.map(u=>u.name),i=new Set(s);for(;s.length>0;){const u=s.pop(),l=e.get(u);for(const p of l.children)!e.has(p.name)||i.has(p.name)||(i.add(p.name),s.push(p.name))}return r.filter(u=>i.has(u.name))}class zo extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function d_(r,t){const e=new Map(r.map((l,p)=>[l.name,p])),s=new Set(t.map(l=>l.name)),i=l=>s.has(typeof l=="string"?l:l.name),o=new Set(r.map(l=>l.name)),u=l=>o.has(typeof l=="string"?l:l.name);for(const l of r){for(const p of l.children.filter(u)){if(!e.has(p.name))throw new zo(`Child ${p.name} of node ${l.name} is unreachable.`);if(e.get(l.name)>e.get(p.name))throw new zo(`Node ${l.name} is scheduled to run after its child ${p.name}.`)}if(!i(l))for(const p of l.inputs){if(!e.has(p.name))throw new zo(`Input ${p.name} of node ${l.name} is unreachable.`);if(e.get(p.name)>e.get(l.name))throw new zo(`Node ${l.name} is scheduled to run before its input ${p.name}.`)}}}function f_(r){const t=new Map(r.map((l,p)=>[l.name,p])),e=Number.MAX_SAFE_INTEGER,s=r.map((l,p)=>is(l)?e:p),i=l=>{const p=s[t.get(l.name)];return p??-1},o=r.map((l,p)=>l.children.map(i).reduce((d,f)=>Math.max(d,f),s[p])),u=new Map;for(let l=0;l<r.length;++l){const p=o[l];if(p===e)continue;const d=r[l],f=r[p];u.has(f.name)||u.set(f.name,[]),u.get(f.name).push(d)}return u}const m_=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),g_=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),y_=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function is(r){return m_.has(r.op)}function w_(r){return g_.has(r.op)}function v_(r){return y_.has(r.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ho{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(s=>t[s].map(i=>i.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Ho(t.functions[s],this)})}getCompilationKey(t,e){const s=t.map(o=>o.name).sort(),i=e.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,e){const s=Ep(t,e,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:o,syncInputs:u}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${u}]`);if(i.length>0){const d=e.map(m=>m.name),f=Object.keys(t);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${f}]. Missing the following inputs: [${i}]`)}const l=h_(this.graph,s),p=f_(l);return{orderedNodes:l,nodeLiveUntilMap:p}}cloneAndKeepTensor(t){if(t==null)return null;const e=t.clone();return on(e),e}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,this.cloneTensorList(s)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=s.map(w=>this.graph.nodes[Xt(w)[0]]),o=e.map(w=>Xt(w)[0]),u=new Set(o);let l=o.map(w=>this.graph.nodes[w]);l.length===0&&(l=this._outputs);const p=this.getCompilationKey(i,l);let d=this.compiledMap.get(p);d==null&&(d=this.compile(t,l),this.compiledMap.set(p,d));try{this.keepIntermediateTensors=Qe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(w){this.keepIntermediateTensors=!1,console.warn(w.message)}const f={},m={};return tt(()=>{const w=new $p(this.weightMap,f,m,this.functionExecutorMap,this.parseNodeNameCache),x=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(P=>{const[O,z]=Xt(P,w),F=[];F[z]=t[P],x[O]=F,this.keepIntermediateTensors&&(this.clonedTensorsMap[O]=this.cloneTensorList(F))});const C=this.getFrozenTensorIds(x),{orderedNodes:I,nodeLiveUntilMap:k}=d;for(const P of I){if(x[P.name])continue;const O=Pp(P,x,w,this._resourceManager);if(Vo(O))throw new Error(`The execution of the op '${P.op}' returned a promise. Please use model.executeAsync() instead.`);x[P.name]=O,this.keepIntermediateTensors&&(this.clonedTensorsMap[P.name]=this.cloneTensorList(O)),this.checkTensorForDisposalWithNodeLiveUntilInfo(P,x,w,C,u,k.get(P.name))}return this.parent==null&&w.dispose(C),e.map(P=>Nt(P,x,w))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(i=>i.id)));return new Set(e)}checkTensorForDisposal(t,e,s,i,o,u,l){if(!(is(e)||u.has(t))){for(const p of s[t])p!=null&&(l[p.id]=(l[p.id]||0)+e.children.length);for(const p of e.inputs){if(is(p))continue;const d=kp(p.name,s,i);if(d!=null)for(const f of d){if(!f||f.kept||o.has(f.id))continue;const m=l[f.id];m===1?(f.dispose(),delete l[f.id]):m!=null&&l[f.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,i,o,u){function l(p){return is(p)||o.has(p.name)}if(!(is(t)||u==null))for(const p of u){if(l(p))continue;const d=kp(p.name,e,s);for(const f of d)!f||f.kept||i.has(f.id)||f.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,s=!1,i={},o={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=Qe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(w){this.keepIntermediateTensors=!1,console.warn(w.message)}const u=new $p(this.weightMap,i,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const l=await this.executeWithControlFlow(t,u,e,s),p=e.map(w=>Nt(w,l,u)),d=p.map(w=>w.id),f=Object.keys(t).map(w=>t[w].id),m=new Set([...d,...f,...this.weightIds]);return Object.values(l).forEach(w=>{w.forEach(x=>{x&&!x.isDisposed&&!m.has(x.id)&&x.dispose()})}),this.parent==null&&u.dispose(m),p}async executeFunctionAsync(t,e,s){const i=t.reduce((o,u,l)=>(o[this.inputs[l].name]=u,o),{});return this._executeAsync(i,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,i){const o=Object.keys(t),u=o.map(F=>this.graph.nodes[Xt(F)[0]]),l=s.map(F=>Xt(F)[0]),p=new Set(l);let d=l.map(F=>this.graph.nodes[F]);d.length===0&&(d=this._outputs);const{usedNodes:f,missingInputs:m,dynamicNode:w,syncInputs:x}=Ep(t,d,this.weightMap,this._initNodes),C=[...u,...this.graph.weights,...this._initNodes||[]].map(F=>({node:F,contexts:e.currentContext})),I=Object.assign({},this.weightMap);Object.keys(t).forEach(F=>{const[V,G]=Xt(F),M=[];M[G]=t[F],I[V]=M});const k={},P=this.getFrozenTensorIds(I),O={};for(;C.length>0;){const F=this.processStack(u,C,e,I,O,P,p,k,f);await Promise.all(F)}w==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const z=d.filter(F=>!is(F)&&!Nt(F.name,I,e)).map(F=>F.name);if(z.length>0){let F="";throw w!=null&&(F=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${x}]`),new Error(`Cannot compute the outputs [${z}] from the provided inputs [${o}]. Consider providing the following inputs: [${m}]. ${F}`)}return I}processStack(t,e,s,i,o,u,l,p,d){const f=[];for(;e.length>0;){const m=e.pop();s.currentContext=m.contexts;let w="";if(m.node.op==="Enter"&&v("isConstant",m.node,i,s)&&([w]=nn(m.node.name,s)),i[m.node.name]==null){const x=Pp(m.node,i,s,this._resourceManager);w||([w]=nn(m.node.name,s));const C=s.currentContext;Vo(x)?f.push(x.then(I=>(i[w]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(I)),s.currentContext=C,this.checkTensorForDisposal(w,m.node,i,s,u,l,p),this.processChildNodes(m.node,e,s,i,o,d),I))):(i[w]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(x)),this.checkTensorForDisposal(w,m.node,i,s,u,l,p),this.processChildNodes(m.node,e,s,i,o,d))}else this.processChildNodes(m.node,e,s,i,o,d)}return f}processChildNodes(t,e,s,i,o,u){t.children.forEach(l=>{const[p]=nn(l.name,s);o[p]||!u.has(l.name)||(l.op==="Merge"?l.inputNames.some(d=>!!Nt(d,i,s))&&(o[p]=!0,e.push({contexts:s.currentContext,node:l})):l.inputNames.every(d=>!!Nt(d,i,s))&&(o[p]=!0,e.push({contexts:s.currentContext,node:l})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[i]=Xt(e),o=this.graph.nodes[i];if(o.attrParams.shape&&o.attrParams.shape.value){const u=o.attrParams.shape.value,l=u.length===s.shape.length&&s.shape.every((p,d)=>u[d]===-1||u[d]===p);le(l,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${u}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&le(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const i={};for(const o in t){const u=(s=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||s===void 0?void 0:s[o];u!=null?i[u.name]=t[o]:i[o]=t[o]}return i}checkInputs(t){const e=Object.keys(t).filter(s=>{const[i]=Xt(s);return this.graph.nodes[i]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var s,i;const o=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[e];return o!=null?o.name:e},{})}checkOutputs(t){t.forEach(e=>{const[s]=Xt(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class b_{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x_="?tfjs-format=file",S_="model.json";class C_{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=pf){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,e==null&&(this.loadOptions={}),this.resourceManager=new b_}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Vo(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const e=await jd(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const s=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(i=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=i,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Ho(_p.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const o=_p.Instance.transformGraph(t.modelInitializer);this.initializer=new Ho(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof Or?[t]:t,s={};return e.forEach((i,o)=>s[this.structuredOutputKeys[o]]=i),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,e){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var e;if(!(t instanceof Or)&&!Array.isArray(t)){const o=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(o!=null)for(const u in o){const l=o[u];l.resourceId!=null&&(t[u]=this.resourceIdToCapturedInput[l.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((o,u)=>{var l,p,d;const f=(d=(p=(l=this.signature)===null||l===void 0?void 0:l.inputs)===null||p===void 0?void 0:p[u])===null||d===void 0?void 0:d.resourceId;return f!=null?o[u]=this.resourceIdToCapturedInput[f]:o[u]=t[i++],o},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let i=0;i<s.length;i++){const o=s[i],u=e[o];this.resourceIdToCapturedInput[u.resourceId]=t[i]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=await this.executor.executeAsync(t,e);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Dt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function li(r,t={},e=pf){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=N_(r));const s=new C_(r,t,e);return await s.load(),s}function N_(r){return r.endsWith("/")||(r=r+"/"),`${r}${S_}${x_}`}var bl={},Dp;function I_(){return Dp||(Dp=1,(function(){var r;function t(c){var g=0;return function(){return g<c.length?{done:!1,value:c[g++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(c,g,b){return c==Array.prototype||c==Object.prototype||(c[g]=b.value),c};function s(c){c=[typeof globalThis=="object"&&globalThis,c,typeof window=="object"&&window,typeof self=="object"&&self,typeof ii=="object"&&ii];for(var g=0;g<c.length;++g){var b=c[g];if(b&&b.Math==Math)return b}throw Error("Cannot find global object")}var i=s(this);function o(c,g){if(g)e:{var b=i;c=c.split(".");for(var N=0;N<c.length-1;N++){var R=c[N];if(!(R in b))break e;b=b[R]}c=c[c.length-1],N=b[c],g=g(N),g!=N&&g!=null&&e(b,c,{configurable:!0,writable:!0,value:g})}}o("Symbol",function(c){function g($){if(this instanceof g)throw new TypeError("Symbol is not a constructor");return new b(N+($||"")+"_"+R++,$)}function b($,A){this.h=$,e(this,"description",{configurable:!0,writable:!0,value:A})}if(c)return c;b.prototype.toString=function(){return this.h};var N="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",R=0;return g}),o("Symbol.iterator",function(c){if(c)return c;c=Symbol("Symbol.iterator");for(var g="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),b=0;b<g.length;b++){var N=i[g[b]];typeof N=="function"&&typeof N.prototype[c]!="function"&&e(N.prototype,c,{configurable:!0,writable:!0,value:function(){return u(t(this))}})}return c});function u(c){return c={next:c},c[Symbol.iterator]=function(){return this},c}function l(c){var g=typeof Symbol<"u"&&Symbol.iterator&&c[Symbol.iterator];return g?g.call(c):{next:t(c)}}function p(c){if(!(c instanceof Array)){c=l(c);for(var g,b=[];!(g=c.next()).done;)b.push(g.value);c=b}return c}var d=typeof Object.assign=="function"?Object.assign:function(c,g){for(var b=1;b<arguments.length;b++){var N=arguments[b];if(N)for(var R in N)Object.prototype.hasOwnProperty.call(N,R)&&(c[R]=N[R])}return c};o("Object.assign",function(c){return c||d});var f=typeof Object.create=="function"?Object.create:function(c){function g(){}return g.prototype=c,new g},m;if(typeof Object.setPrototypeOf=="function")m=Object.setPrototypeOf;else{var w;e:{var x={a:!0},C={};try{C.__proto__=x,w=C.a;break e}catch{}w=!1}m=w?function(c,g){if(c.__proto__=g,c.__proto__!==g)throw new TypeError(c+" is not extensible");return c}:null}var I=m;function k(c,g){if(c.prototype=f(g.prototype),c.prototype.constructor=c,I)I(c,g);else for(var b in g)if(b!="prototype")if(Object.defineProperties){var N=Object.getOwnPropertyDescriptor(g,b);N&&Object.defineProperty(c,b,N)}else c[b]=g[b];c.za=g.prototype}function P(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function O(c){if(c.m)throw new TypeError("Generator is already running");c.m=!0}P.prototype.u=function(c){this.i=c};function z(c,g){c.l={ma:g,na:!0},c.h=c.s||c.v}P.prototype.return=function(c){this.l={return:c},this.h=this.v};function F(c,g,b){return c.h=b,{value:g}}function V(c){this.h=new P,this.i=c}function G(c,g){O(c.h);var b=c.h.j;return b?M(c,"return"in b?b.return:function(N){return{value:N,done:!0}},g,c.h.return):(c.h.return(g),Y(c))}function M(c,g,b,N){try{var R=g.call(c.h.j,b);if(!(R instanceof Object))throw new TypeError("Iterator result "+R+" is not an object");if(!R.done)return c.h.m=!1,R;var $=R.value}catch(A){return c.h.j=null,z(c.h,A),Y(c)}return c.h.j=null,N.call(c.h,$),Y(c)}function Y(c){for(;c.h.h;)try{var g=c.i(c.h);if(g)return c.h.m=!1,{value:g.value,done:!1}}catch(b){c.h.i=void 0,z(c.h,b)}if(c.h.m=!1,c.h.l){if(g=c.h.l,c.h.l=null,g.na)throw g.ma;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function K(c){this.next=function(g){return O(c.h),c.h.j?g=M(c,c.h.j.next,g,c.h.u):(c.h.u(g),g=Y(c)),g},this.throw=function(g){return O(c.h),c.h.j?g=M(c,c.h.j.throw,g,c.h.u):(z(c.h,g),g=Y(c)),g},this.return=function(g){return G(c,g)},this[Symbol.iterator]=function(){return this}}function J(c){function g(N){return c.next(N)}function b(N){return c.throw(N)}return new Promise(function(N,R){function $(A){A.done?N(A.value):Promise.resolve(A.value).then(g,b).then($,R)}$(c.next())})}function ne(c){return J(new K(new V(c)))}o("Promise",function(c){function g(A){this.i=0,this.j=void 0,this.h=[],this.u=!1;var L=this.l();try{A(L.resolve,L.reject)}catch(U){L.reject(U)}}function b(){this.h=null}function N(A){return A instanceof g?A:new g(function(L){L(A)})}if(c)return c;b.prototype.i=function(A){if(this.h==null){this.h=[];var L=this;this.j(function(){L.m()})}this.h.push(A)};var R=i.setTimeout;b.prototype.j=function(A){R(A,0)},b.prototype.m=function(){for(;this.h&&this.h.length;){var A=this.h;this.h=[];for(var L=0;L<A.length;++L){var U=A[L];A[L]=null;try{U()}catch(Z){this.l(Z)}}}this.h=null},b.prototype.l=function(A){this.j(function(){throw A})},g.prototype.l=function(){function A(Z){return function(se){U||(U=!0,Z.call(L,se))}}var L=this,U=!1;return{resolve:A(this.I),reject:A(this.m)}},g.prototype.I=function(A){if(A===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(A instanceof g)this.L(A);else{e:switch(typeof A){case"object":var L=A!=null;break e;case"function":L=!0;break e;default:L=!1}L?this.F(A):this.s(A)}},g.prototype.F=function(A){var L=void 0;try{L=A.then}catch(U){this.m(U);return}typeof L=="function"?this.M(L,A):this.s(A)},g.prototype.m=function(A){this.v(2,A)},g.prototype.s=function(A){this.v(1,A)},g.prototype.v=function(A,L){if(this.i!=0)throw Error("Cannot settle("+A+", "+L+"): Promise already settled in state"+this.i);this.i=A,this.j=L,this.i===2&&this.K(),this.H()},g.prototype.K=function(){var A=this;R(function(){if(A.D()){var L=i.console;typeof L<"u"&&L.error(A.j)}},1)},g.prototype.D=function(){if(this.u)return!1;var A=i.CustomEvent,L=i.Event,U=i.dispatchEvent;return typeof U>"u"?!0:(typeof A=="function"?A=new A("unhandledrejection",{cancelable:!0}):typeof L=="function"?A=new L("unhandledrejection",{cancelable:!0}):(A=i.document.createEvent("CustomEvent"),A.initCustomEvent("unhandledrejection",!1,!0,A)),A.promise=this,A.reason=this.j,U(A))},g.prototype.H=function(){if(this.h!=null){for(var A=0;A<this.h.length;++A)$.i(this.h[A]);this.h=null}};var $=new b;return g.prototype.L=function(A){var L=this.l();A.T(L.resolve,L.reject)},g.prototype.M=function(A,L){var U=this.l();try{A.call(L,U.resolve,U.reject)}catch(Z){U.reject(Z)}},g.prototype.then=function(A,L){function U(ue,ie){return typeof ue=="function"?function(ge){try{Z(ue(ge))}catch(_e){se(_e)}}:ie}var Z,se,we=new g(function(ue,ie){Z=ue,se=ie});return this.T(U(A,Z),U(L,se)),we},g.prototype.catch=function(A){return this.then(void 0,A)},g.prototype.T=function(A,L){function U(){switch(Z.i){case 1:A(Z.j);break;case 2:L(Z.j);break;default:throw Error("Unexpected state: "+Z.i)}}var Z=this;this.h==null?$.i(U):this.h.push(U),this.u=!0},g.resolve=N,g.reject=function(A){return new g(function(L,U){U(A)})},g.race=function(A){return new g(function(L,U){for(var Z=l(A),se=Z.next();!se.done;se=Z.next())N(se.value).T(L,U)})},g.all=function(A){var L=l(A),U=L.next();return U.done?N([]):new g(function(Z,se){function we(ge){return function(_e){ue[ge]=_e,ie--,ie==0&&Z(ue)}}var ue=[],ie=0;do ue.push(void 0),ie++,N(U.value).T(we(ue.length-1),se),U=L.next();while(!U.done)})},g});function me(c,g){c instanceof String&&(c+="");var b=0,N=!1,R={next:function(){if(!N&&b<c.length){var $=b++;return{value:g($,c[$]),done:!1}}return N=!0,{done:!0,value:void 0}}};return R[Symbol.iterator]=function(){return R},R}o("Array.prototype.keys",function(c){return c||function(){return me(this,function(g){return g})}}),o("Array.prototype.fill",function(c){return c||function(g,b,N){var R=this.length||0;for(0>b&&(b=Math.max(0,R+b)),(N==null||N>R)&&(N=R),N=Number(N),0>N&&(N=Math.max(0,R+N)),b=Number(b||0);b<N;b++)this[b]=g;return this}});function ce(c){return c||Array.prototype.fill}o("Int8Array.prototype.fill",ce),o("Uint8Array.prototype.fill",ce),o("Uint8ClampedArray.prototype.fill",ce),o("Int16Array.prototype.fill",ce),o("Uint16Array.prototype.fill",ce),o("Int32Array.prototype.fill",ce),o("Uint32Array.prototype.fill",ce),o("Float32Array.prototype.fill",ce),o("Float64Array.prototype.fill",ce),o("Object.is",function(c){return c||function(g,b){return g===b?g!==0||1/g===1/b:g!==g&&b!==b}}),o("Array.prototype.includes",function(c){return c||function(g,b){var N=this;N instanceof String&&(N=String(N));var R=N.length;for(b=b||0,0>b&&(b=Math.max(b+R,0));b<R;b++){var $=N[b];if($===g||Object.is($,g))return!0}return!1}}),o("String.prototype.includes",function(c){return c||function(g,b){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(g instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(g,b||0)!==-1}});var ye=this||self;function Ne(c,g){c=c.split(".");var b=ye;c[0]in b||typeof b.execScript>"u"||b.execScript("var "+c[0]);for(var N;c.length&&(N=c.shift());)c.length||g===void 0?b[N]&&b[N]!==Object.prototype[N]?b=b[N]:b=b[N]={}:b[N]=g}function Ae(c){var g;e:{if((g=ye.navigator)&&(g=g.userAgent))break e;g=""}return g.indexOf(c)!=-1}var rt=Array.prototype.map?function(c,g){return Array.prototype.map.call(c,g,void 0)}:function(c,g){for(var b=c.length,N=Array(b),R=typeof c=="string"?c.split(""):c,$=0;$<b;$++)$ in R&&(N[$]=g.call(void 0,R[$],$,c));return N},nt={},pt=null;function Ot(c){var g=c.length,b=3*g/4;b%3?b=Math.floor(b):"=.".indexOf(c[g-1])!=-1&&(b="=.".indexOf(c[g-2])!=-1?b-2:b-1);var N=new Uint8Array(b),R=0;return ut(c,function($){N[R++]=$}),R!==b?N.subarray(0,R):N}function ut(c,g){function b(U){for(;N<c.length;){var Z=c.charAt(N++),se=pt[Z];if(se!=null)return se;if(!/^[\s\xa0]*$/.test(Z))throw Error("Unknown base64 encoding at char: "+Z)}return U}En();for(var N=0;;){var R=b(-1),$=b(0),A=b(64),L=b(64);if(L===64&&R===-1)break;g(R<<2|$>>4),A!=64&&(g($<<4&240|A>>2),L!=64&&g(A<<6&192|L))}}function En(){if(!pt){pt={};for(var c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],b=0;5>b;b++){var N=c.concat(g[b].split(""));nt[b]=N;for(var R=0;R<N.length;R++){var $=N[R];pt[$]===void 0&&(pt[$]=R)}}}}var Dn=typeof Uint8Array<"u",xs=!(Ae("Trident")||Ae("MSIE"))&&typeof ye.btoa=="function";function zr(c){if(!xs){var g;g===void 0&&(g=0),En(),g=nt[g];for(var b=Array(Math.floor(c.length/3)),N=g[64]||"",R=0,$=0;R<c.length-2;R+=3){var A=c[R],L=c[R+1],U=c[R+2],Z=g[A>>2];A=g[(A&3)<<4|L>>4],L=g[(L&15)<<2|U>>6],U=g[U&63],b[$++]=Z+A+L+U}switch(Z=0,U=N,c.length-R){case 2:Z=c[R+1],U=g[(Z&15)<<2]||N;case 1:c=c[R],b[$]=g[c>>2]+g[(c&3)<<4|Z>>4]+U+N}return b.join("")}for(g="";10240<c.length;)g+=String.fromCharCode.apply(null,c.subarray(0,10240)),c=c.subarray(10240);return g+=String.fromCharCode.apply(null,c),btoa(g)}var On=RegExp("[-_.]","g");function ru(c){switch(c){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function hn(c){if(!xs)return Ot(c);On.test(c)&&(c=c.replace(On,ru)),c=atob(c);for(var g=new Uint8Array(c.length),b=0;b<c.length;b++)g[b]=c.charCodeAt(b);return g}var pn;function mi(){return pn||(pn=new Uint8Array(0))}var Nr={},Ss=typeof Uint8Array.prototype.slice=="function",lt=0,Je=0;function dn(c){var g=0>c;c=Math.abs(c);var b=c>>>0;c=Math.floor((c-b)/4294967296),g&&(b=l(or(b,c)),g=b.next().value,c=b.next().value,b=g),lt=b>>>0,Je=c>>>0}var nu=typeof BigInt=="function";function or(c,g){return g=~g,c?c=~c+1:g+=1,[c,g]}function gi(c,g){this.i=c>>>0,this.h=g>>>0}function _a(c){if(!c)return fn||(fn=new gi(0,0));if(!/^-?\d+$/.test(c))return null;if(16>c.length)dn(Number(c));else if(nu)c=BigInt(c),lt=Number(c&BigInt(4294967295))>>>0,Je=Number(c>>BigInt(32)&BigInt(4294967295));else{var g=+(c[0]==="-");Je=lt=0;for(var b=c.length,N=g,R=(b-g)%6+g;R<=b;N=R,R+=6)N=Number(c.slice(N,R)),Je*=1e6,lt=1e6*lt+N,4294967296<=lt&&(Je+=lt/4294967296|0,lt%=4294967296);g&&(g=l(or(lt,Je)),c=g.next().value,g=g.next().value,lt=c,Je=g)}return new gi(lt,Je)}var fn;function Ut(c,g){return Error("Invalid wire type: "+c+" (at position "+g+")")}function Br(){return Error("Failed to read varint, encoding is invalid.")}function Fn(c,g){return Error("Tried to read past the end of the data "+g+" > "+c)}function Wr(){throw Error("Invalid UTF8")}function mn(c,g){return g=String.fromCharCode.apply(null,g),c==null?g:c+g}var Cs=void 0,Vr,gn=typeof TextDecoder<"u",Ns,yi=typeof TextEncoder<"u",Is;function ks(c){if(c!==Nr)throw Error("illegal external caller")}function Ur(c,g){if(ks(g),this.V=c,c!=null&&c.length===0)throw Error("ByteString should be constructed with non-empty values")}function Ln(){return Is||(Is=new Ur(null,Nr))}function _s(c){ks(Nr);var g=c.V;return g=g==null||Dn&&g!=null&&g instanceof Uint8Array?g:typeof g=="string"?hn(g):null,g==null?g:c.V=g}function wi(c){if(typeof c=="string")return{buffer:hn(c),C:!1};if(Array.isArray(c))return{buffer:new Uint8Array(c),C:!1};if(c.constructor===Uint8Array)return{buffer:c,C:!1};if(c.constructor===ArrayBuffer)return{buffer:new Uint8Array(c),C:!1};if(c.constructor===Ur)return{buffer:_s(c)||mi(),C:!0};if(c instanceof Uint8Array)return{buffer:new Uint8Array(c.buffer,c.byteOffset,c.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ts(c,g){this.i=null,this.m=!1,this.h=this.j=this.l=0,vi(this,c,g)}function vi(c,g,b){b=b===void 0?{}:b,c.S=b.S===void 0?!1:b.S,g&&(g=wi(g),c.i=g.buffer,c.m=g.C,c.l=0,c.j=c.i.length,c.h=c.l)}Ts.prototype.reset=function(){this.h=this.l};function Mr(c,g){if(c.h=g,g>c.j)throw Fn(c.j,g)}function zn(c){var g=c.i,b=c.h,N=g[b++],R=N&127;if(N&128&&(N=g[b++],R|=(N&127)<<7,N&128&&(N=g[b++],R|=(N&127)<<14,N&128&&(N=g[b++],R|=(N&127)<<21,N&128&&(N=g[b++],R|=N<<28,N&128&&g[b++]&128&&g[b++]&128&&g[b++]&128&&g[b++]&128&&g[b++]&128)))))throw Br();return Mr(c,b),R}function bi(c,g){if(0>g)throw Error("Tried to read a negative byte length: "+g);var b=c.h,N=b+g;if(N>c.j)throw Fn(g,c.j-b);return c.h=N,b}var xi=[];function Si(){this.h=[]}Si.prototype.length=function(){return this.h.length},Si.prototype.end=function(){var c=this.h;return this.h=[],c};function Ta(c,g,b){for(;0<b||127<g;)c.h.push(g&127|128),g=(g>>>7|b<<25)>>>0,b>>>=7;c.h.push(g)}function Hr(c,g){for(;127<g;)c.h.push(g&127|128),g>>>=7;c.h.push(g)}function Ci(c,g){if(xi.length){var b=xi.pop();vi(b,c,g),c=b}else c=new Ts(c,g);this.h=c,this.j=this.h.h,this.i=this.l=-1,this.setOptions(g)}Ci.prototype.setOptions=function(c){c=c===void 0?{}:c,this.ca=c.ca===void 0?!1:c.ca},Ci.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Ni(c){var g=c.h;if(g.h==g.j)return!1;c.j=c.h.h;var b=zn(c.h)>>>0;if(g=b>>>3,b&=7,!(0<=b&&5>=b))throw Ut(b,c.j);if(1>g)throw Error("Invalid field number: "+g+" (at position "+c.j+")");return c.l=g,c.i=b,!0}function Rs(c){switch(c.i){case 0:if(c.i!=0)Rs(c);else e:{c=c.h;for(var g=c.h,b=g+10,N=c.i;g<b;)if((N[g++]&128)===0){Mr(c,g);break e}throw Br()}break;case 1:c=c.h,Mr(c,c.h+8);break;case 2:c.i!=2?Rs(c):(g=zn(c.h)>>>0,c=c.h,Mr(c,c.h+g));break;case 5:c=c.h,Mr(c,c.h+4);break;case 3:g=c.l;do{if(!Ni(c))throw Error("Unmatched start-group tag: stream EOF");if(c.i==4){if(c.l!=g)throw Error("Unmatched end-group tag");break}Rs(c)}while(!0);break;default:throw Ut(c.i,c.j)}}var As=[];function su(){this.j=[],this.i=0,this.h=new Si}function Ir(c,g){g.length!==0&&(c.j.push(g),c.i+=g.length)}function iu(c,g){if(g=g.R){Ir(c,c.h.end());for(var b=0;b<g.length;b++)Ir(c,_s(g[b])||mi())}}var Zt=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Gr(c,g){return Zt?c[Zt]|=g:c.A!==void 0?c.A|=g:(Object.defineProperties(c,{A:{value:g,configurable:!0,writable:!0,enumerable:!1}}),g)}function Ra(c,g){Zt?c[Zt]&&(c[Zt]&=~g):c.A!==void 0&&(c.A&=~g)}function at(c){var g;return Zt?g=c[Zt]:g=c.A,g??0}function ur(c,g){Zt?c[Zt]=g:c.A!==void 0?c.A=g:Object.defineProperties(c,{A:{value:g,configurable:!0,writable:!0,enumerable:!1}})}function Ii(c){return Gr(c,1),c}function au(c,g){ur(g,(c|0)&-51)}function Ps(c,g){ur(g,(c|18)&-41)}var ki={};function Bn(c){return c!==null&&typeof c=="object"&&!Array.isArray(c)&&c.constructor===Object}var Wn,Aa=[];ur(Aa,23),Wn=Object.freeze(Aa);function _i(c){if(at(c.o)&2)throw Error("Cannot mutate an immutable Message")}function Ti(c){var g=c.length;(g=g?c[g-1]:void 0)&&Bn(g)?g.g=1:(g={},c.push((g.g=1,g)))}function Pa(c){var g=c.i+c.G;return c.B||(c.B=c.o[g]={})}function Jt(c,g){return g===-1?null:g>=c.i?c.B?c.B[g]:void 0:c.o[g+c.G]}function Ft(c,g,b,N){_i(c),Vn(c,g,b,N)}function Vn(c,g,b,N){c.j&&(c.j=void 0),g>=c.i||N?Pa(c)[g]=b:(c.o[g+c.G]=b,(c=c.B)&&g in c&&delete c[g])}function yn(c,g,b,N){var R=Jt(c,g);Array.isArray(R)||(R=Wn);var $=at(R);if($&1||Ii(R),N)$&2||Gr(R,2),b&1||Object.freeze(R);else{N=!(b&2);var A=$&2;b&1||!A?N&&$&16&&!A&&Ra(R,16):(R=Ii(Array.prototype.slice.call(R)),Vn(c,g,R))}return R}function Ri(c,g){var b=Jt(c,g),N=b==null?b:typeof b=="number"||b==="NaN"||b==="Infinity"||b==="-Infinity"?Number(b):void 0;return N!=null&&N!==b&&Vn(c,g,N),N}function $a(c,g,b,N,R){c.h||(c.h={});var $=c.h[b],A=yn(c,b,3,R);if(!$){var L=A;$=[];var U=!!(at(c.o)&16);A=!!(at(L)&2);var Z=L;!R&&A&&(L=Array.prototype.slice.call(L));for(var se=A,we=0;we<L.length;we++){var ue=L[we],ie=g,ge=!1;if(ge=ge===void 0?!1:ge,ue=Array.isArray(ue)?new ie(ue):ge?new ie:void 0,ue!==void 0){ie=ue.o;var _e=ge=at(ie);A&&(_e|=2),U&&(_e|=16),_e!=ge&&ur(ie,_e),ie=_e,se=se||!!(2&ie),$.push(ue)}}return c.h[b]=$,U=at(L),g=U|33,g=se?g&-9:g|8,U!=g&&(se=L,Object.isFrozen(se)&&(se=Array.prototype.slice.call(se)),ur(se,g),L=se),Z!==L&&Vn(c,b,L),(R||N&&A)&&Gr($,2),N&&Object.freeze($),$}return R||(R=Object.isFrozen($),N&&!R?Object.freeze($):!N&&R&&($=Array.prototype.slice.call($),c.h[b]=$)),$}function Ai(c,g,b){var N=!!(at(c.o)&2);if(g=$a(c,g,b,N,N),c=yn(c,b,3,N),!(N||at(c)&8)){for(N=0;N<g.length;N++){if(b=g[N],at(b.o)&2){var R=Mn(b,!1);R.j=b}else R=b;b!==R&&(g[N]=R,c[N]=R.o)}Gr(c,8)}return g}function er(c,g,b){if(b!=null&&typeof b!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof b+": "+b);Ft(c,g,b)}function Pi(c,g,b,N,R){_i(c);var $=$a(c,b,g,!1,!1);return b=N??new b,c=yn(c,g,2,!1),R!=null?($.splice(R,0,b),c.splice(R,0,b.o)):($.push(b),c.push(b.o)),b.C()&&Ra(c,8),b}function Un(c,g){return c??g}function lr(c,g,b){return b=b===void 0?0:b,Un(Ri(c,g),b)}var $s;function ou(c){switch(typeof c){case"number":return isFinite(c)?c:String(c);case"object":if(c)if(Array.isArray(c)){if((at(c)&128)!==0)return c=Array.prototype.slice.call(c),Ti(c),c}else{if(Dn&&c!=null&&c instanceof Uint8Array)return zr(c);if(c instanceof Ur){var g=c.V;return g==null?"":typeof g=="string"?g:c.V=zr(g)}}}return c}function Ea(c,g,b,N){if(c!=null){if(Array.isArray(c))c=Es(c,g,b,N!==void 0);else if(Bn(c)){var R={},$;for($ in c)R[$]=Ea(c[$],g,b,N);c=R}else c=g(c,N);return c}}function Es(c,g,b,N){var R=at(c);N=N?!!(R&16):void 0,c=Array.prototype.slice.call(c);for(var $=0;$<c.length;$++)c[$]=Ea(c[$],g,b,N);return b(R,c),c}function Da(c){return c.ja===ki?c.toJSON():ou(c)}function Oa(c,g){c&128&&Ti(g)}function Ds(c,g,b){if(b=b===void 0?Ps:b,c!=null){if(Dn&&c instanceof Uint8Array)return c.length?new Ur(new Uint8Array(c),Nr):Ln();if(Array.isArray(c)){var N=at(c);return N&2?c:g&&!(N&32)&&(N&16||N===0)?(ur(c,N|2),c):(c=Es(c,Ds,N&4?Ps:b,!0),g=at(c),g&4&&g&2&&Object.freeze(c),c)}return c.ja===ki?$i(c):c}}function Fa(c,g,b,N,R,$,A){if(c=c.h&&c.h[b]){if(N=at(c),N&2?N=c:($=rt(c,$i),Ps(N,$),Object.freeze($),N=$),_i(g),A=N==null?Wn:Ii([]),N!=null){for($=!!N.length,c=0;c<N.length;c++){var L=N[c];$=$&&!(at(L.o)&2),A[c]=L.o}$=($?8:0)|1,c=at(A),(c&$)!==$&&(Object.isFrozen(A)&&(A=Array.prototype.slice.call(A)),ur(A,c|$)),g.h||(g.h={}),g.h[b]=N}else g.h&&(g.h[b]=void 0);Vn(g,b,A,R)}else Ft(g,b,Ds(N,$,A),R)}function $i(c){return at(c.o)&2||(c=Mn(c,!0),Gr(c.o,2)),c}function Mn(c,g){var b=c.o,N=[];Gr(N,16);var R=c.constructor.h;if(R&&N.push(R),R=c.B,R){N.length=b.length,N.fill(void 0,N.length,b.length);var $={};N[N.length-1]=$}(at(b)&128)!==0&&Ti(N),g=g||c.C()?Ps:au,$=c.constructor,$s=N,N=new $(N),$s=void 0,c.R&&(N.R=c.R.slice()),$=!!(at(b)&16);for(var A=R?b.length-1:b.length,L=0;L<A;L++)Fa(c,N,L-c.G,b[L],!1,$,g);if(R)for(var U in R)Fa(c,N,+U,R[U],!0,$,g);return N}function kt(c,g,b){c==null&&(c=$s),$s=void 0;var N=this.constructor.i||0,R=0<N,$=this.constructor.h,A=!1;if(c==null){c=$?[$]:[];var L=48,U=!0;R&&(N=0,L|=128),ur(c,L)}else{if(!Array.isArray(c)||$&&$!==c[0])throw Error();var Z=L=Gr(c,0);if((U=(16&Z)!==0)&&((A=(32&Z)!==0)||(Z|=32)),R){if(128&Z)N=0;else if(0<c.length){var se=c[c.length-1];if(Bn(se)&&"g"in se){N=0,Z|=128,delete se.g;var we=!0,ue;for(ue in se){we=!1;break}we&&c.pop()}}}else if(128&Z)throw Error();L!==Z&&ur(c,Z)}this.G=($?0:-1)-N,this.h=void 0,this.o=c;e:{if($=this.o.length,N=$-1,$&&($=this.o[N],Bn($))){this.B=$,this.i=N-this.G;break e}g!==void 0&&-1<g?(this.i=Math.max(g,N+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!R&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(b){g=U&&!A&&!0,R=this.i;var ie;for(U=0;U<b.length;U++)A=b[U],A<R?(A+=this.G,(N=c[A])?La(N,g):c[A]=Wn):(ie||(ie=Pa(this)),(N=ie[A])?La(N,g):ie[A]=Wn)}}kt.prototype.toJSON=function(){return Es(this.o,Da,Oa)},kt.prototype.C=function(){return!!(at(this.o)&2)};function La(c,g){if(Array.isArray(c)){var b=at(c),N=1;!g||b&2||(N|=16),(b&N)!==N&&ur(c,b|N)}}kt.prototype.ja=ki,kt.prototype.toString=function(){return this.o.toString()};function Ei(c,g,b){if(b){var N={},R;for(R in b){var $=b[R],A=$.ra;A||(N.J=$.xa||$.oa.W,$.ia?(N.aa=Oi($.ia),A=function(L){return function(U,Z,se){return L.J(U,Z,se,L.aa)}}(N)):$.ka?(N.Z=Wa($.da.P,$.ka),A=function(L){return function(U,Z,se){return L.J(U,Z,se,L.Z)}}(N)):A=N.J,$.ra=A),A(g,c,$.da),N={J:N.J,aa:N.aa,Z:N.Z}}}iu(g,c)}var Hn=Symbol();function Os(c,g,b){return c[Hn]||(c[Hn]=function(N,R){return g(N,R,b)})}function za(c){var g=c[Hn];if(!g){var b=Li(c);g=function(N,R){return Ls(N,R,b)},c[Hn]=g}return g}function Ba(c){var g=c.ia;if(g)return za(g);if(g=c.wa)return Os(c.da.P,g,c.ka)}function Di(c){var g=Ba(c),b=c.da,N=c.oa.U;return g?function(R,$){return N(R,$,b,g)}:function(R,$){return N(R,$,b)}}function Fs(c,g){var b=c[g];return typeof b=="function"&&b.length===0&&(b=b(),c[g]=b),Array.isArray(b)&&(jn in b||wn in b||0<b.length&&typeof b[0]=="function")?b:void 0}function jr(c,g,b,N,R,$){g.P=c[0];var A=1;if(c.length>A&&typeof c[A]!="number"){var L=c[A++];b(g,L)}for(;A<c.length;){b=c[A++];for(var U=A+1;U<c.length&&typeof c[U]!="number";)U++;switch(L=c[A++],U-=A,U){case 0:N(g,b,L);break;case 1:(U=Fs(c,A))?(A++,R(g,b,L,U)):N(g,b,L,c[A++]);break;case 2:U=A++,U=Fs(c,U),R(g,b,L,U,c[A++]);break;case 3:$(g,b,L,c[A++],c[A++],c[A++]);break;case 4:$(g,b,L,c[A++],c[A++],c[A++],c[A++]);break;default:throw Error("unexpected number of binary field arguments: "+U)}}return g}var Gn=Symbol();function Oi(c){var g=c[Gn];if(!g){var b=Fi(c);g=function(N,R){return Ga(N,R,b)},c[Gn]=g}return g}function Wa(c,g){var b=c[Gn];return b||(b=function(N,R){return Ei(N,R,g)},c[Gn]=b),b}var wn=Symbol();function Va(c,g){c.push(g)}function Ua(c,g,b){c.push(g,b.W)}function Ma(c,g,b,N){var R=Oi(N),$=Fi(N).P,A=b.W;c.push(g,function(L,U,Z){return A(L,U,Z,$,R)})}function uu(c,g,b,N,R,$){var A=Wa(N,$),L=b.W;c.push(g,function(U,Z,se){return L(U,Z,se,N,A)})}function Fi(c){var g=c[wn];return g||(g=jr(c,c[wn]=[],Va,Ua,Ma,uu),jn in c&&wn in c&&(c.length=0),g)}var jn=Symbol();function Ha(c,g){c[0]=g}function lu(c,g,b,N){var R=b.U;c[g]=N?function($,A,L){return R($,A,L,N)}:R}function cu(c,g,b,N,R){var $=b.U,A=za(N),L=Li(N).P;c[g]=function(U,Z,se){return $(U,Z,se,L,A,R)}}function hu(c,g,b,N,R,$,A){var L=b.U,U=Os(N,R,$);c[g]=function(Z,se,we){return L(Z,se,we,N,U,A)}}function Li(c){var g=c[jn];return g||(g=jr(c,c[jn]={},Ha,lu,cu,hu),jn in c&&wn in c&&(c.length=0),g)}function Ls(c,g,b){for(;Ni(g)&&g.i!=4;){var N=g.l,R=b[N];if(!R){var $=b[0];$&&($=$[N])&&(R=b[N]=Di($))}if(!R||!R(g,c,N)){R=g,N=c,$=R.j,Rs(R);var A=R;if(!A.ca){if(R=A.h.h-$,A.h.h=$,A=A.h,R==0)R=Ln();else{if($=bi(A,R),A.S&&A.m)R=A.i.subarray($,$+R);else{A=A.i;var L=$;R=$+R,R=L===R?mi():Ss?A.slice(L,R):new Uint8Array(A.subarray(L,R))}R=R.length==0?Ln():new Ur(R,Nr)}($=N.R)?$.push(R):N.R=[R]}}}return c}function Ga(c,g,b){for(var N=b.length,R=N%2==1,$=R?1:0;$<N;$+=2)(0,b[$+1])(g,c,b[$]);Ei(c,g,R?b[0]:void 0)}function Kn(c,g){return{U:c,W:g}}var tr=Kn(function(c,g,b){if(c.i!==5)return!1;c=c.h;var N=c.i,R=c.h,$=N[R],A=N[R+1],L=N[R+2];return N=N[R+3],Mr(c,c.h+4),A=($<<0|A<<8|L<<16|N<<24)>>>0,c=2*(A>>31)+1,$=A>>>23&255,A&=8388607,Ft(g,b,$==255?A?NaN:1/0*c:$==0?c*Math.pow(2,-149)*A:c*Math.pow(2,$-150)*(A+Math.pow(2,23))),!0},function(c,g,b){if(g=Ri(g,b),g!=null){Hr(c.h,8*b+5),c=c.h;var N=+g;N===0?0<1/N?lt=Je=0:(Je=0,lt=2147483648):isNaN(N)?(Je=0,lt=2147483647):(N=(b=0>N?-2147483648:0)?-N:N,34028234663852886e22<N?(Je=0,lt=(b|2139095040)>>>0):11754943508222875e-54>N?(N=Math.round(N/Math.pow(2,-149)),Je=0,lt=(b|N)>>>0):(g=Math.floor(Math.log(N)/Math.LN2),N*=Math.pow(2,-g),N=Math.round(8388608*N),16777216<=N&&++g,Je=0,lt=(b|g+127<<23|N&8388607)>>>0)),b=lt,c.h.push(b>>>0&255),c.h.push(b>>>8&255),c.h.push(b>>>16&255),c.h.push(b>>>24&255)}}),pu=Kn(function(c,g,b){if(c.i!==0)return!1;var N=c.h,R=0,$=c=0,A=N.i,L=N.h;do{var U=A[L++];R|=(U&127)<<$,$+=7}while(32>$&&U&128);for(32<$&&(c|=(U&127)>>4),$=3;32>$&&U&128;$+=7)U=A[L++],c|=(U&127)<<$;if(Mr(N,L),128>U)N=R>>>0,U=c>>>0,(c=U&2147483648)&&(N=~N+1>>>0,U=~U>>>0,N==0&&(U=U+1>>>0)),N=4294967296*U+(N>>>0);else throw Br();return Ft(g,b,c?-N:N),!0},function(c,g,b){g=Jt(g,b),g!=null&&(typeof g=="string"&&_a(g),g!=null&&(Hr(c.h,8*b),typeof g=="number"?(c=c.h,dn(g),Ta(c,lt,Je)):(b=_a(g),Ta(c.h,b.i,b.h))))}),du=Kn(function(c,g,b){return c.i!==0?!1:(Ft(g,b,zn(c.h)),!0)},function(c,g,b){if(g=Jt(g,b),g!=null&&g!=null)if(Hr(c.h,8*b),c=c.h,b=g,0<=b)Hr(c,b);else{for(g=0;9>g;g++)c.h.push(b&127|128),b>>=7;c.h.push(1)}}),je=Kn(function(c,g,b){if(c.i!==2)return!1;var N=zn(c.h)>>>0;c=c.h;var R=bi(c,N);if(c=c.i,gn){var $=c,A;(A=Vr)||(A=Vr=new TextDecoder("utf-8",{fatal:!0})),c=R+N,$=R===0&&c===$.length?$:$.subarray(R,c);try{var L=A.decode($)}catch(we){if(Cs===void 0){try{A.decode(new Uint8Array([128]))}catch{}try{A.decode(new Uint8Array([97])),Cs=!0}catch{Cs=!1}}throw!Cs&&(Vr=void 0),we}}else{L=R,N=L+N,R=[];for(var U=null,Z,se;L<N;)Z=c[L++],128>Z?R.push(Z):224>Z?L>=N?Wr():(se=c[L++],194>Z||(se&192)!==128?(L--,Wr()):R.push((Z&31)<<6|se&63)):240>Z?L>=N-1?Wr():(se=c[L++],(se&192)!==128||Z===224&&160>se||Z===237&&160<=se||(($=c[L++])&192)!==128?(L--,Wr()):R.push((Z&15)<<12|(se&63)<<6|$&63)):244>=Z?L>=N-2?Wr():(se=c[L++],(se&192)!==128||(Z<<28)+(se-144)>>30!==0||(($=c[L++])&192)!==128||((A=c[L++])&192)!==128?(L--,Wr()):(Z=(Z&7)<<18|(se&63)<<12|($&63)<<6|A&63,Z-=65536,R.push((Z>>10&1023)+55296,(Z&1023)+56320))):Wr(),8192<=R.length&&(U=mn(U,R),R.length=0);L=mn(U,R)}return Ft(g,b,L),!0},function(c,g,b){if(g=Jt(g,b),g!=null){var N=!1;if(N=N===void 0?!1:N,yi){if(N&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(g))throw Error("Found an unpaired surrogate");g=(Ns||(Ns=new TextEncoder)).encode(g)}else{for(var R=0,$=new Uint8Array(3*g.length),A=0;A<g.length;A++){var L=g.charCodeAt(A);if(128>L)$[R++]=L;else{if(2048>L)$[R++]=L>>6|192;else{if(55296<=L&&57343>=L){if(56319>=L&&A<g.length){var U=g.charCodeAt(++A);if(56320<=U&&57343>=U){L=1024*(L-55296)+U-56320+65536,$[R++]=L>>18|240,$[R++]=L>>12&63|128,$[R++]=L>>6&63|128,$[R++]=L&63|128;continue}else A--}if(N)throw Error("Found an unpaired surrogate");L=65533}$[R++]=L>>12|224,$[R++]=L>>6&63|128}$[R++]=L&63|128}}g=R===$.length?$:$.subarray(0,R)}Hr(c.h,8*b+2),Hr(c.h,g.length),Ir(c,c.h.end()),Ir(c,g)}}),He=Kn(function(c,g,b,N,R){if(c.i!==2)return!1;g=Pi(g,b,N),b=c.h.j,N=zn(c.h)>>>0;var $=c.h.h+N,A=$-b;if(0>=A&&(c.h.j=$,R(g,c,void 0,void 0,void 0),A=$-c.h.h),A)throw Error("Message parsing ended unexpectedly. Expected to read "+(N+" bytes, instead read "+(N-A)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return c.h.h=$,c.h.j=b,!0},function(c,g,b,N,R){if(g=Ai(g,N,b),g!=null)for(N=0;N<g.length;N++){var $=c;Hr($.h,8*b+2);var A=$.h.end();Ir($,A),A.push($.i),$=A,R(g[N],c),A=c;var L=$.pop();for(L=A.i+A.h.length()-L;127<L;)$.push(L&127|128),L>>>=7,A.i++;$.push(L),A.i++}});function zi(c){return function(g,b){e:{if(As.length){var N=As.pop();N.setOptions(b),vi(N.h,g,b),g=N}else g=new Ci(g,b);try{var R=Li(c),$=Ls(new R.P,g,R);break e}finally{R=g.h,R.i=null,R.m=!1,R.l=0,R.j=0,R.h=0,R.S=!1,g.l=-1,g.i=-1,100>As.length&&As.push(g)}$=void 0}return $}}function Bi(c){return function(){var g=new su;Ga(this,g,Fi(c)),Ir(g,g.h.end());for(var b=new Uint8Array(g.i),N=g.j,R=N.length,$=0,A=0;A<R;A++){var L=N[A];b.set(L,$),$+=L.length}return g.j=[b],b}}function vn(c){kt.call(this,c)}k(vn,kt);var ja=[vn,1,du,2,tr,3,je,4,je];vn.prototype.l=Bi(ja);function Wi(c){kt.call(this,c,-1,fu)}k(Wi,kt),Wi.prototype.addClassification=function(c,g){return Pi(this,1,vn,c,g),this};var fu=[1],Ka=zi([Wi,1,He,ja]);function qn(c){kt.call(this,c)}k(qn,kt);var yt=[qn,1,tr,2,tr,3,tr,4,tr,5,tr];qn.prototype.l=Bi(yt);function zs(c){kt.call(this,c,-1,Kr)}k(zs,kt);var Kr=[1],qa=zi([zs,1,He,yt]);function bn(c){kt.call(this,c)}k(bn,kt);var Lt=[bn,1,tr,2,tr,3,tr,4,tr,5,tr,6,pu],Xa=zi(Lt);bn.prototype.l=Bi(Lt);function Vi(c,g,b){if(b=c.createShader(b===0?c.VERTEX_SHADER:c.FRAGMENT_SHADER),c.shaderSource(b,g),c.compileShader(b),!c.getShaderParameter(b,c.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+c.getShaderInfoLog(b));return b}function Ya(c){return Ai(c,vn,1).map(function(g){var b=Jt(g,1);return{index:b??0,qa:lr(g,2),label:Jt(g,3)!=null?Un(Jt(g,3),""):void 0,displayName:Jt(g,4)!=null?Un(Jt(g,4),""):void 0}})}function Qa(c){return{x:lr(c,1),y:lr(c,2),z:lr(c,3),visibility:Ri(c,4)!=null?lr(c,4):void 0}}function Bs(c){return Ai(qa(c),qn,1).map(Qa)}function Ws(c,g){this.i=c,this.h=g,this.m=0}function Tt(c,g,b){return mu(c,g),typeof c.h.canvas.transferToImageBitmap=="function"?Promise.resolve(c.h.canvas.transferToImageBitmap()):b?Promise.resolve(c.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(c.h.canvas):(c.j===void 0&&(c.j=document.createElement("canvas")),new Promise(function(N){c.j.height=c.h.canvas.height,c.j.width=c.h.canvas.width,c.j.getContext("2d",{}).drawImage(c.h.canvas,0,0,c.h.canvas.width,c.h.canvas.height),N(c.j)}))}function mu(c,g){var b=c.h;if(c.s===void 0){var N=Vi(b,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),R=Vi(b,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),$=b.createProgram();if(b.attachShader($,N),b.attachShader($,R),b.linkProgram($),!b.getProgramParameter($,b.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+b.getProgramInfoLog($));N=c.s=$,b.useProgram(N),R=b.getUniformLocation(N,"sampler0"),c.l={O:b.getAttribLocation(N,"aVertex"),N:b.getAttribLocation(N,"aTex"),ya:R},c.v=b.createBuffer(),b.bindBuffer(b.ARRAY_BUFFER,c.v),b.enableVertexAttribArray(c.l.O),b.vertexAttribPointer(c.l.O,2,b.FLOAT,!1,0,0),b.bufferData(b.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),b.STATIC_DRAW),b.bindBuffer(b.ARRAY_BUFFER,null),c.u=b.createBuffer(),b.bindBuffer(b.ARRAY_BUFFER,c.u),b.enableVertexAttribArray(c.l.N),b.vertexAttribPointer(c.l.N,2,b.FLOAT,!1,0,0),b.bufferData(b.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),b.STATIC_DRAW),b.bindBuffer(b.ARRAY_BUFFER,null),b.uniform1i(R,0)}N=c.l,b.useProgram(c.s),b.canvas.width=g.width,b.canvas.height=g.height,b.viewport(0,0,g.width,g.height),b.activeTexture(b.TEXTURE0),c.i.bindTexture2d(g.glName),b.enableVertexAttribArray(N.O),b.bindBuffer(b.ARRAY_BUFFER,c.v),b.vertexAttribPointer(N.O,2,b.FLOAT,!1,0,0),b.enableVertexAttribArray(N.N),b.bindBuffer(b.ARRAY_BUFFER,c.u),b.vertexAttribPointer(N.N,2,b.FLOAT,!1,0,0),b.bindFramebuffer(b.DRAW_FRAMEBUFFER?b.DRAW_FRAMEBUFFER:b.FRAMEBUFFER,null),b.clearColor(0,0,0,0),b.clear(b.COLOR_BUFFER_BIT),b.colorMask(!0,!0,!0,!0),b.drawArrays(b.TRIANGLE_FAN,0,4),b.disableVertexAttribArray(N.O),b.disableVertexAttribArray(N.N),b.bindBuffer(b.ARRAY_BUFFER,null),c.i.bindTexture2d(0)}function Mt(c){this.h=c}var gu=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Za(c,g){return g+c}function wr(c,g){window[c]=g}function Vs(c){var g=document.createElement("script");return g.setAttribute("src",c),g.setAttribute("crossorigin","anonymous"),new Promise(function(b){g.addEventListener("load",function(){b()},!1),g.addEventListener("error",function(){b()},!1),document.body.appendChild(g)})}function Ui(){return ne(function(c){switch(c.h){case 1:return c.s=2,F(c,WebAssembly.instantiate(gu),4);case 4:c.h=3,c.s=0;break;case 2:return c.s=0,c.l=null,c.return(!1);case 3:return c.return(!0)}})}function Ke(c){if(this.h=c,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=c&&c.locateFile||Za,typeof window=="object")var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=g,c.options){g=l(Object.keys(c.options));for(var b=g.next();!b.done;b=g.next()){b=b.value;var N=c.options[b].default;N!==void 0&&(this.l[b]=typeof N=="function"?N():N)}}}r=Ke.prototype,r.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function kr(c){var g,b,N,R,$,A,L,U,Z,se,we;return ne(function(ue){switch(ue.h){case 1:return c.ga?(g=c.h.files===void 0?[]:typeof c.h.files=="function"?c.h.files(c.l):c.h.files,F(ue,Ui(),2)):ue.return();case 2:if(b=ue.i,typeof window=="object")return wr("createMediapipeSolutionsWasm",{locateFile:c.locateFile}),wr("createMediapipeSolutionsPackedAssets",{locateFile:c.locateFile}),A=g.filter(function(ie){return ie.data!==void 0}),L=g.filter(function(ie){return ie.data===void 0}),U=Promise.all(A.map(function(ie){var ge=xn(c,ie.url);if(ie.path!==void 0){var _e=ie.path;ge=ge.then(function(qe){return c.overrideFile(_e,qe),Promise.resolve(qe)})}return ge})),Z=Promise.all(L.map(function(ie){return ie.simd===void 0||ie.simd&&b||!ie.simd&&!b?Vs(c.locateFile(ie.url,c.ha)):Promise.resolve()})).then(function(){var ie,ge,_e;return ne(function(qe){if(qe.h==1)return ie=window.createMediapipeSolutionsWasm,ge=window.createMediapipeSolutionsPackedAssets,_e=c,F(qe,ie(ge),2);_e.i=qe.i,qe.h=0})}),se=function(){return ne(function(ie){return c.h.graph&&c.h.graph.url?ie=F(ie,xn(c,c.h.graph.url),0):(ie.h=0,ie=void 0),ie})}(),F(ue,Promise.all([Z,U,se]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return N=g.filter(function(ie){return ie.simd===void 0||ie.simd&&b||!ie.simd&&!b}).map(function(ie){return c.locateFile(ie.url,c.ha)}),importScripts.apply(null,p(N)),R=c,F(ue,createMediapipeSolutionsWasm(Module),6);case 6:R.i=ue.i,c.m=new OffscreenCanvas(1,1),c.i.canvas=c.m,$=c.i.GL.createContext(c.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),c.i.GL.makeContextCurrent($),ue.h=4;break;case 7:if(c.m=document.createElement("canvas"),we=c.m.getContext("webgl2",{}),!we&&(we=c.m.getContext("webgl",{}),!we))return alert("Failed to create WebGL canvas context when passing video frame."),ue.return();c.K=we,c.i.canvas=c.m,c.i.createContext(c.m,!0,!0,{});case 4:c.j=new c.i.SolutionWasm,c.ga=!1,ue.h=0}})}function Mi(c){var g,b,N,R,$,A,L,U;return ne(function(Z){if(Z.h==1){if(c.h.graph&&c.h.graph.url&&c.fa===c.h.graph.url)return Z.return();if(c.u=!0,!c.h.graph||!c.h.graph.url){Z.h=2;return}return c.fa=c.h.graph.url,F(Z,xn(c,c.h.graph.url),3)}for(Z.h!=2&&(g=Z.i,c.j.loadGraph(g)),b=l(Object.keys(c.D)),N=b.next();!N.done;N=b.next())R=N.value,c.j.overrideFile(R,c.D[R]);if(c.D={},c.h.listeners)for($=l(c.h.listeners),A=$.next();!A.done;A=$.next())L=A.value,bu(c,L);U=c.l,c.l={},c.setOptions(U),Z.h=0})}r.reset=function(){var c=this;return ne(function(g){c.j&&(c.j.reset(),c.s={},c.v={}),g.h=0})},r.setOptions=function(c,g){var b=this;if(g=g||this.h.options){for(var N=[],R=[],$={},A=l(Object.keys(c)),L=A.next();!L.done;$={X:$.X,Y:$.Y},L=A.next())if(L=L.value,!(L in this.l&&this.l[L]===c[L])){this.l[L]=c[L];var U=g[L];U!==void 0&&(U.onChange&&($.X=U.onChange,$.Y=c[L],N.push(function(Z){return function(){var se;return ne(function(we){if(we.h==1)return F(we,Z.X(Z.Y),2);se=we.i,se===!0&&(b.u=!0),we.h=0})}}($))),U.graphOptionXref&&(L=Object.assign({},{calculatorName:"",calculatorIndex:0},U.graphOptionXref,{valueNumber:U.type===1?c[L]:0,valueBoolean:U.type===0?c[L]:!1,valueString:U.type===2?c[L]:""}),R.push(L)))}(N.length!==0||R.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(R),this.F=(this.F===void 0?[]:this.F).concat(N))}};function yu(c){var g,b,N,R,$,A,L;return ne(function(U){switch(U.h){case 1:if(!c.u)return U.return();if(!c.F){U.h=2;break}g=l(c.F),b=g.next();case 3:if(b.done){U.h=5;break}return N=b.value,F(U,N(),4);case 4:b=g.next(),U.h=3;break;case 5:c.F=void 0;case 2:if(c.H){for(R=new c.i.GraphOptionChangeRequestList,$=l(c.H),A=$.next();!A.done;A=$.next())L=A.value,R.push_back(L);c.j.changeOptions(R),R.delete(),c.H=void 0}c.u=!1,U.h=0}})}r.initialize=function(){var c=this;return ne(function(g){return g.h==1?F(g,kr(c),2):g.h!=3?F(g,Mi(c),3):F(g,yu(c),0)})};function xn(c,g){var b,N;return ne(function(R){return g in c.L?R.return(c.L[g]):(b=c.locateFile(g,""),N=fetch(b).then(function($){return $.arrayBuffer()}),c.L[g]=N,R.return(N))})}r.overrideFile=function(c,g){this.j?this.j.overrideFile(c,g):this.D[c]=g},r.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},r.send=function(c,g){var b=this,N,R,$,A,L,U,Z,se,we;return ne(function(ue){switch(ue.h){case 1:return b.h.inputs?(N=1e3*(g??performance.now()),F(ue,b.I,2)):ue.return();case 2:return F(ue,b.initialize(),3);case 3:for(R=new b.i.PacketDataList,$=l(Object.keys(c)),A=$.next();!A.done;A=$.next())if(L=A.value,U=b.h.inputs[L]){e:{var ie=c[L];switch(U.type){case"video":var ge=b.s[U.stream];if(ge||(ge=new Ws(b.i,b.K),b.s[U.stream]=ge),ge.m===0&&(ge.m=ge.i.createTexture()),typeof HTMLVideoElement<"u"&&ie instanceof HTMLVideoElement)var _e=ie.videoWidth,qe=ie.videoHeight;else typeof HTMLImageElement<"u"&&ie instanceof HTMLImageElement?(_e=ie.naturalWidth,qe=ie.naturalHeight):(_e=ie.width,qe=ie.height);qe={glName:ge.m,width:_e,height:qe},_e=ge.h,_e.canvas.width=qe.width,_e.canvas.height=qe.height,_e.activeTexture(_e.TEXTURE0),ge.i.bindTexture2d(ge.m),_e.texImage2D(_e.TEXTURE_2D,0,_e.RGBA,_e.RGBA,_e.UNSIGNED_BYTE,ie),ge.i.bindTexture2d(0),ge=qe;break e;case"detections":for(ge=b.s[U.stream],ge||(ge=new Mt(b.i),b.s[U.stream]=ge),ge.data||(ge.data=new ge.h.DetectionListData),ge.data.reset(ie.length),qe=0;qe<ie.length;++qe){_e=ie[qe];var Xe=ge.data,wt=Xe.setBoundingBox,Ht=qe,Rt=_e.la,Be=new bn;if(er(Be,1,Rt.sa),er(Be,2,Rt.ta),er(Be,3,Rt.height),er(Be,4,Rt.width),er(Be,5,Rt.rotation),Ft(Be,6,Rt.pa),Rt=Be.l(),wt.call(Xe,Ht,Rt),_e.ea)for(Xe=0;Xe<_e.ea.length;++Xe){Be=_e.ea[Xe],wt=ge.data,Ht=wt.addNormalizedLandmark,Rt=qe,Be=Object.assign({},Be,{visibility:Be.visibility?Be.visibility:0});var st=new qn;er(st,1,Be.x),er(st,2,Be.y),er(st,3,Be.z),Be.visibility&&er(st,4,Be.visibility),Be=st.l(),Ht.call(wt,Rt,Be)}if(_e.ba)for(Xe=0;Xe<_e.ba.length;++Xe)wt=ge.data,Ht=wt.addClassification,Rt=qe,Be=_e.ba[Xe],st=new vn,er(st,2,Be.qa),Be.index&&Ft(st,1,Be.index),Be.label&&Ft(st,3,Be.label),Be.displayName&&Ft(st,4,Be.displayName),Be=st.l(),Ht.call(wt,Rt,Be)}ge=ge.data;break e;default:ge={}}}switch(Z=ge,se=U.stream,U.type){case"video":R.pushTexture2d(Object.assign({},Z,{stream:se,timestamp:N}));break;case"detections":we=Z,we.stream=se,we.timestamp=N,R.pushDetectionList(we);break;default:throw Error("Unknown input config type: '"+U.type+"'")}}return b.j.send(R),F(ue,b.I,4);case 4:R.delete(),ue.h=0}})};function wu(c,g,b){var N,R,$,A,L,U,Z,se,we,ue,ie,ge,_e,qe;return ne(function(Xe){switch(Xe.h){case 1:if(!b)return Xe.return(g);for(N={},R=0,$=l(Object.keys(b)),A=$.next();!A.done;A=$.next())L=A.value,U=b[L],typeof U!="string"&&U.type==="texture"&&g[U.stream]!==void 0&&++R;1<R&&(c.M=!1),Z=l(Object.keys(b)),A=Z.next();case 2:if(A.done){Xe.h=4;break}if(se=A.value,we=b[se],typeof we=="string")return _e=N,qe=se,F(Xe,vu(c,se,g[we]),14);if(ue=g[we.stream],we.type==="detection_list"){if(ue){for(var wt=ue.getRectList(),Ht=ue.getLandmarksList(),Rt=ue.getClassificationsList(),Be=[],st=0;st<wt.size();++st){var _r=Xa(wt.get(st)),xu=lr(_r,1),Gi=lr(_r,2),Ja=lr(_r,3),Tr=lr(_r,4),Us=lr(_r,5,0),Ms=void 0;Ms=Ms===void 0?0:Ms,_r={la:{sa:xu,ta:Gi,height:Ja,width:Tr,rotation:Us,pa:Un(Jt(_r,6),Ms)},ea:Bs(Ht.get(st)),ba:Ya(Ka(Rt.get(st)))},Be.push(_r)}wt=Be}else wt=[];N[se]=wt,Xe.h=7;break}if(we.type==="proto_list"){if(ue){for(wt=Array(ue.size()),Ht=0;Ht<ue.size();Ht++)wt[Ht]=ue.get(Ht);ue.delete()}else wt=[];N[se]=wt,Xe.h=7;break}if(ue===void 0){Xe.h=3;break}if(we.type==="float_list"){N[se]=ue,Xe.h=7;break}if(we.type==="proto"){N[se]=ue,Xe.h=7;break}if(we.type!=="texture")throw Error("Unknown output config type: '"+we.type+"'");return ie=c.v[se],ie||(ie=new Ws(c.i,c.K),c.v[se]=ie),F(Xe,Tt(ie,ue,c.M),13);case 13:ge=Xe.i,N[se]=ge;case 7:we.transform&&N[se]&&(N[se]=we.transform(N[se])),Xe.h=3;break;case 14:_e[qe]=Xe.i;case 3:A=Z.next(),Xe.h=2;break;case 4:return Xe.return(N)}})}function vu(c,g,b){var N;return ne(function(R){return typeof b=="number"||b instanceof Uint8Array||b instanceof c.i.Uint8BlobList?R.return(b):b instanceof c.i.Texture2dDataOut?(N=c.v[g],N||(N=new Ws(c.i,c.K),c.v[g]=N),R.return(Tt(N,b,c.M))):R.return(void 0)})}function bu(c,g){for(var b=g.name||"$",N=[].concat(p(g.wants)),R=new c.i.StringList,$=l(g.wants),A=$.next();!A.done;A=$.next())R.push_back(A.value);$=c.i.PacketListener.implement({onResults:function(L){for(var U={},Z=0;Z<g.wants.length;++Z)U[N[Z]]=L.get(Z);var se=c.listeners[b];se&&(c.I=wu(c,U,g.outs).then(function(we){we=se(we);for(var ue=0;ue<g.wants.length;++ue){var ie=U[N[ue]];typeof ie=="object"&&ie.hasOwnProperty&&ie.hasOwnProperty("delete")&&ie.delete()}we&&(c.I=we)}))}}),c.j.attachMultiListener(R,$),R.delete()}r.onResults=function(c,g){this.listeners[g||"$"]=c},Ne("Solution",Ke),Ne("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Hi(c){switch(c===void 0&&(c=0),c){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Xn(c){var g=this;c=c||{},this.h=new Ke({locateFile:c.locateFile,files:function(b){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Hi(b.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Bs},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Bs},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(b){var N,R,$;return ne(function(A){return A.h==1?(N=Hi(b),R="third_party/mediapipe/modules/pose_landmark/"+N,F(A,xn(g.h,N),2)):($=A.i,g.h.overrideFile(R,$),A.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}r=Xn.prototype,r.reset=function(){this.h.reset()},r.close=function(){return this.h.close(),Promise.resolve()},r.onResults=function(c){this.h.onResults(c)},r.initialize=function(){var c=this;return ne(function(g){return F(g,c.h.initialize(),0)})},r.send=function(c,g){var b=this;return ne(function(N){return F(N,b.h.send(c,g),0)})},r.setOptions=function(c){this.h.setOptions(c)},Ne("Pose",Xn),Ne("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),Ne("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),Ne("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),Ne("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),Ne("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),Ne("VERSION","0.5.1675469404")}).call(bl)),bl}var k_=I_();/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ar=Qe();ar.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);ar.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);ar.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);ar.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);ar.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);ar.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);ar.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);ar.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);ar.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);ar.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);ar.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);ar.registerFlag("WEBGPU_PRINT_SHADER",()=>"");ar.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class __{constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T_{constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,s=!1,i=!0){let o;const u=Op(t,e);return i?(this.freeBuffers.has(u)||this.freeBuffers.set(u,[]),this.freeBuffers.get(u).length>0?(o=this.freeBuffers.get(u).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t)):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t),this.usedBuffers.has(u)||this.usedBuffers.set(u,[]),this.usedBuffers.get(u).push(o),this.numUsedBuffers++,this.numBytesUsed+=t,o}releaseBuffer(t,e=!0){if(this.freeBuffers.size===0)return;const s=t.size,i=t.usage,o=Op(s,i),u=this.usedBuffers.get(o),l=u.indexOf(t);if(l<0)throw new Error("Cannot find the buffer in buffer manager");u[l]=u[u.length-1],u.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,e?(this.freeBuffers.get(o).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Op(r,t){return`${r}_${t}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_{constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,s,i){const o=Lp(s),u=t*e*o,l=Fp(t,e,s,i);if(this.freeTextures.has(l)||this.freeTextures.set(l,[]),this.usedTextures.has(l)||this.usedTextures.set(l,[]),this.numBytesUsed+=u,this.numUsedTextures++,this.freeTextures.get(l).length>0){this.numFreeTextures--;const d=this.freeTextures.get(l).shift();return this.usedTextures.get(l).push(d),d}this.numBytesAllocated+=u;const p=this.device.createTexture({size:[t,e],format:s,usage:i});return this.usedTextures.get(l).push(p),p}releaseTexture(t){if(this.freeTextures.size===0)return;const e=t.width,s=t.height,i=t.format,o=t.usage,u=Fp(e,s,i,o);this.freeTextures.has(u)||this.freeTextures.set(u,[]),this.freeTextures.get(u).push(t),this.numFreeTextures++,this.numUsedTextures--;const l=this.usedTextures.get(u),p=l.indexOf(t);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1);const d=Lp(i),f=e*s*d;this.numBytesUsed-=f}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Fp(r,t,e,s){return`${r}_${t}_${e}_${s}`}function Lp(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(r,t){if(Math.max(...r)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const e=r.length,s="xyzwuv",i=r.map(u=>`${t}.${s[u]}`),o=new Array(e-1);o[e-2]=i[e-1];for(let u=e-3;u>=0;--u)o[u]=`(${o[u+1]} * ${i[u+1]})`;return o}const $n=(r,t,e)=>e==="int32"?`atomicAdd(${r}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${r}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ci;(function(r){r[r.FROM_PIXELS=0]="FROM_PIXELS",r[r.DRAW=1]="DRAW"})(ci||(ci={}));const P_=(r,t,e,s,i)=>{const o={dtype:s.dtype,shape:s.shape},u=E_(e,o,t),l=r.createShaderModule({code:u,label:t.constructor.name});let p=Qe().get("WEBGPU_PRINT_SHADER");if(p!==""){p=p.toLowerCase();const d=p.split(",");(p==="all"||d.some(f=>t.shaderKey.toLowerCase().includes(f)))&&(console.group(t.shaderKey),console.debug(u),console.groupEnd())}return i?r.createComputePipelineAsync({compute:{module:l,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):r.createComputePipeline({compute:{module:l,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},Te=(r,t="f32")=>{switch(r){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${r}-component ${t} is not supported.`)}};function ht(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function un(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function te(...r){let t;switch(r.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function zp(r,t){let e;return e=`
     ${$_(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r?"main(getGlobalIndex());":"main();"};
      }
    `,e}function $_(r){return`
  @compute @workgroup_size(${r.workgroupSize[0]}, ${r.workgroupSize[1]}, ${r.workgroupSize[2]})
`}function E_(r,t,e){const s=[],i=e.workgroupSize[0]*e.workgroupSize[1]*e.workgroupSize[2];if(e.outputComponent=e.outputComponent?e.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${gf(e)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),e.pixelsOpType!=null){const C=e.pixelsOpType===ci.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${as(t.dtype,e.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${as(r[0].dtype,e.outputComponent)}>;`,I=t.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${I},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${C}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const k=Wp(e);return[Bp,s.join(`
`),Wo(t.shape),e.getUserCode(),zp(k,e)].join(`
`)}let o,u,l="struct Uniforms { NAN : f32, INFINITY : f32, ";e.variableNames.forEach((C,I)=>{const k=ht(r[I].shape.length);l+=`${C.charAt(0).toLowerCase()+C.slice(1)}Shape : ${k}, `,o=r[I].shape.length-1,u=ht(o),l+=`${C.charAt(0).toLowerCase()+C.slice(1)}ShapeStrides: ${u}, `});const p=ht(t.shape.length);l+=`outShape : ${p}, `,o=t.shape.length-1,u=ht(o),l+=`
         outShapeStrides: ${u}, `,e.size&&(l+="size : i32, "),e.uniforms&&(l+=e.uniforms),l+="};",l=U_(l),s.push(l),e.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${as(t.dtype,e.outputComponent)}>;
    `),e.variableNames.forEach((C,I)=>{s.push(`
      @group(0) @binding(${1+I}) var<storage, read> ${C}: array<${e.variableComponents?as(r[I].dtype,e.variableComponents[I]):as(r[I].dtype,e.outputComponent)}>;
        `)}),l!==""&&s.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const d=B_(t.shape,e.dispatchLayout),f=[Bp,s.join(`
`)+O_,Wo(t.shape),d,W_(t.shape.length)];e.atomic||f.push(V_(t.shape,t.dtype,e.outputComponent)),e.variableNames.forEach((C,I)=>{f.push(`${Wo(r[I].shape,C)}`)});const m=r.map((C,I)=>z_(C,t.shape,e.variableComponents?e.variableComponents[I]:e.outputComponent,e.dispatchLayout.x.length===t.shape.length)).join(`
`);f.push(m),f.push(e.getUserCode());const w=Wp(e);return f.push(zp(w,e)),f.join(`
`)}function D_(r,t,e){let s=r.shaderKey;if(r.pixelsOpType!=null)return s;const i=[],o=[];t.forEach(f=>{i.push(f.shape),o.push(f.dtype)}),i.push(e.shape),o.push(e.dtype);const u=t.map(f=>Jd(f.shape,e.shape)),l=t.map(f=>Cr(f.shape,e.shape)).join("_"),p=u.map(f=>f.join("_")).join(";"),d=gf(r)?"flatDispatch":"";return s+="_"+(r.workgroupSize?r.workgroupSize.join(","):"")+i.map(f=>f.length).join(",")+o.join(",")+r.variableNames.join(",")+p+l+d,s}const Bp=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,O_=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Wo(r,t=""){const e=r.length,s=t!==""?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=t!==""?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(e<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const o=da(r),u=ht(e),l=[];for(let d=0;d<e;d++)l.push(`d${d}`);if(o.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let p;return p="var index2 = index;"+o.map((d,f)=>{const m=`let ${l[f]} = index2 / uniforms.${i}.${un(f)}`,w=f===o.length-1?`let ${l[f+1]} = index2 - ${l[f]} * uniforms.${i}.${un(f)}`:`index2 = index2 - ${l[f]} * uniforms.${i}.${un(f)}`;return`${m}; ${w};`}).join(""),`
    fn ${s}(index : i32) -> ${u} {
      ${p}
      return ${u}(${l.join(",")});
    }
  `}function F_(r,t){const e=r.name,s=r.shape.length,i=ht(s),o="get"+e.charAt(0).toUpperCase()+e.slice(1),u=["d0","d1","d2","d3","d4","d5"].slice(0,s),l=u.map(f=>`${f} : i32`).join(", ");if(s<1)return`
      fn ${o}() -> ${Te(t)} {
        return ${Te(t)}(${e}[0]);
      }
    `;const p=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`;let d=`${s}D`;return s===0&&(d="1D"),`
    fn ${o}(${l}) -> ${Te(t)} {
      return ${Te(t)}(${e}[getIndexFromCoords${d}(${i}(${u.join(",")}),
        ${p})${t===1?"":` / ${t}`}]);
    }
   `}function L_(r,t,e,s){const i=r.name,o=i.charAt(0).toUpperCase()+i.slice(1),u="get"+o+"ByOutput",l=r.shape.length,p=t.length,d=ht(p);if(Cr(r.shape,t)&&s)return`
    fn ${u}Index(globalIndex : i32) -> ${Te(e)} {
      return ${Te(e)}(${i}[globalIndex]);
    }

    fn ${u}Coords(coords : ${d}) -> ${Te(e)} {
      return ${Te(e)}(${i}[${p>1?"getOutputIndexFromCoords(coords)":"coords"}${e===1?"":` / ${e}`}]);
    }
    `;const f=Jd(r.shape,t),m=p-l;let w="";if(l===0)return`
    fn ${u}Index(globalIndex : i32) -> ${Te(e)}{
      return get${o}();
    }

    fn ${u}Coords(coords : ${d}) -> ${Te(e)}{
      return get${o}();
    }
  `;p<2&&f.length>=1?w="coords = 0;":w=f.map(k=>`coords.${un(k+m)} = 0;`).join(`
`);let x="";if(p<2&&l>0)x="coords";else if(p>1){const k=ht(l),P=r.shape.map((O,z)=>`coords.${un(z+m)}`).join(", ");x=`${k}(${P})`}else x="coords";const C=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,I=`${l}D`;return`
  fn ${u}Index(globalIndex : i32) -> ${Te(e)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${w}
    return ${Te(e)}(${i}[getIndexFromCoords${I}(${x}, ${C})${e===1?"":` / ${e}`}]);
  }

  fn ${u}Coords(coordsIn : ${d}) -> ${Te(e)} {
    var coords = coordsIn;
    ${w}
    return ${Te(e)}(${i}[getIndexFromCoords${I}(${x}, ${C})${e===1?"":` / ${e}`}]);
  }
`}function z_(r,t,e,s){let i=F_(r,e);return r.shape.length<=t.length&&(i+=L_(r,t,e,s)),i}function B_(r,t){const{x:e,y:s=[],z:i=[]}=t,o=r.length,u=e.length+s.length+i.length;if(u!==o)return"";if(e.length===o)return`fn getOutputCoords() -> ${ht(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let l="";const p=[e,s,i];for(let w=0;w<p.length;w++){const x=p[w];if(x.length!==0)if(x.length===1)l+=`let d${x[0]} = i32(globalId[${w}]);`;else{const C=A_(x,"uniforms.outShape");l+=`var index${w} = i32(globalId[${w}]);`;for(let I=0;I<C.length;I++)l+=`let d${x[I]} = index${w} / ${C[I]};`,I===C.length-1?l+=`let d${x[I+1]} = index${w} - d${x[I]} * ${C[I]};`:l+=`index${w} = index${w} - d${x[I]} * ${C[I]};`}}const d=[];for(let w=0;w<u;w++)d.push(`d${w}`);const f=ht(u);let m=`fn getOutputCoords() -> ${f} {
  ${l}
`;return d.length===0?m+=`return ${f}(0); }`:m+=`return ${f}(${d.join(",")}); }`,m}function W_(r){let t="";switch(r){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:le(!1,()=>`Unsupported ${r}D shape`);break}return t}function gf(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function as(r,t=1){if(r==="float32")return Te(t,"f32");if(r==="int32"||r==="bool")return Te(t,"i32");throw new Error(`type ${r} is not supported.`)}function V_(r,t,e){const s=r.length,i=as(t,e);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${Te(e)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Te(e,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(s>=2){const u=["d0","d1","d2","d3","d4","d5"].slice(0,s),l=ht(s);o+=`
      fn setOutputAtCoords(${u.map(p=>`${p} : i32`).join(", ")}, value : ${Te(e)}) {
        let flatIndex = getOutputIndexFromCoords(${l}(${u.join(", ")}));
        setOutputAtIndex(flatIndex${e===1?"":` / ${e}`}, value);
      }
      fn setOutputAtCoordsI32(${u.map(p=>`${p} : i32`).join(", ")}, value : ${Te(e,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${l}(${u.join(", ")}));
        setOutputAtIndexI32(flatIndex${e===1?"":` / ${e}`}, value);
      }
    `}return o}function U_(r){const t=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(t,s=>"@align(16) "+s);const e=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(e,(s,i,o)=>`vec${i}, @align(16) ${o}`),r}function Wp(r){return!(r.dispatchLayout.hasOwnProperty("y")&&r.dispatchLayout.y.length!==0||r.dispatchLayout.hasOwnProperty("z")&&r.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hs=r=>{let t=1;for(let e=0;e<r.length;e++)t*=r[e];return t};function re(r,t,e=[1,1,1],s=[1,1,1]){const[i,o,u]=[Math.ceil(hs(r.x.map(l=>t[l]))/(e[0]*s[0])),r.y?Math.ceil(hs(r.y.map(l=>t[l]))/(e[1]*s[1])):1,r.z?Math.ceil(hs(r.z.map(l=>t[l]))/(e[2]*s[2])):1];return[i,o,u]}function M_(r,t,e,s=!1){const i=[8,8,1],o=[4,4,1];return s||(r<=8&&(o[1]=1),t<=16&&e<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:o}}function yf(r,t,e=!1){if(e)return[8,8,1];const s=hs(r.x.map(o=>t[o])),i=hs(r.y.map(o=>t[o]));return s<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function wf(r,t,e=!1){if(e)return[4,4,1];const s=hs(r.x.map(o=>t[o])),i=hs(r.y.map(o=>t[o]));return s<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function ae(r){return{x:r.map((t,e)=>e)}}function Vp(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function vf(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function bf(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&le(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}var $r;(function(r){r[r.MatMulReduceProgram=0]="MatMulReduceProgram",r[r.MatMulSplitKProgram=1]="MatMulSplitKProgram",r[r.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",r[r.MatMulPackedProgram=3]="MatMulPackedProgram",r[r.MatMulMax=4]="MatMulMax"})($r||($r={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H_=Qe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),G_=(r,t)=>{const e=r.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,i=t.dispatch;if(i.every(u=>u<=e))return i;le(i[0]>e&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(i[0]));return o>e?(o=Math.ceil(Math.cbrt(i[0])),le(o<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class pi extends T2{nextDataId(){return pi.nextDataId++}constructor(t,e){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!vf())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=t,this.queue=t.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new __(e),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new T_(this.device),this.textureManager=new R_(this.device),this.tensorMap=new R2(this,ai()),Qe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(t,e=!1){if(!this.tensorMap.has(t))return!0;const s=this.tensorMap.get(t);return e?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(t)?(this.tensorDataPendingDisposal.push(t),!0):(this.releaseResource(t),this.tensorMap.delete(t),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(t){const e=this.tensorMap.get(t);if(!(!e||!e.resource)){if(e.external){e.resource=null;return}e.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(e.resource):e.resource instanceof GPUTexture&&this.textureManager.releaseTexture(e.resource),e.resource=null}}refCount(t){return this.tensorMap.has(t)?this.tensorMap.get(t).refCount:0}incRef(t){const e=this.tensorMap.get(t);e.refCount++}decRef(t){if(this.tensorMap.has(t)){const e=this.tensorMap.get(t);e.refCount--}}write(t,e,s){if(s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:s,shape:e,values:t,refCount:1}),i}move(t,e,s,i,o){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(t,{dtype:i,shape:s,values:e,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(t=>{this.releaseResource(t),this.tensorMap.delete(t)}),this.uniformPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t)),this.stagingPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let t;try{t=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map((e,s)=>{this.pipelineCache[e]=t[s]})}async getBufferData(t){if(Qe().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const e=t.size,s=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,s,0,e),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),Qe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(le(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(t,e){const s=this.tensorMap.get(t);return s.values=e,s.values}readSync(t){const e=this.tensorMap.get(t),{values:s,complexTensorInfos:i}=e;if(s!=null||e.dtype==="string")return s;if(e.dtype==="complex64"){const I=this.readSync(i.real.dataId),k=this.readSync(i.imag.dataId),P=gl(bp(I,k).buffer,"float32");return this.convertAndCacheOnCPU(t,P),P}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],u=e.resource,l=u.size;le(l%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const p=l/4,d=new ArrayBuffer(l),f=256,m=256,w=o.map(I=>new OffscreenCanvas(f,m)),x=new OffscreenCanvas(f,m);this.endComputePassEncoder(),w.map((I,k)=>{const P=I.getContext("webgpu");return P.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[k]}),P.getCurrentTexture()}).map((I,k)=>{const P=f*4,O=(Y,K,J)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:u,bytesPerRow:P,offset:J},{texture:I},{width:Y,height:K}),this.submitQueue();const ne=x.getContext("2d",{willReadFrequently:!0});ne.clearRect(0,0,Y,K),ne.drawImage(w[k],0,0);const me=ne.getImageData(0,0,Y,K).data,ce=o[k],ye=new Uint8ClampedArray(d,J,Y*K*4);for(let Ne=0;Ne<ye.length;Ne+=4)if(ce==="premultiplied")ye[Ne+3]=me[Ne+3];else{const Ae=me[Ne];ye[Ne]=me[Ne+2],ye[Ne+1]=me[Ne+1],ye[Ne+2]=Ae}},z=Math.floor(p/(f*m));let F=f,V=m,G=0;for(let Y=0;Y<z;Y++)O(F,V,G),G+=f*m*4;const M=p%(f*m);V=Math.floor(M/f),V>0&&(O(F,V,G),G+=V*(f*4)),F=M%f,F>0&&O(F,1,G)});const C=gl(d,e.dtype);return this.convertAndCacheOnCPU(t,C),C}async read(t){if(!this.tensorMap.has(t))throw new Error(`Tensor ${t} was not registered!`);const e=this.tensorMap.get(t),{values:s}=e;if(s!=null)return s;let i;if(e.dtype==="complex64"){const o=await Promise.all([this.read(e.complexTensorInfos.real.dataId),this.read(e.complexTensorInfos.imag.dataId)]),u=o[0],l=o[1];i=bp(u,l)}else{const o=await this.getBufferData(e.resource);i=gl(o,e.dtype)}return this.convertAndCacheOnCPU(t,i),i}copyBuffer(t){const e=t.size,s=t.usage,i=this.bufferManager.acquireBuffer(e,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,i,0,e),this.submitQueue(),i}createTensorFromGPUData(t,e,s){let i=t.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:s,shape:e,values:null,refCount:1,external:t.zeroCopy});const u=this.tensorMap.get(o),l=Vp(u.dtype)*Ce(u.shape);if(t.buffer.size<l)throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${l})!`);if((t.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return t.zeroCopy!==!0&&(i=this.copyBuffer(i)),u.resource=i,ai().makeTensorFromDataId(o,e,s,this)}readToGPU(t){const e=this.tensorMap.get(t),{values:s,dtype:i,shape:o,resource:u}=e;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=u,p=l.size,d=l.usage,f=this.bufferManager.acquireBuffer(p,d);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(u,0,f,0,p),this.submitQueue();const m=this.makeTensorInfo(o,i),w=ai().makeTensorFromTensorInfo(m),x=this.tensorMap.get(m.dataId);return x.resource=f,{tensorRef:w,buffer:f}}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>cc(i));return Pn(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Pn(t.shape,t.dtype,e)}async time(t){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const e=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const o=xp(this.activeTimers.map(d=>d.query)).filter(d=>d!=null),u=xp(this.activeTimers.map(d=>d.name)).filter(d=>d!=null);this.activeTimers=e,i&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},p=await Promise.all(o);return l.kernelMs=A2(p),l.getExtraProfileInfo=()=>p.map((d,f)=>({name:u[f],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,l}makeTensorInfo(t,e,s){return e==="string"&&s!=null&&s.length>0&&P2(s[0])&&(s=s.map(o=>$2(o))),{dataId:this.write(s,t,e),shape:t,dtype:e}}tensorToBinding(t){if(!t)return null;const s=this.tensorMap.get(t.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(t){const e=this.tensorMap.get(t);if(e.resource!=null)return;const s=Vp(e.dtype)*Ce(e.shape);let i;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(e.values){if(i=this.bufferManager.acquireBuffer(s,o,!0),i.mapState==="unmapped"){const u=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),l=u.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(l).set(e.values):new Float32Array(l).set(e.values),u.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(u,0,i,0,s),this.stagingPendingDisposal.push(u)}else{const u=i.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(u).set(e.values):new Float32Array(u).set(e.values),i.unmap()}e.values=null}else i=this.bufferManager.acquireBuffer(s,o);e.resource=i}makeUniforms(t){let e=0,s=0;const i=[];let o=1;t.forEach(p=>{p.data.length===0&&(p.data=[1]);let d;switch(p.data.length){case 1:d=4;break;case 2:d=8;break;case 3:d=16;break;case 4:d=16;break;case 5:d=16;break;case 6:d=16;break;default:le(!1,()=>`Unsupported ${p.data.length}D shape`)}(s===5||s===6)&&(d=16),d>o&&(o=d),e=Math.ceil(e/d)*d,s=p.data.length,i.push(e),e+=p.data.length*4}),e=Math.ceil(e/o)*o;const u=new ArrayBuffer(e);t.forEach((p,d)=>{const f=i[d];p.type==="int32"?new Int32Array(u,f,p.data.length).set(p.data):p.type==="uint32"?new Uint32Array(u,f,p.data.length).set(p.data):new Float32Array(u,f,p.data.length).set(p.data)});const l=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(l,0,u,0,e),this.uniformPendingDisposal.push(l),{offset:0,size:e,buffer:l}}runWebGPUProgram(t,e,s,i,o){if(o||(o=this.makeTensorInfo(t.outputShape,s)),Ce(o.shape)===0)return this.tensorMap.get(o.dataId).values=sc(o.dtype,0),o;this.uploadToGPU(o.dataId),t.dispatch=G_(this.device,t);const u=e.map((p,d)=>{if(p.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(p.dataId),{dtype:this.tensorMap.get(p.dataId).dtype,shape:p.shape,name:t.variableNames[d]}});t.shaderKey=D_(t,u,o);const l=Qe().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return t.shaderKey in this.pipelineCache||(this.pipelineCache[t.shaderKey]=P_(this.device,t,u,o,l)),t.pipeline=this.pipelineCache[t.shaderKey],l||this.recordAndSubmit(t,o,e,i),o}recordAndSubmit(t,e,s,i){if(t.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],u=[];const l="int32";if(t.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),u=s.concat(e).map(x=>x.shape);const w="int32";u.map(x=>{o.push({type:w,data:x});const C=da(x);o.push({type:w,data:C})})}else{const w=da(e.shape);o.push({type:l,data:w})}if(t.size){const w=Ce(t.outputShape);o.push({type:l,data:[t.outputComponent?w/t.outputComponent:w]})}i&&(o=[...o,...i]);const p=[this.tensorToBinding(e),...s.map(w=>this.tensorToBinding(w)),this.makeUniforms(o)];s.forEach(w=>{this.commandQueueOwnedIds.add(w.dataId)}),this.commandQueueOwnedIds.add(e.dataId);const d=this.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:p.map((w,x)=>({binding:x,resource:w}))}),f=this.activeTimers!=null;this.ensureCommandEncoderReady();const m={};f&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),m.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(m)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(m)),this.computePassEncoder.setPipeline(t.pipeline),this.computePassEncoder.setBindGroup(0,d),this.computePassEncoder.dispatchWorkgroups(t.dispatch[0],t.dispatch[1],t.dispatch[2]),this.dispatchCountInPass++,(f||Qe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||t.pixelsOpType===ci.DRAW)&&(this.endComputePassEncoder(),f?this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const t=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.querySetCount*8),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(t.getMappedRange()),s=Number(e[1]-e[0])/1e6;return t.unmap(),this.bufferManager.releaseBuffer(t),s}shouldExecuteOnCPU(t,e=H_){return Qe().getBool("WEBGPU_CPU_FORWARD")&&t.every(s=>this.tensorMap.get(s.dataId).resource==null&&Ce(s.shape)<e)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}pi.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */vf()&&E2("webgpu",async()=>{const r={powerPreference:Qe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(r),e={},s=[];t.features.has("timestamp-query")&&s.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),e.requiredFeatures=s;const i=t.limits;e.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const o=await t.requestDevice(e),u="info"in t?t.info:"requestAdapterInfo"in t?await t.requestAdapterInfo():void 0;return new pi(o,u)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Se;(function(r){r[r.ADD=0]="ADD",r[r.ATAN2=1]="ATAN2",r[r.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",r[r.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",r[r.DIV=4]="DIV",r[r.ELU_DER=5]="ELU_DER",r[r.EQUAL=6]="EQUAL",r[r.FLOOR_DIV=7]="FLOOR_DIV",r[r.GREATER=8]="GREATER",r[r.GREATER_EQUAL=9]="GREATER_EQUAL",r[r.LESS=10]="LESS",r[r.LESS_EQUAL=11]="LESS_EQUAL",r[r.LOGICAL_AND=12]="LOGICAL_AND",r[r.LOGICAL_OR=13]="LOGICAL_OR",r[r.MAX=14]="MAX",r[r.MIN=15]="MIN",r[r.MOD=16]="MOD",r[r.MUL=17]="MUL",r[r.NOT_EQUAL=18]="NOT_EQUAL",r[r.POW=19]="POW",r[r.PRELU=20]="PRELU",r[r.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",r[r.SUB=22]="SUB"})(Se||(Se={}));const j_="let resultTemp = a + b;",K_="let resultTemp = atan2(a, b);",q_="let resultTemp = areal * breal - aimag * bimag;",X_="let resultTemp = areal * bimag + aimag * breal;",Y_="let resultTemp = a / b;",Q_="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Z_=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,J_=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,eT=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,tT=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,rT=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,nT=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,sT="return f32(a >= 1.0 && b >= 1.0);",iT=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,aT="return f32(a >= 1.0 || b >= 1.0);",oT=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,uT="let resultTemp = max(a, b);",lT="let resultTemp = min(a, b);",cT=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,hT=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,pT="let resultTemp = a * b;",dT=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,fT=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,mT=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,gT=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,yT="if (a < 0.0) { return b * a; }  return a;",wT=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,vT="let resultTemp = (a - b) * (a - b);",bT="let resultTemp = a - b;";function xc(r,t){let e;do{switch(r){case Se.ATAN2:e=K_;break;case Se.MAX:e=uT;break;case Se.MIN:e=lT;break;case Se.MOD:e=t?hT:cT;break;case Se.NOT_EQUAL:e=t?fT:dT;break;case Se.POW:e=t?gT:mT;break;default:continue}let s,i,o;return t?(s="isnanVec4",i="vec4<f32>",o="vec4<bool>"):(s="isnan",i="f32",o="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${e}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(r){case Se.ADD:e=j_;break;case Se.COMPLEX_MULTIPLY_IMAG:e=X_;break;case Se.COMPLEX_MULTIPLY_REAL:e=q_;break;case Se.DIV:e=Y_;break;case Se.ELU_DER:e=Q_;break;case Se.EQUAL:e=Z_;break;case Se.FLOOR_DIV:e=J_;break;case Se.GREATER:e=eT;break;case Se.GREATER_EQUAL:e=tT;break;case Se.LESS:e=rT;break;case Se.LESS_EQUAL:e=nT;break;case Se.LOGICAL_AND:return t?iT:sT;case Se.LOGICAL_OR:return t?oT:aT;case Se.MUL:e=pT;break;case Se.PRELU:return t?wT:yT;case Se.SQUARED_DIFFERENCE:e=vT;break;case Se.SUB:e=bT;break}return`
    ${e}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ee;(function(r){r[r.ABS=0]="ABS",r[r.ACOS=1]="ACOS",r[r.ACOSH=2]="ACOSH",r[r.ASIN=3]="ASIN",r[r.ASINH=4]="ASINH",r[r.ATAN=5]="ATAN",r[r.ATANH=6]="ATANH",r[r.CEIL=7]="CEIL",r[r.COS=8]="COS",r[r.COSH=9]="COSH",r[r.ELU=10]="ELU",r[r.ERF=11]="ERF",r[r.EXP=12]="EXP",r[r.EXPM1=13]="EXPM1",r[r.FLOOR=14]="FLOOR",r[r.IS_FINITE=15]="IS_FINITE",r[r.IS_INF=16]="IS_INF",r[r.IS_NAN=17]="IS_NAN",r[r.LINEAR=18]="LINEAR",r[r.LOG=19]="LOG",r[r.LOG1P=20]="LOG1P",r[r.LOGICAL_NOT=21]="LOGICAL_NOT",r[r.NEG=22]="NEG",r[r.RELU=23]="RELU",r[r.RELU6=24]="RELU6",r[r.LEAKYRELU=25]="LEAKYRELU",r[r.RECIPROCAL=26]="RECIPROCAL",r[r.ROUND=27]="ROUND",r[r.RSQRT=28]="RSQRT",r[r.SELU=29]="SELU",r[r.SIGMOID=30]="SIGMOID",r[r.SIGN=31]="SIGN",r[r.SIN=32]="SIN",r[r.SINH=33]="SINH",r[r.SOFTPLUS=34]="SOFTPLUS",r[r.SQRT=35]="SQRT",r[r.SQUARE=36]="SQUARE",r[r.STEP=37]="STEP",r[r.TAN=38]="TAN",r[r.TANH=39]="TANH",r[r.TO_INT=40]="TO_INT"})(ee||(ee={}));const xT="return abs(a);",ST=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,CT=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,NT=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,IT="return asinh(a);",kT=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,_T=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,TT="return ceil(a);",RT="return cos(a);",AT=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,PT="return exp(a) - 1.0;",$T="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",ET=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,DT=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${F2};
  let a1 = ${L2};
  let a2 = ${z2};
  let a3 = ${B2};
  let a4 = ${W2};
  let a5 = ${V2};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,OT="return exp(a);",FT="return floor(a);",LT="return f32(!isnan(a) && !isinf(a));",zT="return f32(isinf(a));",BT="return f32(isnan(a));",WT="return a;",VT=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,UT=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,MT="return f32(!(a >= 1.0));",HT="return -a;",GT="if (a < 0.0) { return uniforms.alpha * a; } return a;",jT=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,KT="return 1.0 / a;",qT="return select(a, 0.0, a < 0.0);",XT="return clamp(a, 0.0, 6.0);",YT="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",QT=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,ZT="return round(a);",JT="return inverseSqrt(a);",eR=`
  if (a >= 0.0) {
    return ${D2} * a;
  } else {
    return ${O2} * (exp(a) - 1.0);
  }
`,tR="return 1.0 / (1.0 + exp(-1.0 * a));",rR="return sign(a);",nR="return sin(a);",sR=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,iR=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,aR="return sqrt(a);",oR="return a * a;",uR=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,lR="return tan(a);",cR=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,hR="return f32(i32((a)));";function ss(r,t){switch(r){case ee.ABS:return xT;case ee.ACOS:return ST;case ee.ACOSH:return CT;case ee.ASIN:return NT;case ee.ASINH:return IT;case ee.ATAN:return kT;case ee.ATANH:return _T;case ee.COS:return RT;case ee.COSH:return AT;case ee.CEIL:return TT;case ee.ELU:return t?ET:$T;case ee.ERF:return DT;case ee.EXP:return OT;case ee.EXPM1:return PT;case ee.FLOOR:return FT;case ee.IS_FINITE:return LT;case ee.IS_INF:return zT;case ee.IS_NAN:return BT;case ee.LINEAR:return WT;case ee.LOG:return VT;case ee.LOG1P:return UT;case ee.LOGICAL_NOT:return MT;case ee.NEG:return HT;case ee.LEAKYRELU:return t?jT:GT;case ee.RECIPROCAL:return KT;case ee.RELU:return t?QT:qT;case ee.RELU6:return t?YT:XT;case ee.ROUND:return ZT;case ee.RSQRT:return JT;case ee.SELU:return eR;case ee.SIGMOID:return tR;case ee.SIGN:return rR;case ee.SIN:return nR;case ee.SINH:return sR;case ee.SOFTPLUS:return iR;case ee.SQRT:return aR;case ee.SQUARE:return oR;case ee.STEP:return uR;case ee.TAN:return lR;case ee.TANH:return cR;case ee.TO_INT:return hR;default:throw new Error(`BinaryType ${r} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(r,t=!1,e=!1,s=3){if(r===null)return"";let i="";if(r==="linear")i=ss(ee.LINEAR);else if(r==="relu")i=ss(ee.RELU,e);else if(r==="elu")i=ss(ee.ELU,e);else if(r==="relu6")i=ss(ee.RELU6,e);else if(r==="prelu")i=xc(Se.PRELU,e);else if(r==="sigmoid")i=ss(ee.SIGMOID,e);else if(r==="leakyrelu")i=ss(ee.LEAKYRELU,e);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);const u=Te(e?4:1);let l="";return t?l=`
      fn activation(a : ${u}, coords : vec${s}<i32>) -> ${u} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:l=`
      fn activation(a : ${u}, coords : vec${s}<i32>) -> ${u} {
        ${i}
      }`,l}function ws(r,t){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xf(r,t,e=!1,s=!1,i=!1,o=1){le(r&&o===1||!r,()=>`transposeA ${r} is not compatible with component size ${o}`);const u=`
      ${r?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,l=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Te(o)} {
    var value = ${Te(o)}(0.0);
    ${e&&i?u:`
    ${r?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${u}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Te(o)} {
    var value = ${Te(o)}(0.0);
    ${l}
    return value;
  }
  `}function Sc(r,t,e,s,i=!1,o=!1,u=!1,l=1){return`
  ${xf(e,s,i,o,u,l)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Te(l)}) {
    ${i&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${ws(r,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const pR=(r,t)=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,dR=(r,t,e,s)=>{if(r)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${e}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",o="";for(let u=0;u<t;u++)i+=`let BCached${u} = mm_Bsub[k * ${t} + ${u}][tileCol];`,o+=`acc[i] = fma(BCached${u}, vec4<f32>(ACached[${u}]), acc[i]);`;return`
      for (var k = 0; k < ${s/t}; k++) {
        ${i}
        for (var i = 0; i < ${e}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function Zo(r,t,e=!1,s=32,i=!1,o=32,u=!1){const l=t[1]*r[1],p=t[0]*r[0],d=e?l:s,f=e?s:l,m=d/t[0],w=s/t[1],x=r[1],C=r[0];return le((e&&m===4&&r[1]===4||!e&&(m===3||m===4))&&d%t[0]===0&&s%t[1]===0&&r[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${m} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${m} must be 3 or 4.
      tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${m}<f32>, ${d/m}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${p/r[0]}>, ${s}>;

  ${te()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${x};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${x};
    let globalCol = i32(globalId.x) * ${C};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!u?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!u?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${l};

    let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${x}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${w};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${pR(e,m)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${w}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${dR(e,m,x,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const Up=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,fR=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Jo(r,t,e=!1,s=32,i=!1,o=32,u=!1,l=!1){const p=r[1]*t[1],d=r[0]*t[0],f=e?p:s,m=e?s:p;le(m%t[1]===0&&f%t[0]===0&&s%t[1]===0,()=>`tileAHight ${m} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);const w=m/t[1],x=f/t[0],C=s/t[1],I=r[1],k=r[0],P=u?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${p};
      let globalColStart = i32(workgroupId.x) * ${d};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {
            ${Up(e)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${k}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${k}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${I}; innerRow++) {
            let ACached = ${e?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${k}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${I}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${k}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${I};
  let tileCol = i32(localId.x) * ${k};

  let globalRow = i32(globalId.y) * ${I};
  let globalCol = i32(globalId.x) * ${k};
  let globalRowStart = i32(workgroupId.y) * ${p};

  let tileRowA = i32(localId.y) * ${w};
  let tileColA = i32(localId.x) * ${x};
  let tileRowB = i32(localId.y) * ${C};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${w}; innerRow++) {
      for (var innerCol = 0; innerCol < ${x}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Up(e)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${C}; innerRow++) {
      for (var innerCol = 0; innerCol < ${k}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${k}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${k}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${I}; innerRow++) {
        ${fR(e)}
        for (var innerCol = 0; innerCol < ${k}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${I}; innerRow++) {
    for (var innerCol = 0; innerCol < ${k}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${f}>, ${m}>;
    var<workgroup> mm_Bsub : array<array<f32, ${d}>, ${s}>;

    ${te()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!l?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!l?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${k}>, ${I}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${I}; innerRow++) {
        for (var innerCol = 0; innerCol < ${k}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${P}
    }
  `}const mR=r=>r?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function gR(r,t=!1){le(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`);const e=r[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${te()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${e} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${e} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${mR(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${e/4}; k++) {
          let rowB = t * ${e} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class yR{constructor(t,e,s=!1,i=!1,o=null,u=null,l=null,p=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};const d=s?t[1]:t[2];if(this.isVec4=(d%4===0&&!s||e[1]%4===0&&s)&&e[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=e[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const w=M_(e[1],d,e[2],s);this.workgroupSize=w.workgroupSize,this.elementsPerThread=w.elementsPerThread}this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const f=o!=null,m=l!=null;f&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=p,this.transposeA=s,this.transposeB=i,this.addBias=f,this.activation=u,this.hasPreluActivationWeights=m,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],d),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,s){const i=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const u=t%i===0,l=e%o===0,p=s%this.tileInner===0;return[u,l,p]}getUserCode(){return`
      ${cn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Sc(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Zo(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?gR(this.workgroupSize,this.transposeA):Jo(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(r){return`
    var<workgroup> sumValues : array<f32, ${r}>;
    ${te()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${r}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${r/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class vR{constructor(t,e=!1,s=!1,i=null,o=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize);const l=i!=null,p=u!=null;l&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=s,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=p,this.shaderKey=`matMulReduce_${this.activation}_${e}_${s}`}getUserCode(){return`
      ${cn(this.activation,this.hasPreluActivationWeights)}
      ${Sc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${wR(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(r){const t=r[1],e=r[0],s=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${te()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class xR{constructor(t,e,s,i=!1,o=!1,u=null,l=null,p=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const d=u!=null;d&&this.variableNames.push("bias");const f=p!=null;f&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=o,this.addBias=d,this.activation=l,this.hasPreluActivationWeights=f,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${o}`}getUserCode(){return`
      ${cn(this.activation,this.hasPreluActivationWeights)}
      ${Sc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${bR(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SR{constructor(t,e,s=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,le(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(s&&this.outputShape[1]%4===0||!s&&e%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=re(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=i,this.shaderKey=`matMulSplitK_${s}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const t=this.outputComponent;return`
      ${xf(!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Te(t)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${t}; i = i + 1) {
            ${$n("&result[flatIndex + i]",`${t>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${t===4?Zo(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Jo(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class CR{constructor(t,e=null,s=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=i!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${cn(this.activation,this.hasPreluActivationWeights)}
    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${ws(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NR{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(r){const{backend:t,attrs:e}=r,{shape:s,value:i}=e;let{dtype:o}=e;if(o=o||M2(i),o==="string"){const u=H2(o,Ce(s));return u.fill(i),t.makeTensorInfo(s,o,u)}else{const u=new NR(s),l=[{type:"float32",data:[i]}];return t.runWebGPUProgram(u,[],o,l)}}const IR={kernelName:U2,backendName:"webgpu",kernelFunc:Vt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(r){const{inputs:t,attrs:e}=r,{x:s}=t,{shape:i}=e,o=Ce(s.shape),u=j2(i,o),l=Ce(u);return le(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}}const kR={kernelName:G2,backendName:"webgpu",kernelFunc:pe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu({a:r,b:t,transposeA:e,transposeB:s,backend:i,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:l=0,activation:p=null}){const d=r.shape.length,f=t.shape.length,m=e?r.shape[d-2]:r.shape[d-1],w=s?t.shape[f-1]:t.shape[f-2],x=e?r.shape[d-1]:r.shape[d-2],C=s?t.shape[f-2]:t.shape[f-1],I=r.shape.slice(0,-2),k=t.shape.slice(0,-2),P=Ce(I),O=Ce(k),F=an(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([x,C]);le(m===w,()=>`Error in matMul: inner shapes (${m}) and (${w}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const V=e?[P,m,x]:[P,x,m],G=s?[O,C,w]:[O,w,C],M=pe({inputs:{x:r},backend:i,attrs:{shape:V}}),Y=pe({inputs:{x:t},backend:i,attrs:{shape:G}}),K=[M,Y],J=Math.max(P,O),ne=[M,Y],me=[{type:"int32",data:[x]},{type:"int32",data:[C]},{type:"int32",data:[m]}];let ce,ye;const Ne=[J,x,C];let Ae=Qe().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(Ae<0){const nt=Qe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),pt=nt>0?nt:i.thresholdToIncreaseWorkgroups,Ot=J*Math.ceil(x/32)*Math.ceil(C/32);Ot<=pt||x<=8&&Ot<=pt*2?J*x*C<=128?Ae=$r.MatMulReduceProgram:J===1&&w>=2e3?Ae=$r.MatMulSplitKProgram:Ae=$r.MatMulSmallOutputSizeProgram:Ae=$r.MatMulPackedProgram}switch(Ae){case $r.MatMulReduceProgram:ce=new vR(Ne,e,s,o,p,u);break;case $r.MatMulSplitKProgram:{if(ye=Vt({backend:i,attrs:{shape:Ne,value:0,dtype:r.dtype}}),ce=new SR(Ne,w,e,s),o||p){ye=i.runWebGPUProgram(ce,ne,r.dtype,me,ye);const pt=new CR(ye.shape,o,p,u);let Ot=null;const ut=[ye];o&&ut.push(o),u&&ut.push(u),p==="leakyrelu"&&(Ot=[{type:"float32",data:[l]}],pt.uniforms+=" alpha : f32,");const En=i.runWebGPUProgram(pt,ut,ye.dtype,Ot);K.push(ye);const Dn=pe({inputs:{x:En},backend:i,attrs:{shape:F}});K.push(En);for(const xs of K)i.disposeData(xs.dataId);return Dn}break}case $r.MatMulSmallOutputSizeProgram:ce=new xR(V,G,Ne,e,s,o,p,u);break;case $r.MatMulPackedProgram:const nt=i.adapterInfo.isIntel();ce=new yR(V,Ne,e,s,o,p,u,nt);break;default:throw new Error(`Unsupported MatMulProgramType ${Ae}.`)}o&&ne.push(o),u&&ne.push(u),p==="leakyrelu"&&(me.push({type:"float32",data:[l]}),ce.uniforms+=" alpha : f32,"),ye=i.runWebGPUProgram(ce,ne,r.dtype,me,ye);const rt=pe({inputs:{x:ye},backend:i,attrs:{shape:F}});K.push(ye);for(const nt of K)i.disposeData(nt.dataId);return rt}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(r){const{inputs:t,backend:e,attrs:s}=r,{a:i,b:o,bias:u,preluActivationWeights:l}=t,{transposeA:p,transposeB:d,activation:f,leakyreluAlpha:m}=s;return eu({a:i,b:o,transposeA:p,transposeB:d,backend:e,bias:u,preluActivationWeights:l,leakyreluAlpha:m,activation:f})}const TR={kernelName:K2,backendName:"webgpu",kernelFunc:_R};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mp{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=an(e,s),this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${xc(this.op,!1)}
      }

      ${te("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Go{constructor(t,e,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=an(e,s),this.dispatchLayout=ae(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&s.length>1&&e[0]<128,this.useSharedMemoryWithB=s.length<=1&&e.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=e.length>0&&e[e.length-1]%4===0,o=s.length>0&&s[s.length-1]%4===0;i&&o?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(Sp(s)||s[s.length-1]===1)||o&&(Sp(e)||e[e.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t;const e=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${xc(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;t=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${te("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${s}
       ${te("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${e}(getAByOutputCoords(coords));
           let b = ${e}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(r){const{inputs:t}=r,{x:e}=t;return r.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}const RR={kernelName:q2,backendName:"webgpu",kernelFunc:Qt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vs(r){const{inputs:t,backend:e}=r,{real:s,imag:i}=t,o=e.makeTensorInfo(s.shape,"complex64"),u=e.tensorMap.get(o.dataId),l=Qt({inputs:{x:s},backend:e}),p=Qt({inputs:{x:i},backend:e});return u.complexTensorInfos={real:l,imag:p},o}const AR={kernelName:X2,backendName:"webgpu",kernelFunc:vs};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class di{constructor(t,e,s=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${ss(this.op,!1)}
      }
      ${te("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze({opType:r,cpuKernelImpl:t,dtype:e}){return({inputs:s,backend:i})=>{const{x:o}=s,u=i,l=e||o.dtype;if(u.shouldExecuteOnCPU([o])&&t!=null){const d=u.tensorMap.get(o.dataId),f=t(d.values,l);return u.makeTensorInfo(o.shape,l,f)}const p=new di(o.shape,r);return u.runWebGPUProgram(p,[o],l)}}function St({opType:r,cpuKernelImpl:t,supportsComplex:e=!1,dtype:s}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,p=o;if(e&&u.dtype==="complex64"){const m=p.tensorMap.get(u.dataId),w=p.tensorMap.get(l.dataId);let x,C;if(r!==Se.MUL)[x,C]=[[m.complexTensorInfos.real,w.complexTensorInfos.real],[m.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(k=>{const[P,O]=k,z={dataId:P.dataId,dtype:P.dtype,shape:u.shape},F={dataId:O.dataId,dtype:O.dtype,shape:l.shape},V=new Go(r,u.shape,l.shape);return p.runWebGPUProgram(V,[z,F],fa(P.dtype,O.dtype))});else{const k=new Mp(Se.COMPLEX_MULTIPLY_REAL,u.shape,l.shape),P=new Mp(Se.COMPLEX_MULTIPLY_IMAG,u.shape,l.shape),O=[{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:u.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:u.shape},{dataId:w.complexTensorInfos.real.dataId,dtype:w.complexTensorInfos.real.dtype,shape:l.shape},{dataId:w.complexTensorInfos.imag.dataId,dtype:w.complexTensorInfos.imag.dtype,shape:l.shape}];x=p.runWebGPUProgram(k,O,"float32"),C=p.runWebGPUProgram(P,O,"float32")}const I=vs({inputs:{real:x,imag:C},backend:p});return p.disposeData(x.dataId),p.disposeData(C.dataId),I}const d=s||fa(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||p.shouldExecuteOnCPU([u,l]))&&t!=null){const m=p.tensorMap.get(u.dataId).values,w=p.tensorMap.get(l.dataId).values,x=u.dtype==="string"?Cp(m):m,C=u.dtype==="string"?Cp(w):w,[I,k]=t(u.shape,l.shape,x,C,d);return p.makeTensorInfo(k,d,I)}const f=new Go(r,u.shape,l.shape);return p.runWebGPUProgram(f,[u,l],d)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:PR,castImpl:$R,ceilImpl:ER,concatImpl:DR,equalImpl:OR,expImpl:FR,expm1Impl:LR,floorImpl:zR,floorDivImpl:BR,gatherNdImpl:WR,gatherV2Impl:VR,greaterEqualImpl:UR,greaterImpl:MR,lessEqualImpl:HR,lessImpl:GR,logImpl:jR,maxImpl:KR,maximumImpl:qR,minimumImpl:XR,multiplyImpl:YR,negImpl:QR,notEqualImpl:ZR,prodImpl:JR,rangeImpl:eA,rsqrtImpl:tA,scatterImpl:rA,simpleAbsImpl:nA,sliceImpl:sA,stridedSliceImpl:iA,stringNGramsImpl:aA,subImpl:oA,tileImpl:uA,topKImpl:lA,transposeImpl:cA}=Y2;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hA=ze({opType:ee.ABS,cpuKernelImpl:nA}),pA={kernelName:Q2,backendName:"webgpu",kernelFunc:hA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dA=ze({opType:ee.ACOS}),fA={kernelName:Z2,backendName:"webgpu",kernelFunc:dA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mA=ze({opType:ee.ACOSH}),gA={kernelName:J2,backendName:"webgpu",kernelFunc:mA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yA=St({opType:Se.ADD,cpuKernelImpl:PR,supportsComplex:!0}),wA={kernelName:eS,backendName:"webgpu",kernelFunc:yA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vA{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const t=[];this.variableNames.forEach(i=>{t.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const e=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${te("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(r){const{inputs:t,backend:e}=r,s=t;if(s.length===1)return Qt({inputs:{x:s[0]},backend:e});const i=s.map(l=>l.dtype).reduce((l,p)=>fa(l,p)),o=s.map(l=>l.shape),u=new vA(o);return e.runWebGPUProgram(u,s,i)}const xA={kernelName:_d,backendName:"webgpu",kernelFunc:bA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SA{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){le(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const t=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${te()} {
        var x = i32(workgroupId.x) * ${t} + i32(localId.x);
        var y = i32(workgroupId.y) * ${t} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${t} + i32(localId.x);
        y = i32(workgroupId.x) * ${t} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CA{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){const t=ht(this.outputShape.length),e=Sf(this.newDim);return`
      ${te("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}}function Sf(r){const t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=new Array(t);for(let s=0;s<r.length;s++)e[r[s]]=`coords.${un(s)}`;return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fr(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{perm:o}=s,u=e,l=i.shape.length,p=new Array(l);for(let f=0;f<p.length;f++)p[f]=i.shape[o[f]];if(e.shouldExecuteOnCPU([i])){const m=u.tensorMap.get(i.dataId).values,w=cA(m,i.shape,i.dtype,o,p);return e.makeTensorInfo(p,i.dtype,w)}if(i.shape.length===2&&Cr(o,[1,0])){const f=new SA(i.shape,o);return u.runWebGPUProgram(f,[i],i.dtype)}const d=new CA(i.shape,o);return u.runWebGPUProgram(d,[i],i.dtype)}const NA={kernelName:tS,backendName:"webgpu",kernelFunc:Fr};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IA{constructor(t,e,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];const[i]=hc(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,t.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(t=" bestValue = bestValue * candidate; ",e="1.0"):this.reduceType==="all"?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):this.reduceType==="any"&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${te("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kA={mean:"float32",all:"bool",any:"bool"};function bs(r,t,e,s,i){const o=r.shape.length,u=[],l=ys(t,r.shape);let p=l;const d=Sa(p,o);let f=r;d!=null&&(f=Fr({inputs:{x:r},attrs:{perm:d},backend:i}),p=Ca(p.length,o),u.push(f)),pc(s,p,o);const[m,w]=hc(f.shape,p);let x=m;e&&(x=rS(m,l));let C;if((s==="max"||s==="prod")&&i.shouldExecuteOnCPU([f])){const I=i.tensorMap.get(f.dataId).values;switch(s){case"max":const k=KR(I,Ce(w),x,r.dtype);C=i.makeTensorInfo(x,r.dtype,k);break;case"prod":const{outVals:P,outShape:O,outDtype:z}=JR(f.shape,f.dtype,I,p);C=i.makeTensorInfo(O,z,P);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const I=Ce(w),P=Ce(f.shape)/I,O={windowSize:I,inSize:I,batchSize:P,outSize:1},z=kA[s]||nS(r.dtype),F=[{type:"int32",data:[I]}],V=new IA(O,s,i.device.limits.maxComputeWorkgroupSizeX),G=i.runWebGPUProgram(V,[f],z,F);u.push(G),C=pe({inputs:{x:G},attrs:{shape:x},backend:i})}return u.forEach(I=>i.disposeData(I.dataId)),C}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{keepDims:o,axis:u}=s;return bs(i,u,o,"all",e)}const TA={kernelName:sS,backendName:"webgpu",kernelFunc:_A};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{keepDims:o,axis:u}=s;return bs(i,u,o,"any",e)}const AA={kernelName:iS,backendName:"webgpu",kernelFunc:RA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cf{constructor(t,e,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[e];this.op=s==="min"?"<":">";const[o,u]=hc(t,i);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=ae(this.outputShape),Ce(u)<32?(this.type="plain",this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=re(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const t=this.workgroupSize[0],e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${un(this.inputShape.length-1)}`,s=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)i+=`outputCoords.${un(o)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${t}>;
      var<workgroup> xBestValues : array<f32, ${t}>;
    `}

      ${te("index")} {
        let outputIndex = index / ${t};
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${t}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${t}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${te("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o}=s;let u=ys(o,i.shape);const l=Sa(u,i.shape.length);let p=i;const d=[];l!=null&&(p=Fr({inputs:{x:i},backend:e,attrs:{perm:l}}),d.push(p),u=Ca(u.length,p.shape.length)),pc("argMax",[u[0]],p.shape.length);const f=new Cf(p.shape,u[0],"max"),m=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],w=e.runWebGPUProgram(f,[p],"int32",m);return d.forEach(x=>e.disposeData(x.dataId)),w}const $A={kernelName:aS,backendName:"webgpu",kernelFunc:PA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o}=s;let u=ys(o,i.shape);const l=Sa(u,i.shape.length);let p=i;const d=[];l!=null&&(p=Fr({inputs:{x:i},backend:e,attrs:{perm:l}}),d.push(p),u=Ca(u.length,p.shape.length)),pc("argMin",[u[0]],p.shape.length);const f=new Cf(p.shape,u[0],"min"),m=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],w=e.runWebGPUProgram(f,[p],"int32",m);return d.forEach(x=>e.disposeData(x.dataId)),w}const DA={kernelName:oS,backendName:"webgpu",kernelFunc:EA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OA=ze({opType:ee.ASIN}),FA={kernelName:uS,backendName:"webgpu",kernelFunc:OA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LA=ze({opType:ee.ASINH}),zA={kernelName:lS,backendName:"webgpu",kernelFunc:LA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BA=ze({opType:ee.ATAN}),WA={kernelName:cS,backendName:"webgpu",kernelFunc:BA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VA=St({opType:Se.ATAN2}),UA={kernelName:hS,backendName:"webgpu",kernelFunc:VA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MA=ze({opType:ee.ATANH}),HA={kernelName:pS,backendName:"webgpu",kernelFunc:MA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GA{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ya{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool2D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${t}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}class Cc{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool3D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue += value; count += 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${t}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nf(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{reductionIndices:o,keepDims:u}=s;return bs(i,o,u,"max",e)}const jA={kernelName:dS,backendName:"webgpu",kernelFunc:Nf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function If(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{keepDims:o,axis:u}=s;return bs(i,u,o,"mean",e)}const KA={kernelName:fS,backendName:"webgpu",kernelFunc:If};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kf(r,t,e,s){if(t.filterWidth===1&&t.filterHeight===1&&Cr(t.inShape,t.outShape))return Qt({inputs:{x:r},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){const u=r.shape.length,l=pe({inputs:{x:r},backend:s,attrs:{shape:[r.shape[u-3]*r.shape[u-2],r.shape[u-1]]}});let p;e==="avg"?p=If({inputs:{x:l},backend:s,attrs:{axis:0,keepDims:!1}}):(le(e==="max",()=>`Invalid pool type ${e}`),p=Nf({inputs:{x:l},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const d=pe({inputs:{x:p},backend:s,attrs:{shape:t.outShape}});return s.disposeData(l.dataId),s.disposeData(p.dataId),d}let i;const o=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?i=new GA(t):(e==="avg"?i=new ya(t,"avg"):(le(e==="max",()=>`Invalid pool type ${e}`),i=new ya(t,"max")),o.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(i,[r],r.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:p}=s,f=Na(i.shape,o,u,1,l,p);return kf(i,f,"avg",e)}const XA={kernelName:mS,backendName:"webgpu",kernelFunc:qA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{filterSize:o,strides:u,pad:l,dataFormat:p,dimRoundingMode:d}=s,f=[1,1,1],m=Qo(i.shape,o,u,f,l,d,p),w=new Cc(m,"avg"),x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.front,m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inDepth,m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]}];return e.runWebGPUProgram(w,[i],i.dtype,x)}const QA={kernelName:gS,backendName:"webgpu",kernelFunc:YA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZA{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class JA{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eP(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,input:o}=t,u=o,{filterSize:l,strides:p,pad:d,dimRoundingMode:f}=s,m=Qo(u.shape,l,p,1,d,f),w=new JA(m),x=1/(m.filterDepth*m.filterHeight*m.filterWidth),C=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.effectiveFilterDepth-1-m.padInfo.front,m.effectiveFilterHeight-1-m.padInfo.top,m.effectiveFilterWidth-1-m.padInfo.left]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]},{type:"int32",data:[m.outDepth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]},{type:"float32",data:[x]}];return e.runWebGPUProgram(w,[i],u.dtype,C)}const tP={kernelName:yS,backendName:"webgpu",kernelFunc:eP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,input:o}=t,u=o;bf([i,o],"avgPoolGrad");const{filterSize:l,strides:p,pad:d}=s,f=Na(u.shape,l,p,1,d),m=new ZA(f),w=1/(f.filterHeight*f.filterWidth),x=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[w]}];return e.runWebGPUProgram(m,[i],u.dtype,x)}const nP={kernelName:wS,backendName:"webgpu",kernelFunc:rP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sP(r){const{inputs:t,backend:e,attrs:s}=r,{a:i,b:o}=t,{transposeA:u,transposeB:l}=s;return eu({a:i,b:o,transposeA:u,transposeB:l,backend:e})}const iP={kernelName:vS,backendName:"webgpu",kernelFunc:sP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aP{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${ht(t.length)}, `,this.shaderKey="slice"}getUserCode(){const t=ht(this.rank),e=oP(this.rank);let s;return this.start.length===1?s=this.outputShape.map((o,u)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((o,u)=>`sourceLoc.${Kl[u]} = uniforms.start.${un(u)} + coords.${Kl[u]};`),`
      ${te("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}}const Kl=["x","y","z","w","u","v"];function oP(r){if(r===1)return"sourceLoc";if(r<=6)return Kl.slice(0,r).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fi(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{begin:o,size:u}=s,[l,p]=xS(i,o,u);if(SS(i,l,p),e.shouldExecuteOnCPU([i])||i.dtype==="string"){const m=e.tensorMap.get(i.dataId),w=sA(m.values,l,p,i.shape,i.dtype);return e.makeTensorInfo(p,i.dtype,w)}if(Ce(p)===0)return e.makeTensorInfo(p,i.dtype,[]);const d=new aP(l,p),f=[{type:"int32",data:l}];return e.runWebGPUProgram(d,[i],i.dtype,f)}const uP={kernelName:bS,backendName:"webgpu",kernelFunc:fi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lP=r=>{const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{blockShape:o,crops:u}=s;le(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const l=o.reduce((O,z)=>O*z),p=ef(i.shape,o,l),d=tf(p.length,o.length),f=rf(i.shape,o,l),m=NS(u,o.length),w=IS(f,u,o.length),x=[],C=pe({inputs:{x:i},backend:e,attrs:{shape:p}}),I=Fr({inputs:{x:C},backend:e,attrs:{perm:d}}),k=pe({inputs:{x:I},backend:e,attrs:{shape:f}}),P=fi({inputs:{x:k},backend:e,attrs:{begin:m,size:w}});return x.push(C),x.push(I),x.push(k),x.forEach(O=>e.disposeData(O.dataId)),P},cP={kernelName:CS,backendName:"webgpu",kernelFunc:lP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hP=`
  fn bincount_write(index: i32, value: f32) {
    ${$n("&result[index]","value","float32")}
  }
`,pP=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class _f{constructor(t,e,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?pP:hP}
  ${te("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dP(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,weights:o}=t,{size:u}=s,l=Ce(i.shape),d=Ce(o.shape)>0,f=[u],m=o.dtype,w=Vt({backend:e,attrs:{shape:f,value:0,dtype:m}}),x=new _f([l],d),C=[{type:"int32",data:[u]}],I=d?[i,o]:[i];return e.runWebGPUProgram(x,I,m,C,w)}const fP={kernelName:kS,backendName:"webgpu",kernelFunc:dP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mP{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${te("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gP(r){const{inputs:t,backend:e}=r,{s0:s,s1:i}=t;if(e.shouldExecuteOnCPU([s,i])){const f=e.tensorMap.get(s.dataId),m=e.tensorMap.get(i.dataId),w=f.values,x=m.values,C=an(Array.from(w),Array.from(x));return e.makeTensorInfo([C.length],"int32",Int32Array.from(C))}const o=Ce(s.shape),u=Ce(i.shape),l=Math.max(o,u),p=new mP(l),d=[{type:"int32",data:[o]},{type:"int32",data:[u]}];return e.runWebGPUProgram(p,[s,i],"int32",d)}const yP={kernelName:Td,backendName:"webgpu",kernelFunc:gP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tf=St({opType:Se.NOT_EQUAL,dtype:"bool",cpuKernelImpl:ZR}),wP={kernelName:_S,backendName:"webgpu",kernelFunc:Tf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(r){const{inputs:t,backend:e}=r,{input:s}=t,i=e.tensorMap.get(s.dataId);return Qt({inputs:{x:i.complexTensorInfos.real},backend:e})}const vP={kernelName:TS,backendName:"webgpu",kernelFunc:ka};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(r,t){const e=new di(r.shape,ee.TO_INT),s=t.runWebGPUProgram(e,[r],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{dtype:o}=s;if(o==="complex64"){if(i.dtype==="complex64")return Qt({inputs:{x:i},backend:e});const u=lc(i.shape),l=ql({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),p=vs({inputs:{real:l,imag:u},backend:e});return u.dispose(),e.disposeData(l.dataId),p}if(i.dtype==="complex64"){const u=ka({inputs:{input:i},backend:e}),l=ql({inputs:{x:u},backend:e,attrs:{dtype:o}});return e.disposeData(u.dataId),l}if(!AS(i.dtype,o)){const u=Qt({inputs:{x:i},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:o}}if(e.shouldExecuteOnCPU([i])){const u=e.tensorMap.get(i.dataId).values,[l,p,d]=$R(u,i.shape,i.dtype,o);return e.makeTensorInfo(l,p,d)}if(o==="int32")return bP(i,e);if(o==="bool"){const u=e.makeTensorInfo([],"bool",sc("bool",1)),p=Tf({inputs:{a:i,b:u},backend:e});return e.disposeData(u.dataId),p}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}const xP={kernelName:RS,backendName:"webgpu",kernelFunc:ql};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP=ze({opType:ee.CEIL,cpuKernelImpl:ER}),CP={kernelName:PS,backendName:"webgpu",kernelFunc:SP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NP{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${te("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IP{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${te("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{clipValueMin:o,clipValueMax:u}=s;let l;const p=[{type:"float32",data:[o]},{type:"float32",data:[u]}];return Ce(i.shape)%4===0?l=new NP(i.shape):l=new IP(i.shape),e.runWebGPUProgram(l,[i],i.dtype,p)}const _P={kernelName:$S,backendName:"webgpu",kernelFunc:kP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TP{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hp(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function RP(r){const{inputs:t,backend:e}=r,{x:s}=t,i=e.tensorMap.get(s.dataId),o=new TP(s.shape),u=[Hp(s,i.complexTensorInfos.real),Hp(s,i.complexTensorInfos.imag)];return e.runWebGPUProgram(o,u,u[0].dtype)}const AP={kernelName:ES,backendName:"webgpu",kernelFunc:RP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PP{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ma(t,1),this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)t.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const s=this.offsetLength,i=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${i})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${te("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(r){const{inputs:t,backend:e}=r,{input:s}=t,i=e.tensorMap.get(s.dataId);return Qt({inputs:{x:i.complexTensorInfos.imag},backend:e})}const $P={kernelName:DS,backendName:"webgpu",kernelFunc:tu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function la(r,t,e){const s=r[0].dtype;if(s==="complex64"){const C=r.map(z=>ka({inputs:{input:z},backend:e})),I=r.map(z=>tu({inputs:{input:z},backend:e})),k=la(C,t,e),P=la(I,t,e),O=vs({inputs:{real:k,imag:P},backend:e});return C.forEach(z=>e.disposeData(z.dataId)),I.forEach(z=>e.disposeData(z.dataId)),e.disposeData(k.dataId),e.disposeData(P.dataId),O}let i=e.shouldExecuteOnCPU(r);if(s==="string"&&(i=!0),i){const C=r.map(V=>{const M=[-1,Ce(V.shape.slice(t))];return pe({inputs:{x:V},backend:e,attrs:{shape:M}})}),I=C.map(V=>({vals:e.readSync(V.dataId),shape:V.shape})),k=ma(C.map(V=>V.shape),1),P=C[0].shape[0]===1,O=DR(I,k,s,P),z=ma(r.map(V=>V.shape),t),F=e.makeTensorInfo(z,s,O);return C.forEach(V=>e.disposeData(V.dataId)),F}const o=e.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>o){const C=[];for(let k=0;k<r.length;k+=o){const P=r.slice(k,k+o);C.push(la(P,t,e))}const I=la(C,t,e);for(const k of C)e.disposeData(k.dataId);return I}const{tensors2D:u,outShape:l}=EP(r,t,e),p=u.map(C=>C.shape),d=new PP(p),f=[],m=new Array(p.length-1);if(m.length>0){m[0]=p[0][1],f.push({type:"int32",data:[m[0]]});for(let C=1;C<m.length;C++)m[C]=m[C-1]+p[C][1],f.push({type:"int32",data:[m[C]]})}const w=e.runWebGPUProgram(d,u,u[0].dtype,f);u.forEach(C=>e.disposeData(C.dataId));const x=pe({inputs:{x:w},backend:e,attrs:{shape:l}});return e.disposeData(w.dataId),x}function EP(r,t,e){const s=ma(r.map(o=>o.shape),t);return{tensors2D:r.map(o=>pe({inputs:{x:o},backend:e,attrs:{shape:[Ce(o.shape.slice(0,t)),Ce(o.shape.slice(t))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(r){const{inputs:t,backend:e,attrs:s}=r,{axis:i}=s,o=ys(i,t[0].shape)[0],u=t.map(d=>d.shape);FS(u,o);const l=ma(t.map(d=>d.shape),o);if(Ce(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const p=t.filter(d=>Ce(d.shape)>0);return p.length===1?Qt({inputs:{x:p[0]},backend:e}):la(p,o,e)}const DP={kernelName:OS,backendName:"webgpu",kernelFunc:Rf};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(r,t,e,s,i=!1,o=null,u=!1,l=4,p=4,d=4){const f=K=>{switch(K){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${K} is not supported.`)}},m=K=>{switch(K){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${K} is not supported.`)}},w=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,x=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,C=r?"uniforms.xShape[1]":"uniforms.xShape[2]",I=r?"uniforms.xShape[2]":"uniforms.xShape[3]",k=r?"row":"col",P=r?"col":"row",O=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${k} / outWidth;
      let outCol = ${k} % outWidth;

      let WRow = ${P} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${P} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${P} % inChannels;
      var resData = ${Te(l)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${C} && xCol >= 0 && xCol < ${I}) {
        ${w}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${f(l)}
      }
      return resData;`,z=r?t&&s?`
      ${O}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${O}
      }
      return ${Te(l)}(0.0);`:s&&e?`
      ${O}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${O}
      }
      return ${Te(l)}(0.0);`,F=`${m(p)}`,V=Te(d),G=Te(r?l:p),M=Te(r?p:l);return`
      ${cn(o,u,d===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${G} {
        ${r?z:F}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${M} {
        ${r?F:z}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${V}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${x}
        ${ws(i,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class FP{constructor(t,e,s,i,o=!1,u=null,l=!1,p=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=yf(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=wf(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),l&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=p,this.addBias=o,this.activation=u,this.hasPreluActivationWeights=l,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const t=this.isVec4?Zo(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Jo(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${OP(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LP{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=s,this.hasPreluActivationWeights=i,e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${cn(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${ws(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${te("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zP{constructor(t,e){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${te("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jo(r,t){const e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function BP({x:r,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const p=e.dataFormat==="channelsLast",d=!p,f=!1,m=p&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",w=[];let x,C;if(m){const P=e.inHeight*e.inWidth*e.inChannels;x=pe({inputs:{x:r},backend:s,attrs:{shape:[1,e.batchSize,P]}}),C=pe({inputs:{x:t},backend:s,attrs:{shape:[1,P,e.outChannels]}})}else x=pe({inputs:{x:r},backend:s,attrs:{shape:p?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),C=pe({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(w.push(x),w.push(C),o!=null){const P=jo(o.shape,p);P!=null&&(o=pe({inputs:{x:o},backend:s,attrs:{shape:P}}),w.push(o))}if(i!=null){const P=jo(i.shape,p);P!=null&&(i=pe({inputs:{x:i},backend:s,attrs:{shape:P}}),w.push(i))}const I=eu({a:p?x:C,b:p?C:x,transposeA:d,transposeB:f,backend:s,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:u}),k=pe({inputs:{x:I},backend:s,attrs:{shape:e.outShape}});w.push(I);for(const P of w)s.disposeData(P.dataId);return k}function WP({x:r,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const{filterWidth:p,filterHeight:d,inChannels:f,strideWidth:m,strideHeight:w,padInfo:x,outWidth:C,outHeight:I,dilationWidth:k,dilationHeight:P,dataFormat:O}=e,z=O==="channelsLast",F=p*d*f,V=I*C,G=z?[e.batchSize,V,F]:[e.batchSize,F,V],M=new zP(G,z),Y=[{type:"int32",data:[x.top,x.left]},{type:"int32",data:[w,m]},{type:"int32",data:[P,k]},{type:"int32",data:[C]},{type:"int32",data:[f*p]},{type:"int32",data:[f]}],K=s.runWebGPUProgram(M,[r],r.dtype,Y),J=[];J.push(K);const ne=pe({inputs:{x:t},backend:s,attrs:{shape:[1,F,-1]}});if(J.push(ne),o!=null){const Ae=jo(o.shape,z);Ae!=null&&(o=pe({inputs:{x:o},backend:s,attrs:{shape:Ae}}),J.push(o))}if(i!=null){const Ae=jo(i.shape,z);Ae!=null&&(i=pe({inputs:{x:i},backend:s,attrs:{shape:Ae}}),J.push(i))}const ye=eu({a:z?K:ne,b:z?ne:K,transposeA:!z,transposeB:!1,backend:s,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:u}),Ne=pe({inputs:{x:ye},backend:s,attrs:{shape:e.outShape}});J.push(ye);for(const Ae of J)s.disposeData(Ae.dataId);return Ne}function Af({x:r,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const p=i!=null,d=o!=null,f=e.dataFormat==="channelsLast",m=f&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",w=Qe().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!w&&(m||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID")))return BP({x:r,filter:t,convInfo:e,backend:s,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:u});const x=Qe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),C=x>-1?x:s.thresholdToIncreaseWorkgroups,I=e.batchSize*Math.ceil(e.outHeight*e.outWidth/32)*Math.ceil(e.outChannels/32);if(Qe().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||I<=C)return WP({x:r,filter:t,convInfo:e,backend:s,bias:i,preluActivationWeights:o,leakyreluAlpha:u,activation:l});let k;const P=[e.padInfo.top,e.padInfo.left],O=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...P]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]}];if(w)k=new LP(e,p,l,d);else{const G=f?e.outHeight*e.outWidth:e.outChannels,M=f?e.outChannels:e.outHeight*e.outWidth,Y=e.filterHeight*e.filterWidth*e.inChannels;O.push({type:"int32",data:[G]},{type:"int32",data:[M]},{type:"int32",data:[Y]});const K=s.adapterInfo.isIntel();k=new FP(e,G,M,Y,p,l,d,K)}const z=[],F=[r,t];p&&(!f&&i.shape.length===1&&(i=pe({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),z.push(i)),F.push(i)),d&&(!f&&o.shape.length===1&&(o=pe({inputs:{x:o},backend:s,attrs:{shape:[o.shape[0],1,1]}}),z.push(o)),F.push(o)),l==="leakyrelu"&&(O.push({type:"float32",data:[u]}),k.uniforms+=" alpha : f32,");const V=s.runWebGPUProgram(k,F,r.dtype,O);for(const G of z)s.disposeData(G.dataId);return V}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VP(r){const{inputs:t,attrs:e,backend:s}=r,{x:i,filter:o}=t,{strides:u,pad:l,dataFormat:p,dilations:d,dimRoundingMode:f}=e,m=Ia(p),w=ln(i.shape,o.shape,u,d,l,f,!1,m);return Af({x:i,filter:o,convInfo:w,backend:s})}const UP={kernelName:LS,backendName:"webgpu",kernelFunc:VP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MP{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&t.outChannels%4===0&&t.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,i=`
    ${te()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${te("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class HP{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${te("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class GP{constructor(t){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${te("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class jP{constructor(t){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${te("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,dy:o}=t,{strides:u,pad:l,dataFormat:p,dimRoundingMode:d,filterShape:f}=s,m=Ia(p),w=ln(i.shape,f,u,1,l,d,!1,m),x=new HP(w),C=[{type:"int32",data:[w.padInfo.top,w.padInfo.left]},{type:"int32",data:[w.strideHeight,w.strideWidth]},{type:"int32",data:[w.batchSize]},{type:"int32",data:[w.outHeight]},{type:"int32",data:[w.outWidth]},{type:"int32",data:[w.inHeight]},{type:"int32",data:[w.inWidth]}];return e.runWebGPUProgram(x,[i,o],i.dtype,C)}const qP={kernelName:zS,backendName:"webgpu",kernelFunc:KP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(r=4){const t=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Te(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Te(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${Te(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Te(r)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Te(r)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(r)}
    }
    return ${Te(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Te(r)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}class YP{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,le(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=yf(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=wf(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const t=this.isVec4?Zo(this.elementsPerThread,this.workgroupSize):Jo(this.elementsPerThread,this.workgroupSize);return`
    ${XP(this.isVec4?4:1)}
    ${t}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,filter:o}=t,{inputShape:u,strides:l,pad:p,dataFormat:d,dimRoundingMode:f}=s,m=Ia(d),w=ln(u,o.shape,l,1,p,f,!1,m),x=[{type:"int32",data:[w.filterHeight,w.filterWidth]},{type:"int32",data:[w.filterHeight-1-w.padInfo.top,w.filterWidth-1-w.padInfo.left]},{type:"int32",data:[w.strideHeight,w.strideWidth]},{type:"int32",data:[w.batchSize,w.outHeight,w.outWidth,w.outChannels]}];let C;if(Qe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||w.dataFormat!=="channelsLast")C=new MP(w);else{C=new YP(w);const I=w.inHeight*w.inWidth,k=w.inChannels,P=w.filterHeight*w.filterWidth*w.outChannels;x.push({type:"uint32",data:[I]},{type:"uint32",data:[k]},{type:"uint32",data:[P]})}return e.runWebGPUProgram(C,[i,o],"float32",x)}const ZP={kernelName:BS,backendName:"webgpu",kernelFunc:QP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JP{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o}=t,{strides:u,pad:l,dilations:p}=s,d=dc(i.shape,o.shape,u,p,l),f=[d.padInfo.front,d.padInfo.top,d.padInfo.left],m=[{type:"int32",data:[d.filterDepth,d.filterHeight,d.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationDepth,d.dilationHeight,d.dilationWidth]}],w=new JP(d),x=fa(i.dtype,o.dtype);return e.runWebGPUProgram(w,[i,o],x,m)}const t$={kernelName:WS,backendName:"webgpu",kernelFunc:e$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,dy:o}=t,{strides:u,pad:l,filterShape:p}=s,d=dc(i.shape,p,u,1,l),f=new GP(d),m=[{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inDepth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return e.runWebGPUProgram(f,[i,o],o.dtype,m)}const n$={kernelName:VS,backendName:"webgpu",kernelFunc:r$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,filter:o}=t,{strides:u,pad:l,inputShape:p}=s,d=dc(p,o.shape,u,1,l),f=new jP(d),m=[{type:"int32",data:[d.filterDepth,d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterDepth-1-d.padInfo.front,d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.outChannels]}];return e.runWebGPUProgram(f,[i,o],i.dtype,m)}const i$={kernelName:US,backendName:"webgpu",kernelFunc:s$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$=ze({opType:ee.COS}),o$={kernelName:MS,backendName:"webgpu",kernelFunc:a$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u$=ze({opType:ee.COSH}),l$={kernelName:HS,backendName:"webgpu",kernelFunc:u$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c${constructor(t,e,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=e;this.outputShape=[o,s[0],s[1],t],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,i,o]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[u,l,p]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${u});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${l};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${p};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$=r=>{const{inputs:t,backend:e,attrs:s}=r,{image:i,boxes:o,boxInd:u}=t,{cropSize:l,method:p,extrapolationValue:d}=s,f=new c$(i.shape[3],o.shape,l,p),m=[{type:"float32",data:[d]}];return e.runWebGPUProgram(f,[i,o,u],"float32",m)},p$={kernelName:GS,backendName:"webgpu",kernelFunc:h$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var wa;(function(r){r.Prod="*",r.Sum="+"})(wa||(wa={}));class Gp{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=i,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const t=this.outputShape.length,e=this.op===wa.Prod?"1.0":"0.0",s=this.exclusive?e:`getX(${jp(t,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let o="",u="";return this.exclusive?(o=this.reverse?`end != ${i-1}`:"end != 0",u=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${i}`:"end >= pow2",u=this.reverse?"end + pow2":"end - pow2"),`
      ${te("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${Kp(t,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${u};
           ${Kp(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${jp(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function jp(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function Kp(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(r,t,e,s,i,o){const u=t.shape.length,l=Sa([s],u);let p=t;l!=null&&(p=Fr({inputs:{x:t},backend:e,attrs:{perm:l}}));const d=Ca(1,u)[0];if(d!==u-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const f=p.shape[d];let m=Qt({inputs:{x:p},backend:e});for(let w=0;w<=Math.ceil(Math.log2(f))-1;w++){const x=new Gp(r,p.shape,!1,o),C=m,I=[{type:"float32",data:[w]}];m=e.runWebGPUProgram(x,[m],m.dtype,I),e.disposeData(C.dataId)}if(i){const w=new Gp(r,p.shape,i,o),x=m,C=[{type:"float32",data:[0]}];m=e.runWebGPUProgram(w,[m],m.dtype,C),e.disposeData(x.dataId)}if(l!=null){const w=nf(l),x=Fr({inputs:{x:m},backend:e,attrs:{perm:w}});return e.disposeData(m.dataId),e.disposeData(p.dataId),x}return m}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o,exclusive:u,reverse:l}=s;return Pf(wa.Prod,i,e,o,u,l)}const f$={kernelName:jS,backendName:"webgpu",kernelFunc:d$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o,exclusive:u,reverse:l}=s;return Pf(wa.Sum,i,e,o,u,l)}const g$={kernelName:KS,backendName:"webgpu",kernelFunc:m$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,weights:o}=t,{size:u,binaryOutput:l}=s,p=i.shape.length===1,f=Ce(o.shape)>0,m=o.dtype,w=p?[i.shape[0]]:[i.shape[0],i.shape[1]],x=p?[u]:[i.shape[0],u],C=Vt({backend:e,attrs:{shape:x,value:0,dtype:m}}),I=new _f(w,f,l),k=[{type:"int32",data:[u]}],P=f?[i,o]:[i];return e.runWebGPUProgram(I,P,m,k,C)}const w$={kernelName:qS,backendName:"webgpu",kernelFunc:y$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v${constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{blockSize:o,dataFormat:u}=s,l=i.shape[0],p=u==="NHWC"?i.shape[1]:i.shape[2],d=u==="NHWC"?i.shape[2]:i.shape[3],f=u==="NHWC"?i.shape[3]:i.shape[1],m=p*o,w=d*o,x=f/(o*o),C=u==="NHWC"?[l,m,w,x]:[l,x,m,w],I=[{type:"int32",data:[o]}],k=new v$(C,u);return e.runWebGPUProgram(k,[i],i.dtype,I)}const x$={kernelName:XS,backendName:"webgpu",kernelFunc:b$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S${constructor(t,e,s,i=!1,o=null,u=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=o,this.hasPreluActivation=u,this.filterHeight=e,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${cn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${te()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${ws(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $f{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=ae(o),this.dispatch=re(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),le(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${cn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${te("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${t}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${ws(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ef{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${cn(this.activation,this.hasPreluActivation,!1,4)}

      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${ws(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o}=t,{strides:u,pad:l,dataFormat:p,dilations:d,dimRoundingMode:f}=s,m=Ia(p);let w=d;w==null&&(w=[1,1]);const x=ln(i.shape,o.shape,u,w,l,f,!0,m),C=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}],I=x.dataFormat==="channelsLast";let k;return!I&&x.inHeight>16&&x.inWidth>16&&x.strideHeight===1&&x.strideWidth===1&&x.dilationWidth===1&&x.dilationHeight===1&&x.inChannels===x.outChannels?k=new S$(x.outShape,x.filterHeight,x.filterWidth):I&&x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(k=new $f(x),C.push({type:"int32",data:[k.virtualWidth]})):(k=new Ef(x),C.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),e.runWebGPUProgram(k,[i,o],i.dtype,C)}const N$={kernelName:YS,backendName:"webgpu",kernelFunc:C$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I${constructor(t){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class k${constructor(t){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,dy:o}=t,{strides:u,dilations:l,pad:p,dimRoundingMode:d,filterShape:f}=s,m=ln(i.shape,f,u,l,p,d,!0),w=new I$(m),x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]},{type:"int32",data:[m.inHeight]},{type:"int32",data:[m.inWidth]},{type:"int32",data:[m.batchSize]},{type:"int32",data:[m.outChannels/m.inChannels]}];return e.runWebGPUProgram(w,[i,o],"float32",x)}const T$={kernelName:QS,backendName:"webgpu",kernelFunc:_$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,filter:o}=t,{strides:u,dilations:l,pad:p,dimRoundingMode:d,inputShape:f}=s,m=ln(f,o.shape,u,l,p,d,!0),w=new k$(m),x=[{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.outHeight]},{type:"int32",data:[m.outWidth]},{type:"int32",data:[m.outChannels/m.inChannels]}];return e.runWebGPUProgram(w,[i,o],i.dtype,x)}const A$={kernelName:ZS,backendName:"webgpu",kernelFunc:R$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P${constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(r){const{inputs:t,backend:e}=r,{x:s}=t,i=[...s.shape,...s.shape],o=Ce(s.shape),u=pe({inputs:{x:s},backend:e,attrs:{shape:[o]}}),l=new P$(o),p=e.runWebGPUProgram(l,[u],u.dtype),d=pe({inputs:{x:p},backend:e,attrs:{shape:i}});return e.disposeData(u.dataId),e.disposeData(p.dataId),d}const E$={kernelName:Rd,backendName:"webgpu",kernelFunc:$$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D${constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${te("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o}=t,{strides:u,pad:l,dilations:p}=s,d=fc(i.shape,o.shape,u,l,"NHWC",p),f=[d.padInfo.top,d.padInfo.left],m=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]}],w=new D$(d);return e.runWebGPUProgram(w,[i,o],i.dtype,m)}const F$={kernelName:JS,backendName:"webgpu",kernelFunc:O$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L${constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(t.outShape),this.dispatch=re(this.dispatchLayout,t.outShape,this.workgroupSize),e!=="float32"&&e!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${te("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${$n("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class z${constructor(t,e,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=ae(t.outShape),this.dispatch=re(this.dispatchLayout,t.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${te("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${$n("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o,dy:u}=t,{strides:l,pad:p,dilations:d}=s,f=fc(i.shape,o.shape,l,p,"NHWC",d),m=o.dtype,w=new z$(f,o.shape,m),x=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[Ce(f.outShape)]}],C=Vt({backend:e,attrs:{shape:o.shape,value:0,dtype:m}});return e.runWebGPUProgram(w,[i,o,u],m,x,C)}const W$={kernelName:eC,backendName:"webgpu",kernelFunc:B$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o,dy:u}=t,{strides:l,pad:p,dilations:d}=s,f=fc(i.shape,o.shape,l,p,"NHWC",d),m=i.dtype,w=new L$(f,m),x=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[Ce(f.outShape)]}],C=Vt({backend:e,attrs:{shape:f.inShape,value:0,dtype:m}});return e.runWebGPUProgram(w,[i,o,u],m,x,C)}const U$={kernelName:tC,backendName:"webgpu",kernelFunc:V$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M${constructor(t,e,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=ci.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=s,this.shaderKey=`draw_${e}_${s}`}getUserCode(){let t;const e=this.type==="float32"?"value":"value / 255.0";return t=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${e};
        rgba[1] = ${e};
        rgba[2] = ${e};
      } else {
        rgba[d] = ${e};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${te("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${t}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(r){const{inputs:t,backend:e,attrs:s}=r,{image:i}=t,{canvas:o,options:u}=s,[l,p]=i.shape.slice(0,2),{imageOptions:d}=u||{},f=d?.alpha||1,m=e.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",w=[l,p],x=new M$(w,i.dtype,m);o.width=p,o.height=l;const C="webgpu";let I=o.getContext(C),k;I||(k=new OffscreenCanvas(p,l),I=k.getContext(C));const P=i.shape.length===3?i.shape[2]:1;I.configure({device:e.device,format:m,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const O="int32",z=e.makeTensorInfo(w,O),F=e.tensorMap.get(z.dataId);F.resource=I.getCurrentTexture(),F.external=!0;const V=[{type:"uint32",data:[P]},{type:"float32",data:[f]}];if(e.runWebGPUProgram(x,[i],O,V,z),k){const G=o.getContext("2d");if(!G)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");G.drawImage(k,0,0)}return e.disposeData(z.dataId),i}const G$={kernelName:rC,backendName:"webgpu",kernelFunc:H$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Df=St({opType:Se.MUL,cpuKernelImpl:YR,supportsComplex:!0}),j$={kernelName:nC,backendName:"webgpu",kernelFunc:Df};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o,keepDims:u}=s;return bs(i,o,u,"sum",e)}const K$={kernelName:sC,backendName:"webgpu",kernelFunc:Of};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(r){const{inputs:t,backend:e,attrs:s}=r,{equation:i}=s,o=t,{allDims:u,summedDims:l,idDims:p}=aC(i,o.length);oC(u.length,p,o);const{path:d,steps:f}=uC(l,p),m=f.length;let w=null,x=u.length;const C=[];for(let I=0;I<m;++I){for(const k of f[I]){const{permutationIndices:P,expandDims:O}=lC(x,p[k]);let z;cC(P)?z=o[k]:(z=Fr({inputs:{x:o[k]},backend:e,attrs:{perm:P}}),C.push(z));const F=z.shape.slice();for(let V=0;V<O.length;++V)F.splice(O[V],0,1);Cr(z.shape,F)||(z=pe({inputs:{x:z},backend:e,attrs:{shape:F}}),C.push(z)),w===null?w=z:(w=Df({inputs:{a:z,b:w},backend:e}),C.push(w))}I<m-1&&(d[I]>=0&&(w=Of({inputs:{x:w},backend:e,attrs:{axis:d[I]-(u.length-x),keepDims:!1}}),C.push(w)),x--)}for(const I of C)I!==w&&e.disposeData(I.dataId);return w}const X$={kernelName:iC,backendName:"webgpu",kernelFunc:q$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$=ze({opType:ee.ELU}),Q$={kernelName:hC,backendName:"webgpu",kernelFunc:Y$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$=r=>{const{inputs:t,backend:e}=r,{dy:s,y:i}=t,o=new Go(Se.ELU_DER,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],s.dtype)},J$={kernelName:pC,backendName:"webgpu",kernelFunc:Z$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eE=St({opType:Se.EQUAL,dtype:"bool",cpuKernelImpl:OR}),tE={kernelName:dC,backendName:"webgpu",kernelFunc:eE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rE=ze({opType:ee.ERF}),nE={kernelName:fC,backendName:"webgpu",kernelFunc:rE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE=ze({opType:ee.EXP,cpuKernelImpl:FR,dtype:"float32"}),iE={kernelName:mC,backendName:"webgpu",kernelFunc:sE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xl(r){const{inputs:t,attrs:e,backend:s}=r,{dim:i}=e,{input:o}=t,u=o.shape.length,l=o.shape.slice();let p=i;return i<0&&(le(-(u+1)<=i,()=>`Axis must be in the interval [${-(u+1)}, ${u}]`),p=u+i+1),l.splice(p,0,1),pe({inputs:{x:o},backend:s,attrs:{shape:l}})}const aE={kernelName:gC,backendName:"webgpu",kernelFunc:Xl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oE=ze({opType:ee.EXPM1,cpuKernelImpl:LR}),uE={kernelName:yC,backendName:"webgpu",kernelFunc:oE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qp{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(r,t,e){const s=e.tensorMap.get(r.dataId),i=Ce(r.shape),o=r.shape[r.shape.length-1],u=i/o,l=[],p=pe({inputs:{x:r},backend:e,attrs:{shape:[u,o]}});l.push(p);const d=p.shape,f=new qp("real",d),m=new qp("imag",d),w=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:d},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:d}],x=t?2*Math.PI:-2*Math.PI,C=t?d[1]:1,I=[{type:"float32",data:[x]},{type:"float32",data:[C]}],k=e.runWebGPUProgram(f,w,"float32",I);l.push(k);const P=e.runWebGPUProgram(m,w,"float32",I);l.push(P);const O=vs({inputs:{real:k,imag:P},backend:e});l.push(O);const z=pe({inputs:{x:O},backend:e,attrs:{shape:r.shape}});return l.forEach(F=>e.disposeData(F.dataId)),z}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(r){const{inputs:t,backend:e}=r,{input:s}=t;return Ff(s,!1,e)}const cE={kernelName:wC,backendName:"webgpu",kernelFunc:lE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hE{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE={kernelName:vC,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{const{image:e}=r,s=t,i=new hE(e.shape);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE=ze({opType:ee.FLOOR,cpuKernelImpl:zR}),fE={kernelName:bC,backendName:"webgpu",kernelFunc:dE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE=St({opType:Se.FLOOR_DIV,cpuKernelImpl:BR,dtype:"int32"}),gE={kernelName:xC,backendName:"webgpu",kernelFunc:mE};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yE{constructor(t,e,s=!1){this.pixelsOpType=ci.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${te("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wE={kernelName:SC,backendName:"webgpu",kernelFunc:vE};let ti,xl=Qe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function vE(r){const{inputs:t,backend:e,attrs:s}=r;let{pixels:i}=t;const{numChannels:o}=s;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const u=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,p=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,d=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[f,m]=u?[i.videoWidth,i.videoHeight]:[i.width,i.height],w=[m,f,o],x=Qe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&u,C=u||l;if(d||p||C){let O;if(x)O=e.device.importExternalTexture({source:i});else{if(C){const ce=Qe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ti==null||ce!==xl)&&(xl=ce,ti=document.createElement("canvas").getContext("2d",{willReadFrequently:xl})),ti.canvas.width=f,ti.canvas.height=m,ti.drawImage(i,0,0,f,m),i=ti.canvas}const J=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,me=e.textureManager.acquireTexture(w[1],w[0],"rgba8unorm",J);e.queue.copyExternalImageToTexture({source:i},{texture:me},[w[1],w[0]]),O=me}const z=Ce(w),F=da(w),V=new yE(w,o,x),G=[{type:"uint32",data:[z]},{type:"uint32",data:[o]},{type:"uint32",data:[...F]}],M=e.makeTensorInfo([m,f],"int32"),Y=e.tensorMap.get(M.dataId);Y.resource=O;const K=e.runWebGPUProgram(V,[M],"int32",G);return e.disposeData(M.dataId),K}const I=i.data;let k=I;if(o!=null&&o!==4){k=new Uint8Array(i.width*i.height*o);const O=I.length;let z=0;for(let F=0;F<O;F++)F%4<o&&(k[z++]=I[F])}const P=e.makeTensorInfo(w,"int32",new Int32Array(k));return e.uploadToGPU(P.dataId),P}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bE{constructor(t,e,s,i,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],an(t,e),an(t,s),this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(an(t,i),this.variableNames.push("offset")),o!=null&&(an(t,o),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${te("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xE={kernelName:CC,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{const{x:s,scale:i,offset:o,mean:u,variance:l}=r,{varianceEpsilon:p}=t,d=e,f=[s,u,l];let m=null;o!=null&&(m=o.shape,f.push(o));let w=null;i!=null&&(w=i.shape,f.push(i));const x=new bE(s.shape,u.shape,l.shape,m,w),C=[{type:"float32",data:[p]}];return d.runWebGPUProgram(x,f,s.dtype,C)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o,bias:u,preluActivationWeights:l}=t,{strides:p,pad:d,dataFormat:f,dilations:m,dimRoundingMode:w,activation:x,leakyreluAlpha:C}=s,I=Ia(f),k=ln(i.shape,o.shape,p,m,d,w,!1,I);return Af({x:i,filter:o,convInfo:k,backend:e,bias:u,preluActivationWeights:l,leakyreluAlpha:C,activation:x})}const CE={kernelName:NC,backendName:"webgpu",kernelFunc:SE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,filter:o,bias:u,preluActivationWeights:l}=t,{strides:p,pad:d,dilations:f,dimRoundingMode:m,activation:w,leakyreluAlpha:x}=s;let C=f;C==null&&(C=[1,1]),le(ic(p,C),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${p} and dilations '${C}'`);const I=ln(i.shape,o.shape,p,C,d,m,!0),k=[i,o],P=u!=null,O=l!=null;P&&k.push(u),O&&k.push(l);const z=[{type:"int32",data:[I.padInfo.top,I.padInfo.left]},{type:"int32",data:[I.inHeight,I.inWidth]}];let F;return I.outHeight>4&&I.outWidth>4&&I.strideWidth<=2&&I.inChannels===I.outChannels&&I.dilationHeight===1&&I.dilationWidth===1&&I.inChannels%4===0?(F=new $f(I,P,w,O),z.push({type:"int32",data:[F.virtualWidth]})):(F=new Ef(I,P,w,O),z.push({type:"int32",data:[I.filterHeight]},{type:"int32",data:[I.filterWidth]},{type:"int32",data:[I.strideHeight,I.strideWidth]},{type:"int32",data:[I.dilationHeight,I.dilationWidth]})),w==="leakyrelu"&&(z.push({type:"float32",data:[x]}),F.uniforms+=" alpha : f32,"),e.runWebGPUProgram(F,k,"float32",z)}const IE={kernelName:$l,backendName:"webgpu",kernelFunc:NE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kE{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${ht(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(r){const{inputs:t,backend:e}=r,{params:s,indices:i}=t,o=i.shape,u=o[o.length-1],l=Ce(s.shape),[p,d,f,m]=IC(s,i),w=pe({inputs:{x:i},backend:e,attrs:{shape:[d,u]}}),x=pe({inputs:{x:s},backend:e,attrs:{shape:[Ce(s.shape)/f,f]}});if(e.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const O=e.readSync(i.dataId),z=e.bufferSync(s),F=WR(O,z,s.dtype,d,u,f,m,s.shape,l);return e.makeTensorInfo(p,s.dtype,F.values)}const C=new kE(u,[d,f]),I=[{type:"int32",data:[u]},{type:"int32",data:m}],k=e.runWebGPUProgram(C,[x,w],x.dtype,I),P=pe({inputs:{x:k},backend:e,attrs:{shape:p}});return e.disposeData(w.dataId),e.disposeData(x.dataId),e.disposeData(k.dataId),P}const TE={kernelName:Ud,backendName:"webgpu",kernelFunc:_E};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RE{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const t=AE(this.aShape);return`
      ${te("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}}function AE(r){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let s=0;s<r.length;s++)s===2?e.push("indexZ"):e.push(`${t[s]}`);return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lf(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,indices:o}=t,{axis:u,batchDims:l}=s,p=ys(u,i.shape)[0],d=_C(i,o,p,l),f=Ce(o.shape),m=[],w=pe({inputs:{x:i},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),x=pe({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,f/d.batchSize]}});m.push(w),m.push(x);const C=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize];if(e.shouldExecuteOnCPU([i,o])){const z=e.tensorMap.get(x.dataId).values,F=Pn(x.shape,x.dtype,z),G=e.tensorMap.get(w.dataId).values,M=Pn(w.shape,w.dtype,G),Y=VR(M,F,C);return m.forEach(K=>e.disposeData(K.dataId)),e.makeTensorInfo(d.outputShape,Y.dtype,Y.values)}const I=new RE(w.shape,C),k=e.runWebGPUProgram(I,[w,x],w.dtype);m.push(k);const P=pe({inputs:{x:k},backend:e,attrs:{shape:d.outputShape}});return m.forEach(O=>e.disposeData(O.dataId)),P}const PE={kernelName:kC,backendName:"webgpu",kernelFunc:Lf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $E=St({opType:Se.GREATER,cpuKernelImpl:MR,dtype:"bool"}),EE={kernelName:TC,backendName:"webgpu",kernelFunc:$E};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE=St({opType:Se.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:UR}),OE={kernelName:RC,backendName:"webgpu",kernelFunc:DE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(r){const{inputs:t,backend:e}=r,{input:s}=t;return Ff(s,!0,e)}const LE={kernelName:AC,backendName:"webgpu",kernelFunc:FE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE=ze({opType:ee.IS_FINITE,dtype:"bool"}),BE={kernelName:PC,backendName:"webgpu",kernelFunc:zE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WE=ze({opType:ee.IS_INF,dtype:"bool"}),VE={kernelName:$C,backendName:"webgpu",kernelFunc:WE};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE=ze({opType:ee.IS_NAN,dtype:"bool"}),ME={kernelName:EC,backendName:"webgpu",kernelFunc:UE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HE(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{alpha:o}=s,u=[{type:"float32",data:[o]}],l=new di(i.shape,ee.LEAKYRELU,"alpha : f32,");return e.runWebGPUProgram(l,[i],"float32",u)}const GE={kernelName:DC,backendName:"webgpu",kernelFunc:HE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=St({opType:Se.LESS,dtype:"bool",cpuKernelImpl:GR}),KE={kernelName:OC,backendName:"webgpu",kernelFunc:jE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qE=St({opType:Se.LESS_EQUAL,dtype:"bool",cpuKernelImpl:HR}),XE={kernelName:FC,backendName:"webgpu",kernelFunc:qE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YE{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(r){const{backend:t,attrs:e}=r,{start:s,stop:i,num:o}=e,u=(i-s)/(o-1),l=new YE(o),p=[{type:"float32",data:[s]},{type:"float32",data:[u]}];return t.runWebGPUProgram(l,[],"float32",p)}const ZE={kernelName:Ad,backendName:"webgpu",kernelFunc:QE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JE=ze({opType:ee.LOG,cpuKernelImpl:jR}),eD={kernelName:LC,backendName:"webgpu",kernelFunc:JE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=ze({opType:ee.LOG1P}),rD={kernelName:zC,backendName:"webgpu",kernelFunc:tD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD=St({opType:Se.LOGICAL_AND,dtype:"bool"}),sD={kernelName:BC,backendName:"webgpu",kernelFunc:nD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iD=ze({opType:ee.LOGICAL_NOT}),aD={kernelName:WC,backendName:"webgpu",kernelFunc:iD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oD=St({opType:Se.LOGICAL_OR}),uD={kernelName:VC,backendName:"webgpu",kernelFunc:oD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zf=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class lD{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${zf}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class cD{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,le(e<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=re(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${te()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${zf}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{depthRadius:o,bias:u,alpha:l,beta:p}=s;let d;o>16?d=new lD(i.shape):d=new cD(i.shape,o);const f=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[p]}];return e.runWebGPUProgram(d,[i],i.dtype,f)}const pD={kernelName:UC,backendName:"webgpu",kernelFunc:hD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dD{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fD(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,y:o,dy:u}=t,{depthRadius:l,bias:p,alpha:d,beta:f}=s,m=new dD(i.shape),w=[{type:"int32",data:[l]},{type:"float32",data:[p]},{type:"float32",data:[d]},{type:"float32",data:[f]}];return e.runWebGPUProgram(m,[i,o,u],i.dtype,w)}const mD={kernelName:MC,backendName:"webgpu",kernelFunc:fD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gD=St({opType:Se.MAX,cpuKernelImpl:qR}),yD={kernelName:HC,backendName:"webgpu",kernelFunc:gD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{filterSize:o,strides:u,pad:l,dimRoundingMode:p}=s,f=Na(i.shape,o,u,1,l,p);return kf(i,f,"max",e)}const vD={kernelName:GC,backendName:"webgpu",kernelFunc:wD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{filterSize:o,strides:u,pad:l,dataFormat:p,dimRoundingMode:d}=s,f=[1,1,1],m=Qo(i.shape,o,u,f,l,d,p),w=new Cc(m,"max"),x=[{type:"int32",data:[m.strideDepth,m.strideHeight,m.strideWidth]},{type:"int32",data:[m.padInfo.front,m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inDepth,m.inHeight,m.inWidth]},{type:"int32",data:[m.effectiveFilterDepth,m.effectiveFilterHeight,m.effectiveFilterWidth]}];return e.runWebGPUProgram(w,[i],i.dtype,x)}const xD={kernelName:jC,backendName:"webgpu",kernelFunc:bD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SD{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class CD{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${te("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,input:o}=t,u=o,{filterSize:l,strides:p,pad:d,dimRoundingMode:f}=s,m=[1,1,1],w=Qo(u.shape,l,p,m,d,f),x=new Cc(w,"max",!0);let C=[{type:"int32",data:[w.strideDepth,w.strideHeight,w.strideWidth]},{type:"int32",data:[w.padInfo.front,w.padInfo.top,w.padInfo.left]},{type:"int32",data:[w.inDepth,w.inHeight,w.inWidth]},{type:"int32",data:[w.effectiveFilterDepth,w.effectiveFilterHeight,w.effectiveFilterWidth]}];const I=e.runWebGPUProgram(x,[u],"int32",C),k=new CD(w);C=[{type:"int32",data:[w.strideDepth,w.strideHeight,w.strideWidth]},{type:"int32",data:[w.effectiveFilterDepth-1-w.padInfo.front,w.effectiveFilterHeight-1-w.padInfo.top,w.effectiveFilterWidth-1-w.padInfo.left]},{type:"int32",data:[w.effectiveFilterDepth,w.effectiveFilterHeight,w.effectiveFilterWidth]},{type:"int32",data:[w.outDepth]},{type:"int32",data:[w.outHeight]},{type:"int32",data:[w.outWidth]}];const P=e.runWebGPUProgram(k,[i,I],u.dtype,C);return e.disposeData(I.dataId),P}const ID={kernelName:KC,backendName:"webgpu",kernelFunc:ND};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(r){const{inputs:t,backend:e,attrs:s}=r,{dy:i,input:o,output:u}=t,l=o;bf([o,u],"maxPoolGrad");const{filterSize:p,strides:d,pad:f,dimRoundingMode:m}=s,w=Na(l.shape,p,d,1,f,m),x=new ya(w,"max",!0);let C=[{type:"int32",data:[w.strideHeight,w.strideWidth]},{type:"int32",data:[w.padInfo.top,w.padInfo.left]},{type:"int32",data:[w.dilationHeight,w.dilationWidth]},{type:"int32",data:[w.inHeight,w.inWidth]},{type:"int32",data:[w.effectiveFilterHeight,w.effectiveFilterWidth]}];const I=e.runWebGPUProgram(x,[l],"int32",C),k=new SD(w);C=[{type:"int32",data:[w.strideHeight,w.strideWidth]},{type:"int32",data:[w.effectiveFilterHeight-1-w.padInfo.top,w.effectiveFilterWidth-1-w.padInfo.left]},{type:"int32",data:[w.dilationHeight,w.dilationWidth]},{type:"int32",data:[w.effectiveFilterHeight,w.effectiveFilterWidth]},{type:"int32",data:[w.outHeight]},{type:"int32",data:[w.outWidth]}];const P=e.runWebGPUProgram(k,[i,I],l.dtype,C);return e.disposeData(I.dataId),P}const _D={kernelName:qC,backendName:"webgpu",kernelFunc:kD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(r){const{inputs:t,backend:e,attrs:s}=r,{filterSize:i,strides:o,pad:u,includeBatchInIndex:l}=s,{x:p}=t;le(p.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${p.shape.length}.`);const d=[1,1];le(ic(o,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const f=Na(p.shape,i,o,d,u),m=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];let w=new ya(f,"max",!1);const x=e.runWebGPUProgram(w,[p],p.dtype,m);w=new ya(f,"max",!0,!0,l);const C=e.runWebGPUProgram(w,[p],"int32",m);return[x,C]}const RD={kernelName:$d,backendName:"webgpu",kernelFunc:TD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o,keepDims:u}=s;return bs(i,o,u,"min",e)}const PD={kernelName:XC,backendName:"webgpu",kernelFunc:AD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D=St({opType:Se.MIN,cpuKernelImpl:XR}),ED={kernelName:YC,backendName:"webgpu",kernelFunc:$D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DD{constructor(t,e,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((i,o)=>i[0]+t[o]+i[1]),this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map((i,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const t=this.xShape.length,e=this.xShape.map((d,f)=>`uniforms.pad${f}[0]`).join(","),s=this.xShape.map((d,f)=>`uniforms.pad${f}[0] + uniforms.xShape${t>1?`[${f}]`:""}`).join(","),i=t===1?"start":"start[i]",o=t===1?"end":"end[i]",u=t===1?"outC":"outC[i]",l=ht(t),p=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${te("index")} {
        if (index < uniforms.size) {
          let start = ${l}(${e});
          let end = ${l}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${u} < ${i}) {
              ${u} = ${i} * 2 - ${u} - ${this.offset};
            } else if(${u} >= ${o}) {
              ${u} = (${o} - 1) * 2 - ${u} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${p}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OD={kernelName:QC,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{const{x:s}=r,{paddings:i,mode:o}=t,u=e,l=i.map(f=>({type:"int32",data:[f[0],f[1]]})),p=new DD(s.shape,i,o);return u.runWebGPUProgram(p,[s],s.dtype,l)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FD=St({opType:Se.MOD}),LD={kernelName:ZC,backendName:"webgpu",kernelFunc:FD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zD{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${te("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BD{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${te("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(r){const{inputs:t,backend:e,attrs:s}=r,{logits:i}=t,{dim:o}=s,u=pe({inputs:{x:i},backend:e,attrs:{shape:[Ce(i.shape)/i.shape[o],i.shape[o]]}}),l=new BD(u.shape),p=e.runWebGPUProgram(l,[u],i.dtype),d=pe({inputs:{x:p},backend:e,attrs:{shape:i.shape}});return e.disposeData(u.dataId),e.disposeData(p.dataId),d}const WD={kernelName:JC,backendName:"webgpu",kernelFunc:Bf};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VD(r){const{inputs:t,backend:e,attrs:s}=r,{logits:i}=t,{numSamples:o,seed:u,normalized:l}=s,p=l?i:Bf({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),d=p.shape[0],f=p.shape[1],m=new zD(d,o),w=[{type:"float32",data:[u]},{type:"int32",data:[f]}],x=e.runWebGPUProgram(m,[p],"int32",w);return l||e.disposeData(p.dataId),x}const UD={kernelName:Ed,backendName:"webgpu",kernelFunc:VD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(r){const{inputs:t,backend:e}=r,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const o=e.tensorMap.get(s.dataId),[u,l]=QR(o.values,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const i=new di(s.shape,ee.NEG);return e.runWebGPUProgram(i,[s],s.dtype)}const HD={kernelName:eN,backendName:"webgpu",kernelFunc:MD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=r,{boxes:i,scores:o}=t,{maxOutputSize:u,iouThreshold:l,scoreThreshold:p}=s,d=e.readSync(i.dataId),f=e.readSync(o.dataId),{selectedIndices:m}=rN(d,f,u,l,p);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}const jD={kernelName:tN,backendName:"webgpu",kernelFunc:GD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=r,{boxes:i,scores:o}=t,{maxOutputSize:u,iouThreshold:l,scoreThreshold:p,softNmsSigma:d}=s,f=e.readSync(i.dataId),m=e.readSync(o.dataId),w=u,x=l,C=p,I=d,{selectedIndices:k,selectedScores:P}=sN(f,m,w,x,C,I);return[e.makeTensorInfo([k.length],"int32",new Int32Array(k)),e.makeTensorInfo([P.length],"float32",new Float32Array(P))]}const qD={kernelName:nN,backendName:"webgpu",kernelFunc:KD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XD{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${te("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(r){const{inputs:t,backend:e,attrs:s}=r,{indices:i}=t,{dtype:o,depth:u,onValue:l,offValue:p}=s,d=Ce(i.shape),f=new XD(d,u),m=pe({inputs:{x:i},backend:e,attrs:{shape:[d]}}),w=[{type:"float32",data:[l]},{type:"float32",data:[p]}],x=e.runWebGPUProgram(f,[m],o,w);e.disposeData(m.dataId);const C=[...i.shape,u],I=pe({inputs:{x},backend:e,attrs:{shape:C}});return e.disposeData(x.dataId),I}const QD={kernelName:iN,backendName:"webgpu",kernelFunc:YD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(r){const{inputs:t,backend:e}=r,{x:s}=t;if(s.dtype==="complex64"){const i=ka({inputs:{input:s},backend:e}),o=Ko({inputs:{x:i},backend:e}),u=tu({inputs:{input:s},backend:e}),l=Ko({inputs:{x:u},backend:e}),p=vs({inputs:{real:o,imag:l},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(u.dataId),e.disposeData(l.dataId),p}else return Vt({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const ZD={kernelName:aN,backendName:"webgpu",kernelFunc:Ko};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wf(r){const{inputs:t,backend:e}=r,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=ka({inputs:{input:s},backend:e}),o=Wf({inputs:{x:i},backend:e}),u=tu({inputs:{input:s},backend:e}),l=Ko({inputs:{x:u},backend:e}),p=vs({inputs:{real:o,imag:l},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(u.dataId),e.disposeData(l.dataId),p}else return Vt({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const JD={kernelName:oN,backendName:"webgpu",kernelFunc:Wf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(r){const{inputs:t,backend:e,attrs:s}=r,{axis:i}=s;if(t.length===1)return Xl({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,u=t[0].dtype;t.forEach(f=>{nc(o,f.shape,"All tensors passed to stack must have matching shapes"),le(u===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],p=t.map(f=>{const m=Xl({inputs:{input:f},backend:e,attrs:{dim:i}});return l.push(m),m}),d=Rf({inputs:p,backend:e,attrs:{axis:i}});return l.forEach(f=>e.disposeData(f.dataId)),d}const tO={kernelName:uN,backendName:"webgpu",kernelFunc:eO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(r,t=!1){const e=r.length,s=ht(e),i=r.map((m,w)=>`uniforms.pad${w}[0]`).join(","),o=r.map((m,w)=>`uniforms.pad${w}[0] + uniforms.xShape${e>1?`[${w}]`:""}`).join(","),u=e>1?`${s}(${i})`:`${i}`,l=e>1?`${s}(${o})`:`${o}`,p=e>1?"any(paddedCoords < start)":"paddedCoords < start",d=e>1?"any(paddedCoords >= end)":"paddedCoords >= end",f=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
        let start = ${u};
        let end = ${l};
        if (${p} || ${d}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${f}));
        }
  `}class rO{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((s,i)=>s[0]+t[i]+s[1]),this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Vf(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nO=r=>{const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{paddings:o,constantValue:u}=s;if(o.every(d=>Cr(d,[0,0])))return Qt({inputs:{x:i},backend:e});if(Ce(i.shape)===0){const d=o.map((f,m)=>f[0]+i.shape[m]+f[1]);return Vt({backend:e,attrs:{shape:d,value:u,dtype:i.dtype}})}const l=[{type:"float32",data:[u]}];o.map(d=>l.push({type:"int32",data:[d[0],d[1]]}));const p=new rO(i.shape,o);return e.runWebGPUProgram(p,[i],i.dtype,l)},sO={kernelName:lN,backendName:"webgpu",kernelFunc:nO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO=St({opType:Se.POW}),aO={kernelName:cN,backendName:"webgpu",kernelFunc:iO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(r){const{inputs:t,backend:e}=r,{x:s,alpha:i}=t,o=new Go(Se.PRELU,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],"float32")}const uO={kernelName:hN,backendName:"webgpu",kernelFunc:oO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{axis:o,keepDims:u}=s;return bs(i,o,u,"prod",e)}const cO={kernelName:pN,backendName:"webgpu",kernelFunc:lO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hO=r=>{const{backend:t,attrs:e}=r,{start:s,stop:i,step:o,dtype:u}=e,l=eA(s,i,o,u);return t.makeTensorInfo([l.length],u,l)},pO={kernelName:dN,backendName:"webgpu",kernelFunc:hO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dO=St({opType:Se.DIV}),fO={kernelName:fN,backendName:"webgpu",kernelFunc:dO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mO=ze({opType:ee.RECIPROCAL}),gO={kernelName:mN,backendName:"webgpu",kernelFunc:mO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yO=ze({opType:ee.RELU}),wO={kernelName:gN,backendName:"webgpu",kernelFunc:yO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vO=ze({opType:ee.RELU6}),bO={kernelName:yN,backendName:"webgpu",kernelFunc:vO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xO{constructor(t,e,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(r){const{inputs:t,backend:e,attrs:s}=r,{images:i}=t,{alignCorners:o,size:u,halfPixelCenters:l}=s,[p,d]=u,f=o&&p>1?1:0,m=o&&d>1?1:0,x=[{type:"float32",data:[f,m]},{type:"float32",data:[l?.5:0]}],C=new xO(i.shape,p,d);return e.runWebGPUProgram(C,[i],"float32",x)}const CO={kernelName:wN,backendName:"webgpu",kernelFunc:SO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NO{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(r){const{inputs:t,backend:e,attrs:s}=r,{images:i,dy:o}=t,{alignCorners:u}=s,[,l,p]=i.shape,[,d,f]=o.shape,m=[u&&d>1?l-1:l,u&&f>1?p-1:p],w=[u&&d>1?d-1:d,u&&f>1?f-1:f],x=m[0]/w[0],C=m[1]/w[1],I=1/x,k=1/C,P=Math.ceil(I)*2+2,O=Math.ceil(k)*2+2,z=new NO(i.shape,u),F=[{type:"int32",data:m},{type:"int32",data:w},{type:"float32",data:[x]},{type:"float32",data:[C]},{type:"float32",data:[I]},{type:"float32",data:[k]},{type:"int32",data:[P]},{type:"int32",data:[O]}];return e.runWebGPUProgram(z,[o],o.dtype,F)}const kO={kernelName:vN,backendName:"webgpu",kernelFunc:IO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _O{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(r){const{inputs:t,backend:e,attrs:s}=r,{images:i}=t,{alignCorners:o,halfPixelCenters:u,size:l}=s,[p,d]=l,f=o&&p>1?1:0,m=o&&d>1?1:0,x=[{type:"float32",data:[f,m]},{type:"float32",data:[o?.5:0]}],C=new _O(i.shape,p,d,u);return e.runWebGPUProgram(C,[i],i.dtype,x)}const RO={kernelName:bN,backendName:"webgpu",kernelFunc:TO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AO{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(r){const{inputs:t,backend:e,attrs:s}=r,{images:i,dy:o}=t,{alignCorners:u}=s,[,l,p]=i.shape,[,d,f]=o.shape,m=[u&&d>1?l-1:l,u&&f>1?p-1:p],w=[u&&d>1?d-1:d,u&&f>1?f-1:f],x=m[0]/w[0],C=m[1]/w[1],I=1/x,k=1/C,P=Math.ceil(I)*2+2,O=Math.ceil(k)*2+2,z=new AO(i.shape,u),F=[{type:"int32",data:m},{type:"int32",data:w},{type:"float32",data:[I]},{type:"float32",data:[k]},{type:"int32",data:[P]},{type:"int32",data:[O]}];return e.runWebGPUProgram(z,[o],o.dtype,F)}const $O={kernelName:xN,backendName:"webgpu",kernelFunc:PO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EO{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{dims:o}=s,u=i.shape.length;if(u===0)return Qt({inputs:{x:i},backend:e});const l=i.shape,p=[1,1,1,1];l.forEach((k,P)=>{const O=P+4-u;p[O]=k});const d=ys(o,i.shape),f=[0,0,0,0];d.forEach(k=>{const P=k+4-u;f[P]=1});const m=[{type:"int32",data:f}],w=pe({inputs:{x:i},backend:e,attrs:{shape:p}}),x=new EO(p),C=e.runWebGPUProgram(x,[w],w.dtype,m);e.disposeData(w.dataId);const I=pe({inputs:{x:C},backend:e,attrs:{shape:l}});return e.disposeData(C.dataId),I}const OO={kernelName:SN,backendName:"webgpu",kernelFunc:DO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FO{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${te("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LO={kernelName:CN,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{const{image:s}=r,{radians:i,fillValue:o,center:u}=t,l=e,p=new FO(s.shape,o),[d,f]=NN(u,s.shape[1],s.shape[2]),m=[{type:"float32",data:[d]},{type:"float32",data:[f]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof o=="number"?m.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):m.push({type:"float32",data:o}),l.runWebGPUProgram(p,[s],s.dtype,m)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zO=ze({opType:ee.ROUND}),BO={kernelName:IN,backendName:"webgpu",kernelFunc:zO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WO=ze({opType:ee.RSQRT,cpuKernelImpl:tA}),VO={kernelName:kN,backendName:"webgpu",kernelFunc:WO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ha{constructor(t,e,s,i,o,u,l,p=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=u,this.type=l,this.sumDupeIndices=p,this.dispatchLayout=ae(t),this.dispatch=re(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${s}_${i}_${this.sliceDimGreaterThanOne}_${l}_${p}_${o.length}`;const d=ht(o.length);this.uniforms=`sliceDim : i32, strides: ${d}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=s}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");const e=`getIndices(${t})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",o="";this.dispatchLayout.x.length===1?(i="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const l=`getUpdates(${Array.from({length:this.updatesRank},(d,f)=>`coords[${f}]`).join(", ")})`;return`
    ${o}
      ${te("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${as(this.type)}(${l});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?$n("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UO(r){const{inputs:t,backend:e,attrs:s}=r,{indices:i,updates:o}=t,{shape:u}=s,{sliceRank:l,numUpdates:p,sliceSize:d,strides:f,outputSize:m}=mc(o,i,u),w=[m/d,d];if(m===0)return e.makeTensorInfo(u,i.dtype);const x=pe({inputs:{x:i},backend:e,attrs:{shape:[p,l]}}),C=pe({inputs:{x:o},backend:e,attrs:{shape:[p,d]}}),I=C.dtype,k=Vt({backend:e,attrs:{shape:w,value:0,dtype:I}}),P=Ce(C.shape),O=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[P]}],z=new ha(C.shape,l,x.shape.length,C.shape.length,f,w,I),F=e.runWebGPUProgram(z,[C,x],I,O,k),V=pe({inputs:{x:F},backend:e,attrs:{shape:u}});return e.disposeData(x.dataId),e.disposeData(C.dataId),e.disposeData(F.dataId),V}const MO={kernelName:Wd,backendName:"webgpu",kernelFunc:UO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HO{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${te("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GO(r){const{inputs:t,backend:e,attrs:s}=r,{sortedSequence:i,values:o}=t,{side:u}=s,l=new HO([o.shape[0],o.shape[1]],u),p=[{type:"int32",data:[i.shape[1]]}];return e.runWebGPUProgram(l,[i,o],"int32",p)}const jO={kernelName:Pd,backendName:"webgpu",kernelFunc:GO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KO{constructor(t,e,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=s,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],u=[];for(let l=0;l<this.outputShape.length;l++)u.push(`${i[l]}`),l<this.cRank&&o.push(`${i[l]}`);t=o.join(),e=u.join()}return`
      ${te("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qO(r){const{inputs:t,backend:e}=r,{condition:s,t:i,e:o}=t,u=new KO(s.shape.length,i.shape,i.shape.length);return e.runWebGPUProgram(u,[s,i,o],fa(i.dtype,o.dtype))}const XO={kernelName:_N,backendName:"webgpu",kernelFunc:qO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YO=ze({opType:ee.SELU}),QO={kernelName:TN,backendName:"webgpu",kernelFunc:YO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZO=ze({opType:ee.SIGMOID}),JO={kernelName:RN,backendName:"webgpu",kernelFunc:ZO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eF=ze({opType:ee.SIGN}),tF={kernelName:AN,backendName:"webgpu",kernelFunc:eF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rF=ze({opType:ee.SIN}),nF={kernelName:PN,backendName:"webgpu",kernelFunc:rF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sF=ze({opType:ee.SINH}),iF={kernelName:$N,backendName:"webgpu",kernelFunc:sF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF=ze({opType:ee.SOFTPLUS}),oF={kernelName:EN,backendName:"webgpu",kernelFunc:aF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uF{constructor(t,e,s,i,o,u){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const l=new Array(i.length);for(let p=0;p<l.length;p++)l[p]=i[o[p]];this.outputShape=l,this.newDim=o,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${ht(i.length)}, paddedXShapeStrides : ${ht(u)}, `,s.map((p,d)=>{this.uniforms+=` pad${d} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const t=ht(this.outputShape.length),e=Sf(this.newDim);return`
      ${Wo(this.paddedXShape,"PaddedX")}
      ${te("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Vf(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lF=r=>{const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{blockShape:o,paddings:u}=s;le(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const l=o.reduce((O,z)=>O*z),p=[[0,0]];p.push(...u);for(let O=1+o.length;O<i.shape.length;++O)p.push([0,0]);const d=p.map((O,z)=>O[0]+i.shape[z]+O[1]),f=ef(d,o,l,!1),m=tf(f.length,o.length,!1),w=rf(d,o,l,!1),x=da(d),C=new uF(i.shape,d,p,f,m,x.length),I=[{type:"int32",data:f},{type:"int32",data:x}];p.map(O=>I.push({type:"int32",data:[O[0],O[1]]}));const k=e.runWebGPUProgram(C,[i],i.dtype,I),P=pe({inputs:{x:k},backend:e,attrs:{shape:w}});return e.disposeData(k.dataId),P},cF={kernelName:DN,backendName:"webgpu",kernelFunc:lF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hF{constructor(t,e,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=s,this.dispatchLayout=ae([e]),this.dispatch=re(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${$n("&result[outIndex]","value",this.type)}
      }
    }
  `}}class pF{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=ae(e),this.dispatch=re(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${$n("&result[segmentId]","1","int32")}
      }
    }
  `}}class dF{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=ae(t),this.dispatch=re(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uf(r,t,e,s=!1,i){const u=Ce(r.shape)/r.shape[0],l=r.dtype,p=Ce(t.shape),d=i.readSync(e.dataId),m=p>0?d[p-1]+1:0;let w;const x=r.shape.slice();x[0]=m;const C=p*u,I=Vt({backend:i,attrs:{shape:x,value:0,dtype:l}});w=new hF(x,C,l);let k=[{type:"int32",data:[u]},{type:"int32",data:[C]}];const P=i.runWebGPUProgram(w,[r,t,e],l,k,I);if(s)return P;const O=Vt({backend:i,attrs:{shape:[m],value:0,dtype:"int32"}});w=new pF(m,e.shape);const z=i.runWebGPUProgram(w,[e],"int32",null,O),F=Vt({backend:i,attrs:{shape:x,value:0,dtype:l}});w=new dF(x,l),k=[{type:"int32",data:[u]}];const V=i.runWebGPUProgram(w,[P,z],l,k,F);return i.disposeData(P.dataId),i.disposeData(z.dataId),V}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(r){const{inputs:t,backend:e}=r,{data:s,indices:i,segmentIds:o}=t;return Uf(s,i,o,!1,e)}const mF={kernelName:ON,backendName:"webgpu",kernelFunc:fF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(r){const{inputs:t,backend:e}=r,{data:s,indices:i,segmentIds:o}=t;return Uf(s,i,o,!0,e)}const yF={kernelName:FN,backendName:"webgpu",kernelFunc:gF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wF{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[i]*e[i];this.outputShape=s,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const t=vF(this.rank,"uniforms.");return`
      ${te("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}}function vF(r,t=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${t}aShape)`;const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<r;i++)s.push(`(${e[i]} % ${t}aShape[${i}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nc(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{reps:o}=s;if(e.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const p=e.readSync(i.dataId),d=i.dtype==="string"?p.map(w=>cc(w)):p,f=Pn(i.shape,i.dtype,d),m=uA(f,o);return e.makeTensorInfo(m.shape,m.dtype,m.values)}const u=new wF(i.shape,o);return e.runWebGPUProgram(u,[i],i.dtype)}const bF={kernelName:LN,backendName:"webgpu",kernelFunc:Nc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(r){const{inputs:t,backend:e,attrs:s}=r,{sparseIndices:i,sparseValues:o,defaultValue:u}=t,{outputShape:l}=s,{sliceRank:p,numUpdates:d,sliceSize:f,strides:m,outputSize:w}=mc(o,i,l),x=!1;if(o.dtype==="string"){const Y=e.bufferSync(i),K=e.bufferSync(o),J=cc(e.readSync(u.dataId)[0]),ne=rA(Y,K,l,w,f,d,p,m,J,x);return e.makeTensorInfo(l,ne.dtype,ne.values)}const C=[w/f,f],I=pe({inputs:{x:i},backend:e,attrs:{shape:[d,p]}}),k=o.shape.length?pe({inputs:{x:o},backend:e,attrs:{shape:[d,f]}}):Qt({inputs:{x:o},backend:e}),P=k.dtype,O=e.makeTensorInfo([],P,zN(1,P)),z=pe({inputs:{x:u},backend:e,attrs:{shape:Array(C.length).fill(1)}}),F=Nc({inputs:{x:z},backend:e,attrs:{reps:C}}),V=Ce([d,f]),G=[{type:"int32",data:[p]},{type:"int32",data:m},{type:"int32",data:[V]}];switch(d){case 0:break;case 1:{const Y=new ha([d,f],p,I.shape.length,k.shape.length,m,C,P,x);e.runWebGPUProgram(Y,[k,I],P,G,F)}break;default:{const Y=new ha([d,f],p,I.shape.length,O.shape.length,m,C,P,x);e.runWebGPUProgram(Y,[O,I],P,G,F)}{const Y=new ha([d,f],p,I.shape.length,k.shape.length,m,C,P);e.runWebGPUProgram(Y,[k,I],P,G,F)}}const M=pe({inputs:{x:F},backend:e,attrs:{shape:l}});return e.disposeData(I.dataId),e.disposeData(k.dataId),e.disposeData(z.dataId),e.disposeData(O.dataId),e.disposeData(F.dataId),M}const SF={kernelName:Vd,backendName:"webgpu",kernelFunc:xF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{numOrSizeSplits:o,axis:u}=s,l=ys(u,i.shape)[0],p=WN(i,o,l),d=i.shape.length,f=new Array(d).fill(0),m=i.shape.slice();return p.map(w=>{const x=[...m];x[l]=w;const C=fi({inputs:{x:i},backend:e,attrs:{begin:f,size:x}});return f[l]+=w,C})}const NF={kernelName:BN,backendName:"webgpu",kernelFunc:CF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=ze({opType:ee.SQRT}),kF={kernelName:VN,backendName:"webgpu",kernelFunc:IF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _F={kernelName:UN,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{const{x:e}=r,s=t,i=new di(e.shape,ee.SQUARE);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=St({opType:Se.SQUARED_DIFFERENCE}),RF={kernelName:MN,backendName:"webgpu",kernelFunc:TF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF({inputs:r,attrs:t,backend:e}){const{x:s}=r,i=new di(s.shape,ee.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[t.alpha]}];return e.runWebGPUProgram(i,[s],s.dtype,o)}const PF={kernelName:HN,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $F{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const e=ht(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){const t=this.outputShape.length;let e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let i=0;e=this.outputShape.map((o,u)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${u}] + uniforms.begin[${u}]`:`coords[${i-1}] * uniforms.strides[${u}] + uniforms.begin[${u}]`)).join(",")}return`
       ${te("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{begin:o,end:u,strides:l,beginMask:p,endMask:d,ellipsisMask:f,newAxisMask:m,shrinkAxisMask:w}=s,{finalShapeSparse:x,finalShape:C,isIdentity:I,sliceDim0:k,isSimpleSlice:P,begin:O,end:z,strides:F}=jN(i.shape,o,u,l,p,d,f,m,w);let V;if(I)V=pe({inputs:{x:i},backend:e,attrs:{shape:C}});else if(k||P){le(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const G=KN(O,z,F),M=fi({inputs:{x:i},backend:e,attrs:{begin:O,size:G}});V=pe({inputs:{x:M},backend:e,attrs:{shape:C}}),e.disposeData(M.dataId)}else if(e.shouldExecuteOnCPU([i])){const M=e.readSync(i.dataId),Y=Pn(i.shape,i.dtype,M),K=iA(x,Y,F,O);V=e.makeTensorInfo(C,i.dtype,K.values)}else{const M=new $F(x),Y=[{type:"int32",data:O},{type:"int32",data:F}],K=e.runWebGPUProgram(M,[i],i.dtype,Y);V=pe({inputs:{x:K},backend:e,attrs:{shape:C}}),e.disposeData(K.dataId)}return V}const DF={kernelName:GN,backendName:"webgpu",kernelFunc:EF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(r){const{inputs:t,backend:e,attrs:s}=r,{separator:i,nGramWidths:o,leftPad:u,rightPad:l,padWidth:p,preserveShortSequences:d}=s,{data:f,dataSplits:m}=t,w=e.readSync(f.dataId),x=e.readSync(m.dataId),[C,I]=aA(w,x,i,o,u,l,p,d);return[e.makeTensorInfo([C.length],"string",C),e.makeTensorInfo(m.shape,"int32",I)]}const FF={kernelName:qN,backendName:"webgpu",kernelFunc:OF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=St({opType:Se.SUB,cpuKernelImpl:oA,supportsComplex:!0}),zF={kernelName:XN,backendName:"webgpu",kernelFunc:LF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BF=ze({opType:ee.TAN}),WF={kernelName:YN,backendName:"webgpu",kernelFunc:BF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=ze({opType:ee.TANH}),UF={kernelName:QN,backendName:"webgpu",kernelFunc:VF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(r){const{inputs:t,backend:e,attrs:s}=r,{tensor:i,indices:o,updates:u}=t,{sliceRank:l,numUpdates:p,sliceSize:d,strides:f,outputSize:m}=mc(u,o,i.shape),w=[m/d,d];if(m===0)return e.makeTensorInfo(i.shape,o.dtype);const x=[],C=pe({inputs:{x:o},backend:e,attrs:{shape:[p,l]}});x.push(C);const I=pe({inputs:{x:u},backend:e,attrs:{shape:[p,d]}});x.push(I);const k=pe({inputs:{x:i},backend:e,attrs:{shape:w}});x.push(k);const P=Nc({inputs:{x:k},backend:e,attrs:{reps:Array(w.length).fill(1)}}),O=new ha([p,d],l,C.shape.length,I.shape.length,f,w,i.dtype,!1),z=Ce([p,d]),F=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[z]}],V=e.runWebGPUProgram(O,[I,C],k.dtype,F,P);x.push(V);const G=pe({inputs:{x:V},backend:e,attrs:{shape:i.shape}});return x.forEach(M=>e.disposeData(M.dataId)),G}const HF={kernelName:Ld,backendName:"webgpu",kernelFunc:MF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GF{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${te("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class jF{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${te("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ri(r,t){t!==null&&r.disposeData(t.dataId)}function Xp(r){let t=1;for(;t<r;)t*=2;return t}function KF(r){const{inputs:t,backend:e,attrs:s}=r,{x:i}=t,{k:o,sorted:u}=s,l=i.shape,p=l[l.length-1];if(e.shouldExecuteOnCPU([i])){const V=e.readSync(i.dataId),[G,M]=lA(V,l,i.dtype,o,u);return[e.makeTensorInfo(G.shape,G.dtype,G.values),e.makeTensorInfo(M.shape,M.dtype,M.values)]}if(o===0)return l[l.length-1]=0,[e.makeTensorInfo(l,i.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(p===1)return[i,Vt({attrs:{shape:l,dtype:"int32",value:0},backend:e})];const f=Ce(l)/p,m=pe({inputs:{x:i},attrs:{shape:[f,p]},backend:e}),w=Xp(o),x=Xp(p);let C=null;const I=()=>C===null?[m,m]:[m,C],k=(V,G,M)=>{const Y=I(),K=new GF(M),ne=[{type:"int32",data:[p]},{type:"int32",data:[C===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[V]},{type:"int32",data:[G]}],me=C;C=e.runWebGPUProgram(K,Y,"int32",ne),ri(e,me)};for(let V=1;V<w;V*=2){const G=V*2;for(let M=V;M>=1;M/=2)k(G,M,[f,x])}for(let V=x;V>w;V/=2){const G=I(),M=new jF([f,V/2]),K=[{type:"int32",data:[p]},{type:"int32",data:[C===null?1:0]},{type:"int32",data:[w]}],J=C;C=e.runWebGPUProgram(M,G,"int32",K),ri(e,J);const ne=w/2,me=ne*2;for(let ce=ne;ce>=1;ce/=2)k(me,ce,C.shape)}let P=C;C=fi({inputs:{x:C},backend:e,attrs:{begin:0,size:[f,o]}}),ri(e,P);let O=Lf({inputs:{x:m,indices:C},backend:e,attrs:{axis:1,batchDims:1}});ri(e,m);const z=l.slice(0,-1);z.push(o),P=C,C=pe({inputs:{x:C},attrs:{shape:z},backend:e}),ri(e,P);const F=O;return O=pe({inputs:{x:O},attrs:{shape:z},backend:e}),ri(e,F),[O,C]}const qF={kernelName:ZN,backendName:"webgpu",kernelFunc:KF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XF{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${te("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(r){const{inputs:t,backend:e,attrs:s}=r,{image:i,transforms:o}=t,{interpolation:u,fillMode:l,fillValue:p,outputShape:d}=s,[f,m,w,x]=i.shape,[C,I]=d??[m,w],k=[f,C,I,x],P=new XF(k),O=u==="nearest"?1:2;let z;switch(l){case"constant":z=1;break;case"reflect":z=2;break;case"wrap":z=3;break;case"nearest":z=4;break;default:z=1;break}const F=[{type:"int32",data:[O]},{type:"int32",data:[z]},{type:"float32",data:[p]}];return e.runWebGPUProgram(P,[i,o],"float32",F)}const QF={kernelName:JN,backendName:"webgpu",kernelFunc:YF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(r){const{inputs:t,backend:e,attrs:s}=r,{value:i}=t;let{axis:o}=s;o<0&&(o+=i.shape.length);const u=i,l=u.shape.length,p=i.shape[o],d=new Array(l-1);let f=0;for(let I=0;I<l;I++)I!==o&&(d[f++]=u.shape[I]);const m=[],w=new Array(l).fill(0),x=u.shape.slice();x[o]=1;const C=new Array(p);for(let I=0;I<C.length;I++){w[o]=I;const k=fi({inputs:{x:u},backend:e,attrs:{begin:w,size:x}}),P=pe({inputs:{x:k},backend:e,attrs:{shape:d}});C[I]=P,m.push(k)}return m.forEach(I=>e.disposeData(I.dataId)),C}const JF={kernelName:e3,backendName:"webgpu",kernelFunc:ZF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eL{constructor(t,e,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=ae(t),this.dispatch=re(this.dispatchLayout,t,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${te("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${$n("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(r){const{inputs:t,backend:e,attrs:s}=r,{x:i,segmentIds:o}=t,{numSegments:u}=s,l=i.shape.length,p=[];let d=0;const f=Sa([d],l);let m=i;f!=null&&(m=Fr({inputs:{x:i},backend:e,attrs:{perm:f}}),p.push(m),d=Ca(1,l)[0]);const w=r3(m.shape,d,u),x=Ce([m.shape[d]]),C=pe({inputs:{x:m},backend:e,attrs:{shape:[-1,x]}});p.push(C);const I=i.dtype,k=[C.shape[0],u],P=Vt({backend:e,attrs:{shape:k,value:0,dtype:I}}),O=new eL(C.shape,k,I),z=[{type:"int32",data:[u]},{type:"int32",data:[Ce(C.shape)]}],F=e.runWebGPUProgram(O,[C,o],I,z,P),V=pe({inputs:{x:F},backend:e,attrs:{shape:w}});p.push(F);let G=V;if(f!=null){p.push(V);const M=nf(f);G=Fr({inputs:{x:G},backend:e,attrs:{perm:M}})}return p.forEach(M=>e.disposeData(M.dataId)),G}const rL={kernelName:t3,backendName:"webgpu",kernelFunc:tL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL=[TR,pA,fA,gA,wA,xA,TA,AA,$A,DA,FA,zA,WA,UA,HA,XA,QA,tP,nP,iP,cP,fP,yP,xP,CP,_P,AR,AP,DP,UP,qP,ZP,t$,n$,i$,o$,l$,p$,f$,g$,w$,x$,T$,A$,N$,E$,F$,W$,U$,G$,X$,Q$,J$,tE,nE,iE,aE,uE,cE,IR,pE,wE,fE,gE,xE,CE,IE,TE,PE,EE,OE,RR,LE,$P,BE,VE,ME,GE,KE,XE,ZE,rD,eD,sD,aD,uD,pD,mD,jA,yD,vD,_D,xD,ID,RD,KA,PD,ED,OD,LD,UD,j$,HD,jD,qD,wP,QD,JD,tO,sO,aO,uO,cO,pO,vP,fO,gO,wO,bO,kR,CO,kO,RO,$O,OO,LO,BO,VO,MO,jO,XO,QO,JO,tF,nF,iF,uP,PF,DF,FF,WD,oF,cF,mF,yF,SF,NF,kF,_F,RF,zF,K$,WF,UF,HF,bF,qF,QF,NA,JF,rL,ZD];for(const r of nL)n3(r);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Mf=function(r,t){return(Mf=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,s){e.__proto__=s}||function(e,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(e[i]=s[i])})(r,t)};function Hf(r,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function e(){this.constructor=r}Mf(r,t),r.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Ze=function(){return(Ze=Object.assign||function(r){for(var t,e=1,s=arguments.length;e<s;e++)for(var i in t=arguments[e])Object.prototype.hasOwnProperty.call(t,i)&&(r[i]=t[i]);return r}).apply(this,arguments)};function Oe(r,t,e,s){return new(e||(e=Promise))(function(i,o){function u(d){try{p(s.next(d))}catch(f){o(f)}}function l(d){try{p(s.throw(d))}catch(f){o(f)}}function p(d){var f;d.done?i(d.value):(f=d.value,f instanceof e?f:new e(function(m){m(f)})).then(u,l)}p((s=s.apply(r,[])).next())})}function Fe(r,t){var e,s,i,o,u={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:l(0),throw:l(1),return:l(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function l(p){return function(d){return function(f){if(e)throw new TypeError("Generator is already executing.");for(;u;)try{if(e=1,s&&(i=2&f[0]?s.return:f[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,f[1])).done)return i;switch(s=0,i&&(f=[2&f[0],i.value]),f[0]){case 0:case 1:i=f;break;case 4:return u.label++,{value:f[1],done:!1};case 5:u.label++,s=f[1],f=[0];continue;case 7:f=u.ops.pop(),u.trys.pop();continue;default:if(i=u.trys,!((i=i.length>0&&i[i.length-1])||f[0]!==6&&f[0]!==2)){u=0;continue}if(f[0]===3&&(!i||f[1]>i[0]&&f[1]<i[3])){u.label=f[1];break}if(f[0]===6&&u.label<i[1]){u.label=i[1],i=f;break}if(i&&u.label<i[2]){u.label=i[2],u.ops.push(f);break}i[2]&&u.ops.pop(),u.trys.pop();continue}f=t.call(r,u)}catch(m){f=[6,m],s=0}finally{e=i=0}if(5&f[0])throw f[1];return{value:f[0]?f[1]:void 0,done:!0}}([p,d])}}}function us(r,t,e){if(e||arguments.length===2)for(var s,i=0,o=t.length;i<o;i++)!s&&i in t||(s||(s=Array.prototype.slice.call(t,0,i)),s[i]=t[i]);return r.concat(s||Array.prototype.slice.call(t))}var Lr=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],va=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function qo(r){return r instanceof SVGAnimatedLength?r.baseVal.value:r}function Gf(r){return Oe(this,void 0,void 0,function(){var t,e;return Fe(this,function(s){switch(s.label){case 0:return t=document.createElement("canvas"),r instanceof Or?[4,gc(r,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=qo(r.width),t.height=qo(r.height),e=t.getContext("2d"),r instanceof ImageData?e.putImageData(r,0,0):e.drawImage(r,0,0),s.label=3;case 3:return[2,t]}})})}function jf(r){return Oe(this,void 0,void 0,function(){var t,e,s,i,o,u;return Fe(this,function(l){switch(l.label){case 0:return r instanceof Or?(t=r.shape.slice(0,2),e=t[0],s=t[1],i=ImageData.bind,[4,gc(r)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,l.sent(),s,e]))];case 2:return o=document.createElement("canvas"),u=o.getContext("2d"),o.width=qo(r.width),o.height=qo(r.height),u.drawImage(r,0,0),[2,u.getImageData(0,0,o.width,o.height)]}})})}function sL(r){return Oe(this,void 0,void 0,function(){var t,e;return Fe(this,function(s){switch(s.label){case 0:return r instanceof SVGImageElement||r instanceof OffscreenCanvas?[4,Gf(r)]:[3,2];case 1:return e=s.sent(),[3,3];case 2:e=r,s.label=3;case 3:return t=e,[2,sf(t,4)]}})})}function Kf(r){if(r<0||r>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(r));if(!Number.isInteger(r))throw new Error("Mask value must be an integer but got ".concat(r))}var oa={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},iL=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,this.mask]})})},r.prototype.toImageData=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,jf(this.mask)]})})},r.prototype.toTensor=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,sL(this.mask)]})})},r.prototype.getUnderlyingType=function(){return"canvasimagesource"},r}();function aL(r){return Kf(r),"person"}var oL=function(){function r(t){var e,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new k_.Pose({locateFile:function(i,o){if(t.solutionPath){var u=t.solutionPath.replace(/\/+$/,"");return"".concat(u,"/").concat(i)}return"".concat(o,"/").concat(i)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;case"full":default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(i){if(s.height=i.image.height,s.width=i.image.width,i.poseLandmarks==null)s.poses=[];else{var o=s.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(o.segmentation={maskValueToLabel:aL,mask:new iL(i.segmentationMask)}),s.poses=[o]}})}return r.prototype.translateOutput=function(t,e){var s=this,i={keypoints:t.map(function(o,u){return{x:o.x*s.width,y:o.y*s.height,z:o.z,score:o.visibility,name:va[u]}})};return e!=null&&(i.keypoints3D=e.map(function(o,u){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:va[u]}})),i},r.prototype.estimatePoses=function(t,e,s){return Oe(this,void 0,void 0,function(){var i,o;return Fe(this,function(u){switch(u.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof Or?(o=ImageData.bind,[4,gc(t)]):[3,2];case 1:return i=new(o.apply(ImageData,[void 0,u.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:i=t,u.label=3;case 3:return t=i,[4,this.poseSolution.send({image:t},s)];case 4:return u.sent(),[2,this.poses]}})})},r.prototype.dispose=function(){this.poseSolution.close()},r.prototype.reset=function(){this.poseSolution.reset()},r.prototype.initialize=function(){return this.poseSolution.initialize()},r}();function uL(r){return Oe(this,void 0,void 0,function(){var t,e;return Fe(this,function(s){switch(s.label){case 0:return t=function(i){if(i==null)return Ze({},oa);var o=Ze({},i);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=oa.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=oa.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=oa.smoothSegmentation),o.modelType==null&&(o.modelType=oa.modelType),o}(r),[4,(e=new oL(t)).initialize()];case 1:return s.sent(),[2,e]}})})}function hi(r){return r instanceof Or?{height:r.shape[0],width:r.shape[1]}:{height:r.height,width:r.width}}function qf(r){return r-2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI))}function Ic(r){return r instanceof Or?r:sf(r)}function Xf(r,t,e){return Yl(e,"inputResolution"),[1/e.width*r[0][0]*t.width,1/e.height*r[0][1]*t.width,r[0][3]*t.width,1/e.width*r[1][0]*t.height,1/e.height*r[1][1]*t.height,r[1][3]*t.height,0,0]}function Yl(r,t){le(r.width!==0,function(){return"".concat(t," width cannot be 0.")}),le(r.height!==0,function(){return"".concat(t," height cannot be 0.")})}function Sl(r,t,e){var s=e.rotationVectorStartKeypointIndex,i=e.rotationVectorEndKeypointIndex,o=r.locationData,u=o.relativeKeypoints[s].x*t.width,l=o.relativeKeypoints[s].y*t.height,p=o.relativeKeypoints[i].x*t.width,d=o.relativeKeypoints[i].y*t.height,f=2*Math.sqrt((p-u)*(p-u)+(d-l)*(d-l)),m=function(w,x,C){var I,k=w.locationData,P=C.rotationVectorStartKeypointIndex,O=C.rotationVectorEndKeypointIndex;I=C.rotationVectorTargetAngle?C.rotationVectorTargetAngle:Math.PI*C.rotationVectorTargetAngleDegree/180;var z=k.relativeKeypoints[P].x*x.width,F=k.relativeKeypoints[P].y*x.height,V=k.relativeKeypoints[O].x*x.width,G=k.relativeKeypoints[O].y*x.height;return qf(I-Math.atan2(-(G-F),V-z))}(r,t,e);return{xCenter:u/t.width,yCenter:l/t.height,width:f/t.width,height:f/t.height,rotation:m}}function Yf(r){if(r.length!==16)throw new Error("Array length must be 16 but got ".concat(r.length));return[[r[0],r[1],r[2],r[3]],[r[4],r[5],r[6],r[7]],[r[8],r[9],r[10],r[11]],[r[12],r[13],r[14],r[15]]]}function Cl(r,t,e,s,i,o,u){return r[t][i]*(r[e][o]*r[s][u]-r[e][u]*r[s][o])}function $t(r,t,e){var s=(t+1)%4,i=(t+2)%4,o=(t+3)%4,u=(e+1)%4,l=(e+2)%4,p=(e+3)%4;return Cl(r,s,i,o,u,l,p)+Cl(r,i,o,s,u,l,p)+Cl(r,o,s,i,u,l,p)}function Yp(r,t,e){e===void 0&&(e={ignoreRotation:!1});for(var s=[],i=0,o=r;i<o.length;i++){var u=o[i],l=u.x-.5,p=u.y-.5,d=e.ignoreRotation?0:t.rotation,f=Math.cos(d)*l-Math.sin(d)*p,m=Math.sin(d)*l+Math.cos(d)*p;f=f*t.width+t.xCenter,m=m*t.height+t.yCenter;var w=u.z*t.width,x=Ze({},u);x.x=f,x.y=m,x.z=w,s.push(x)}return s}function Qf(r,t){var e=function(s,i,o,u){var l=i-s,p=u-o,d=p/l;return{scale:d,offset:o-s*d}}(0,255,t[0],t[1]);return tt(function(){return gt(it(r,e.scale),e.offset)})}function Ql(r,t,e){var s,i,o,u,l,p,d,f,m,w,x,C,I,k,P=t.outputTensorSize,O=t.keepAspectRatio,z=t.borderMode,F=t.outputTensorFloatRange,V=hi(r),G=function(K,J){return J?{xCenter:J.xCenter*K.width,yCenter:J.yCenter*K.height,width:J.width*K.width,height:J.height*K.height,rotation:J.rotation}:{xCenter:.5*K.width,yCenter:.5*K.height,width:K.width,height:K.height,rotation:0}}(V,e),M=function(K,J,ne){if(ne===void 0&&(ne=!1),!ne)return{top:0,left:0,right:0,bottom:0};var me=J.height,ce=J.width;Yl(J,"targetSize"),Yl(K,"roi");var ye,Ne,Ae=me/ce,rt=K.height/K.width,nt=0,pt=0;return Ae>rt?(ye=K.width,Ne=K.width*Ae,pt=(1-rt/Ae)/2):(ye=K.height/Ae,Ne=K.height,nt=(1-Ae/rt)/2),K.width=ye,K.height=Ne,{top:pt,left:nt,right:nt,bottom:pt}}(G,P,O),Y=(s=G,i=V.width,o=V.height,u=!1,l=s.width,p=s.height,d=u?-1:1,f=Math.cos(s.rotation),m=Math.sin(s.rotation),w=s.xCenter,x=s.yCenter,C=1/i,I=1/o,(k=new Array(16))[0]=l*f*d*C,k[1]=-p*m*C,k[2]=0,k[3]=(-.5*l*f*d+.5*p*m+w)*C,k[4]=l*m*d*I,k[5]=p*f*I,k[6]=0,k[7]=(-.5*p*f-.5*l*m*d+x)*I,k[8]=0,k[9]=0,k[10]=l*C,k[11]=0,k[12]=0,k[13]=0,k[14]=0,k[15]=1,Yf(k));return{imageTensor:tt(function(){var K=Ic(r),J=Rn(Xf(Y,V,P),[1,8]),ne=z==="zero"?"constant":"nearest",me=cs.transform(ui(fs(K,"float32")),J,"bilinear",ne,0,[P.height,P.width]);return F!=null?Qf(me,F):me}),padding:M,transformationMatrix:Y}}function Qp(r,t,e,s){return s===1?.5*(r+t):r+(t-r)*e/(s-1)}function lL(r){return tt(function(){var t=function(i){return tt(function(){return[mt(i,[0,0,0],[1,-1,1]),mt(i,[0,0,1],[1,-1,-1])]})}(r),e=t[0],s=t[1];return{boxes:Ye(s),logits:Ye(e)}})}function Zf(r){return r!=null&&r.currentTime!=null}function Zp(r){for(var t={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,u=0;u<r.length;++u){var l=r[u];e=Math.min(e,l.x),s=Math.max(s,l.x),i=Math.min(i,l.y),o=Math.max(o,l.y),t.locationData.relativeKeypoints.push({x:l.x,y:l.y})}return t.locationData.relativeBoundingBox={xMin:e,yMin:i,xMax:s,yMax:o,width:s-e,height:o-i},t}function cL(r,t,e,s){return Oe(this,void 0,void 0,function(){var i,o,u,l,p;return Fe(this,function(d){switch(d.label){case 0:return r.sort(function(f,m){return Math.max.apply(Math,m.score)-Math.max.apply(Math,f.score)}),i=Rn(r.map(function(f){return[f.locationData.relativeBoundingBox.yMin,f.locationData.relativeBoundingBox.xMin,f.locationData.relativeBoundingBox.yMax,f.locationData.relativeBoundingBox.xMax]})),o=si(r.map(function(f){return f.score[0]})),[4,cs.nonMaxSuppressionAsync(i,o,t,e)];case 1:return[4,(u=d.sent()).array()];case 2:return l=d.sent(),p=r.filter(function(f,m){return l.indexOf(m)>-1}),Dt([i,o,u]),[2,p]}})})}function Jf(r,t){return r.map(function(e){var s=Ze(Ze({},e),{x:e.x*t.width,y:e.y*t.height});return e.z!=null&&(s.z=e.z*t.width),s})}function hL(r,t,e){return Oe(this,void 0,void 0,function(){var s,i,o,u,l,p,d,f,m,w,x,C,I,k,P,O,z,F,V,G,M,Y,K,J;return Fe(this,function(ne){switch(ne.label){case 0:if(s=Ye(t,[0]),i=s.shape,o=i[0],u=i[1],l=i[2],r.length!==l)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(r.length,", heatmap length: ").concat(l));return p=[],[4,s.buffer()];case 1:for(d=ne.sent(),f=0;f<r.length;f++)if(m=r[f],w=Ze({},m),p.push(w),x=Math.trunc(w.x*u),C=Math.trunc(w.y*o),!(x<0||x>=u||C<0||x>=o)){for(I=Math.trunc((e.kernelSize-1)/2),k=Math.max(0,x-I),P=Math.min(u,x+I+1),O=Math.max(0,C-I),z=Math.min(o,C+I+1),F=0,V=0,G=0,M=0,Y=O;Y<z;++Y)for(K=k;K<P;++K)J=d.get(Y,K,f),F+=J,M=Math.max(M,J),V+=K*J,G+=Y*J;M>=e.minConfidenceToRefine&&F>0&&(w.x=V/u/F,w.y=G/o/F)}return s.dispose(),[2,p]}})})}function Jp(r,t){var e=t.left,s=t.top,i=t.left+t.right,o=t.top+t.bottom;return r.map(function(u){return Ze(Ze({},u),{x:(u.x-e)/(1-i),y:(u.y-s)/(1-o),z:u.z/(1-i)})})}function pL(r,t,e){return Uo()==="webgl"?function(s,i,o){var u=o.combineWithPreviousRatio.toFixed(2),l={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(u,`);

      setOutput(outputValue);
    }
`)},p=ga();return tt(function(){var d=p.compileAndRun(l,[s,i]);return ai().makeTensorFromDataId(d.dataId,d.shape,d.dtype)})}(r,t,e):tt(function(){var s=Er(t,.5),i=Zd(s),o=Er(1,Yd(1,it(i,gt(5.68842,it(i,gt(-.748699,it(i,gt(-57.8051,it(i,gt(291.309,it(i,-624.717)))))))))));return gt(t,it(Er(r,t),it(o,e.combineWithPreviousRatio)))})}function dL(r,t,e){return Oe(this,void 0,void 0,function(){var s,i,o,u,l;return Fe(this,function(p){switch(p.label){case 0:return s=r[0],i=r[1],o=function(d,f,m){return tt(function(){var w,x,C,I;m.reverseOutputOrder?(x=Ye(mt(d,[0,m.boxCoordOffset+0],[-1,1])),w=Ye(mt(d,[0,m.boxCoordOffset+1],[-1,1])),I=Ye(mt(d,[0,m.boxCoordOffset+2],[-1,1])),C=Ye(mt(d,[0,m.boxCoordOffset+3],[-1,1]))):(w=Ye(mt(d,[0,m.boxCoordOffset+0],[-1,1])),x=Ye(mt(d,[0,m.boxCoordOffset+1],[-1,1])),C=Ye(mt(d,[0,m.boxCoordOffset+2],[-1,1])),I=Ye(mt(d,[0,m.boxCoordOffset+3],[-1,1]))),x=gt(it(Et(x,m.xScale),f.w),f.x),w=gt(it(Et(w,m.yScale),f.h),f.y),m.applyExponentialOnBoxSize?(C=it(Dl(Et(C,m.hScale)),f.h),I=it(Dl(Et(I,m.wScale)),f.w)):(C=it(Et(C,m.hScale),f.h),I=it(Et(I,m.wScale),f.h));var k=Er(w,Et(C,2)),P=Er(x,Et(I,2)),O=gt(w,Et(C,2)),z=gt(x,Et(I,2)),F=ds([We(k,[m.numBoxes,1]),We(P,[m.numBoxes,1]),We(O,[m.numBoxes,1]),We(z,[m.numBoxes,1])],1);if(m.numKeypoints)for(var V=0;V<m.numKeypoints;++V){var G=m.keypointCoordOffset+V*m.numValuesPerKeypoint,M=void 0,Y=void 0;m.reverseOutputOrder?(M=Ye(mt(d,[0,G],[-1,1])),Y=Ye(mt(d,[0,G+1],[-1,1]))):(Y=Ye(mt(d,[0,G],[-1,1])),M=Ye(mt(d,[0,G+1],[-1,1])));var K=gt(it(Et(M,m.xScale),f.w),f.x),J=gt(it(Et(Y,m.yScale),f.h),f.y);F=ds([F,We(K,[m.numBoxes,1]),We(J,[m.numBoxes,1])],1)}return F})}(i,t,e),u=tt(function(){var d=s;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(d=Xd(s,-e.scoreClippingThresh,e.scoreClippingThresh)),d=ls(d)):d}),[4,fL(o,u,e)];case 1:return l=p.sent(),Dt([o,u]),[2,l]}})})}function fL(r,t,e){return Oe(this,void 0,void 0,function(){var s,i,o,u,l,p,d,f,m,w,x,C;return Fe(this,function(I){switch(I.label){case 0:return s=[],[4,r.data()];case 1:return i=I.sent(),[4,t.data()];case 2:for(o=I.sent(),u=0;u<e.numBoxes;++u)if(!(e.minScoreThresh!=null&&o[u]<e.minScoreThresh||(l=u*e.numCoords,p=mL(i[l+0],i[l+1],i[l+2],i[l+3],o[u],e.flipVertically,u),(d=p.locationData.relativeBoundingBox).width<0||d.height<0))){if(e.numKeypoints>0)for((f=p.locationData).relativeKeypoints=[],m=e.numKeypoints*e.numValuesPerKeypoint,w=0;w<m;w+=e.numValuesPerKeypoint)x=l+e.keypointCoordOffset+w,C={x:i[x+0],y:e.flipVertically?1-i[x+1]:i[x+1]},f.relativeKeypoints.push(C);s.push(p)}return[2,s]}})})}function mL(r,t,e,s,i,o,u){return{score:[i],ind:u,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-e:r,xMax:s,yMax:o?1-r:e,width:s-t,height:e-r}}}}function gL(r,t){return r==="none"?t:function(e){return 1/(1+Math.exp(-e))}(t)}function ed(r,t,e,s){return Oe(this,void 0,void 0,function(){var i,o,u,l,p,d,f,m;return Fe(this,function(w){switch(w.label){case 0:return e=e||t.flipHorizontally||!1,s=s||t.flipVertically||!1,i=r.size,o=i/t.numLandmarks,[4,r.data()];case 1:for(u=w.sent(),l=[],p=0;p<t.numLandmarks;++p)d=p*o,(m={x:0,y:0}).x=e?t.inputImageWidth-u[d]:u[d],o>1&&(m.y=s?t.inputImageHeight-u[d+1]:u[d+1]),o>2&&(m.z=u[d+2]),o>3&&(m.score=gL(t.visibilityActivation,u[d+3])),l.push(m);for(f=0;f<l.length;++f)(m=l[f]).x=m.x/t.inputImageWidth,m.y=m.y/t.inputImageHeight,m.z=m.z/t.inputImageWidth/(t.normalizeZ||1);return[2,l]}})})}function td(r,t,e){var s=r.width,i=r.height,o=r.rotation;if(e.rotation==null&&e.rotationDegree==null||(o=function(d,f){return f.rotation!=null?d+=f.rotation:f.rotationDegree!=null&&(d+=Math.PI*f.rotationDegree/180),qf(d)}(o,e)),o===0)r.xCenter=r.xCenter+s*e.shiftX,r.yCenter=r.yCenter+i*e.shiftY;else{var u=(t.width*s*e.shiftX*Math.cos(o)-t.height*i*e.shiftY*Math.sin(o))/t.width,l=(t.width*s*e.shiftX*Math.sin(o)+t.height*i*e.shiftY*Math.cos(o))/t.height;r.xCenter=r.xCenter+u,r.yCenter=r.yCenter+l}{var p=Math.max(s*t.width,i*t.height);s=p/t.width,i=p/t.height}return r.width=s*e.scaleX,r.height=i*e.scaleY,r}function yL(r,t){return r.map(function(e){var s=Ze(Ze({},e),{x:e.x/t.width,y:e.y/t.height});return e.z!=null&&(e.z=e.z/t.width),s})}var Tn=function(){function r(t){this.alpha=t,this.initialized=!1}return r.prototype.apply=function(t,e){var s;return this.initialized?s=e==null?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(s=t,this.initialized=!0),this.rawValue=t,this.storedValue=s,s},r.prototype.applyWithAlpha=function(t,e,s){return this.alpha=e,this.apply(t,s)},r.prototype.hasLastRawValue=function(){return this.initialized},r.prototype.lastRawValue=function(){return this.rawValue},r.prototype.reset=function(){this.initialized=!1},r}(),Nl=function(){function r(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new Tn(this.getAlpha(this.minCutOff)),this.dx=new Tn(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return r.prototype.apply=function(t,e,s){if(t==null)return t;var i=Math.trunc(e);if(this.lastTimestamp>=i)return t;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var o=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*s*this.frequency:0,u=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),l=this.minCutOff+this.beta*Math.abs(u),p=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(u):null;return this.x.applyWithAlpha(t,this.getAlpha(l),p)},r.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},r}(),Zl=function(){function r(t){this.config=t}return r.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;this.initializeFiltersIfEmpty(t);var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return us([],t,!0);o=1/s}return t.map(function(u,l){var p=Ze(Ze({},u),{x:i.xFilters[l].apply(u.x,e,o),y:i.yFilters[l].apply(u.y,e,o)});return u.z!=null&&(p.z=i.zFilters[l].apply(u.z,e,o)),p})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Nl(e.config)}),this.yFilters=t.map(function(s){return new Nl(e.config)}),this.zFilters=t.map(function(s){return new Nl(e.config)}))},r}(),Il=function(){function r(t){this.config=t,this.window=[],this.lowPassFilter=new Tn(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return r.prototype.apply=function(t,e,s){if(t==null)return t;var i,o=Math.trunc(e);if(this.lastTimestamp>=o)return t;if(this.lastTimestamp===-1)i=1;else{for(var u=t*s-this.lastValue*this.lastValueScale,l=o-this.lastTimestamp,p=u,d=l,f=(1+this.window.length)*(1e6/30),m=0,w=this.window;m<w.length;m++){var x=w[m];if(d+x.duration>f)break;p+=x.distance,d+=x.duration}var C=p/(1e-6*d);i=1-1/(1+this.config.velocityScale*Math.abs(C)),this.window.unshift({distance:u,duration:l}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=s,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(t,i)},r}(),wL=function(){function r(t){this.config=t}return r.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return us([],t,!0);o=1/s}return this.initializeFiltersIfEmpty(t),t.map(function(u,l){var p=Ze(Ze({},u),{x:i.xFilters[l].apply(u.x,e,o),y:i.yFilters[l].apply(u.y,e,o)});return u.z!=null&&(p.z=i.zFilters[l].apply(u.z,e,o)),p})},r.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},r.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Il(e.config)}),this.yFilters=t.map(function(s){return new Il(e.config)}),this.zFilters=t.map(function(s){return new Il(e.config)}))},r}(),kl=function(){function r(t){if(t.velocityFilter!=null)this.keypointsFilter=new wL(t.velocityFilter);else{if(t.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new Zl(t.oneEuroFilter)}}return r.prototype.apply=function(t,e,s,i,o){if(i===void 0&&(i=!1),t==null)return this.keypointsFilter.reset(),null;var u=o!=null?function(d,f){return(d.width*f.width+d.height*f.height)/2}(o,s):1,l=i?Jf(t,s):t,p=this.keypointsFilter.apply(l,e,u);return i?yL(p,s):p},r}(),rd=function(){function r(t){this.alpha=t.alpha}return r.prototype.apply=function(t){var e=this;if(t==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map(function(l){return new Tn(e.alpha)}));for(var s=[],i=0;i<t.length;++i){var o=t[i],u=Ze({},o);u.score=this.visibilityFilters[i].apply(o.score),s.push(u)}return s},r}(),vL={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},ni={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},bL={maxPoses:1,flipHorizontal:!1},xL={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},SL=.3,nd={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},CL={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},NL={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},IL={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},kL={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},_L={kernelSize:7,minConfidenceToRefine:.5},sd={alpha:.1},TL={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},RL={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},AL={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},PL={activation:"none"},$L={combineWithPreviousRatio:.7},EL=function(){function r(t){this.mask=t}return r.prototype.toCanvasImageSource=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,Gf(this.mask)]})})},r.prototype.toImageData=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,jf(this.mask)]})})},r.prototype.toTensor=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,this.mask]})})},r.prototype.getUnderlyingType=function(){return"tensor"},r}();function DL(r){return Kf(r),"person"}var OL=function(){function r(t,e,s,i,o,u){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=s,this.enableSegmentation=i,this.smoothSegmentation=o,this.modelType=u,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(m){m.reduceBoxesInLowestLayer==null&&(m.reduceBoxesInLowestLayer=!1),m.interpolatedScaleAspectRatio==null&&(m.interpolatedScaleAspectRatio=1),m.fixedAnchorSize==null&&(m.fixedAnchorSize=!1);for(var w=[],x=0;x<m.numLayers;){for(var C=[],I=[],k=[],P=[],O=x;O<m.strides.length&&m.strides[O]===m.strides[x];){var z=Qp(m.minScale,m.maxScale,O,m.strides.length);if(O===0&&m.reduceBoxesInLowestLayer)k.push(1),k.push(2),k.push(.5),P.push(.1),P.push(z),P.push(z);else{for(var F=0;F<m.aspectRatios.length;++F)k.push(m.aspectRatios[F]),P.push(z);if(m.interpolatedScaleAspectRatio>0){var V=O===m.strides.length-1?1:Qp(m.minScale,m.maxScale,O+1,m.strides.length);P.push(Math.sqrt(z*V)),k.push(m.interpolatedScaleAspectRatio)}}O++}for(var G=0;G<k.length;++G){var M=Math.sqrt(k[G]);C.push(P[G]/M),I.push(P[G]*M)}var Y=0,K=0;if(m.featureMapHeight.length>0)Y=m.featureMapHeight[x],K=m.featureMapWidth[x];else{var J=m.strides[x];Y=Math.ceil(m.inputSizeHeight/J),K=Math.ceil(m.inputSizeWidth/J)}for(var ne=0;ne<Y;++ne)for(var me=0;me<K;++me)for(var ce=0;ce<C.length;++ce){var ye={xCenter:(me+m.anchorOffsetX)/K,yCenter:(ne+m.anchorOffsetY)/Y,width:0,height:0};m.fixedAnchorSize?(ye.width=1,ye.height=1):(ye.width=I[ce],ye.height=C[ce]),w.push(ye)}x=O}return w}(vL);var l=si(this.anchors.map(function(m){return m.width})),p=si(this.anchors.map(function(m){return m.height})),d=si(this.anchors.map(function(m){return m.xCenter})),f=si(this.anchors.map(function(m){return m.yCenter}));this.anchorTensor={x:d,y:f,w:l,h:p},this.prevFilteredSegmentationMask=this.enableSegmentation?Rn([],[0,0]):null}return r.prototype.estimatePoses=function(t,e,s){return Oe(this,void 0,void 0,function(){var i,o,u,l,p,d,f,m,w,x,C,I,k,P,O,z,F,V,G,M,Y,K,J;return Fe(this,function(ne){switch(ne.label){case 0:return i=function(me){var ce;if((ce=me==null?bL:Ze({},me)).maxPoses==null&&(ce.maxPoses=1),ce.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(ce.maxPoses,". Should be > 0."));if(ce.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return ce}(e),t==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=s!=null?1e3*s:Zf(t)?1e6*t.currentTime:null,o=hi(t),u=tt(function(){return fs(Ic(t),"float32")}),(l=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(u)]);case 1:if((p=ne.sent()).length===0)return this.reset(),u.dispose(),[2,[]];d=p[0],l=this.poseDetectionToRoi(d,o),ne.label=2;case 2:return[4,this.poseLandmarksByRoi(l,u)];case 3:return f=ne.sent(),u.dispose(),f==null?(this.reset(),[2,[]]):(m=f.landmarks,w=f.auxiliaryLandmarks,x=f.poseScore,C=f.worldLandmarks,I=f.segmentationMask,k=this.poseLandmarkFiltering(m,w,C,o),P=k.actualLandmarksFiltered,O=k.auxiliaryLandmarksFiltered,z=k.actualWorldLandmarksFiltered,F=this.poseLandmarksToRoi(O,o),this.regionOfInterest=F,V=this.smoothSegmentation&&I!=null?this.poseSegmentationFiltering(I):I,(G=P!=null?Jf(P,o):null)!=null&&G.forEach(function(me,ce){me.name=va[ce]}),(M=z)!=null&&M.forEach(function(me,ce){me.name=va[ce]}),Y={score:x,keypoints:G,keypoints3D:M},V!==null&&(K=tt(function(){var me=ui(V,2),ce=An(me,[[0,0],[0,0],[0,1]]);return Qd(ce,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Dt(V),J={maskValueToLabel:DL,mask:new EL(K)},Y.segmentation=J),[2,[Y]])}})})},r.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return e.size===0?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=pL(e,t,$L),Dt(t)),Dt(e),this.prevFilteredSegmentationMask},r.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Dt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},r.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Dt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Rn([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},r.prototype.detectPose=function(t){return Oe(this,void 0,void 0,function(){var e,s,i,o,u,l,p,d,f,m;return Fe(this,function(w){switch(w.label){case 0:return e=Ql(t,CL),s=e.imageTensor,i=e.padding,o=this.detectorModel.predict(s),u=lL(o),l=u.boxes,[4,dL([p=u.logits,l],this.anchorTensor,xL)];case 1:return(d=w.sent()).length===0?(Dt([s,o,p,l]),[2,d]):[4,cL(d,this.maxPoses,SL)];case 2:return f=w.sent(),m=function(x,C){x===void 0&&(x=[]);for(var I=C.left,k=C.top,P=C.left+C.right,O=C.top+C.bottom,z=0;z<x.length;z++){var F=x[z],V=F.locationData.relativeBoundingBox,G=(V.xMin-I)/(1-P),M=(V.yMin-k)/(1-O),Y=V.width/(1-P),K=V.height/(1-O);V.xMin=G,V.yMin=M,V.width=Y,V.height=K,V.xMax=G+Y,V.yMax=M+K;var J=F.locationData.relativeKeypoints;J&&J.forEach(function(ne){var me=(ne.x-I)/(1-P),ce=(ne.y-k)/(1-O);ne.x=me,ne.y=ce})}return x}(f,i),Dt([s,o,p,l]),[2,m]}})})},r.prototype.poseDetectionToRoi=function(t,e){return td(Sl(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,nd)},r.prototype.poseLandmarksByRoi=function(t,e){return Oe(this,void 0,void 0,function(){var s,i,o,u,l,p,d,f,m,w,x,C,I,k;return Fe(this,function(P){switch(P.label){case 0:if(s=hi(e),i=Ql(e,NL,t),o=i.imageTensor,u=i.padding,l=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return p=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&p.push("activation_segmentation"),d=this.landmarkModel.execute(o,p),[4,this.tensorsToPoseLandmarksAndSegmentation(d)];case 1:return(f=P.sent())==null?(Dt(d),Dt(o),[2,null]):(m=f.landmarks,w=f.auxiliaryLandmarks,x=f.poseScore,C=f.worldLandmarks,I=f.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,t,u,l,m,w,C,I)]);case 2:return k=P.sent(),Dt(d),Dt(o),[2,Ze({poseScore:x},k)]}})})},r.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,s,i,o,u,l,p){return Oe(this,void 0,void 0,function(){var d,f,m,w,x,C;return Fe(this,function(I){return d=Jp(o,s),f=Jp(u,s),m=Yp(d,e),w=Yp(f,e),x=function(k,P){for(var O=[],z=0,F=k;z<F.length;z++){var V=F[z],G=V.x,M=V.y,Y=P.rotation,K=Math.cos(Y)*G-Math.sin(Y)*M,J=Math.sin(Y)*G+Math.cos(Y)*M,ne=Ze({},V);ne.x=K,ne.y=J,O.push(ne)}return O}(l,e),C=null,this.enableSegmentation&&(C=tt(function(){var k=p.shape,P=k[0],O=k[1],z=function(G){var M=Yf(new Array(16).fill(0));M[0][0]=$t(G,0,0),M[1][0]=-$t(G,0,1),M[2][0]=$t(G,0,2),M[3][0]=-$t(G,0,3),M[0][2]=$t(G,2,0),M[1][2]=-$t(G,2,1),M[2][2]=$t(G,2,2),M[3][2]=-$t(G,2,3),M[0][1]=-$t(G,1,0),M[1][1]=$t(G,1,1),M[2][1]=-$t(G,1,2),M[3][1]=$t(G,1,3),M[0][3]=-$t(G,3,0),M[1][3]=$t(G,3,1),M[2][3]=-$t(G,3,2),M[3][3]=$t(G,3,3);for(var Y=G[0][0]*M[0][0]+G[1][0]*M[0][1]+G[2][0]*M[0][2]+G[3][0]*M[0][3],K=0;K<M.length;K++)for(var J=0;J<M.length;J++)M[K][J]/=Y;return M}(i),F=Rn(Xf(z,{width:O,height:P},t),[1,8]),V=[1,P,O,1];return Ye(cs.transform(We(p,V),F,"bilinear","constant",0,[t.height,t.width]),[0,3])}),Dt(p)),[2,{landmarks:m,auxiliaryLandmarks:w,worldLandmarks:x,segmentationMask:C}]})})},r.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return Oe(this,void 0,void 0,function(){var e,s,i,o,u,l,p,d,f,m,w,x,C;return Fe(this,function(I){switch(I.label){case 0:return e=t[0],s=t[1],i=t[2],o=t[3],u=this.enableSegmentation?t[4]:null,[4,s.data()];case 1:return(l=I.sent()[0])<.5?[2,null]:[4,ed(e,IL)];case 2:return[4,hL(I.sent(),i,_L)];case 3:return p=I.sent(),d=p.slice(0,33),f=p.slice(33,35),[4,ed(o,kL)];case 4:return m=I.sent(),w=m.slice(0,33),x=function(k,P,O){for(var z=[],F=0;F<k.length;F++){var V=Ze({},P[F]);V.score=k[F].score,z.push(V)}return z}(d,w),C=this.enableSegmentation?function(k,P,O){return tt(function(){var z=Ye(k,[0]),F=z.shape[2];if(F===1){var V=z;switch(P.activation){case"none":break;case"sigmoid":V=ls(V);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(P.activation,")"))}var G=V;return Ye(G,[2])}throw new Error("Unsupported number of tensor channels ".concat(F))})}(u,PL):null,[2,{landmarks:d,auxiliaryLandmarks:f,poseScore:l,worldLandmarks:x,segmentationMask:C}]}})})},r.prototype.poseLandmarksToRoi=function(t,e){return td(Sl(Zp(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,nd)},r.prototype.poseLandmarkFiltering=function(t,e,s,i){var o,u,l;if(this.timestamp!=null&&this.enableSmoothing){var p=Sl(Zp(e),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new rd(sd)),o=this.visibilitySmoothingFilterActual.apply(t),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new rd(sd)),u=this.visibilitySmoothingFilterAuxiliary.apply(e),l=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new kl(TL)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,i,!0,p),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new kl(RL)),u=this.landmarksSmoothingFilterAuxiliary.apply(u,this.timestamp,i,!0,p),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new kl(AL)),l=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else o=t,u=e,l=s;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:u,actualWorldLandmarksFiltered:l}},r}();function FL(r){return Oe(this,void 0,void 0,function(){var t,e,s,i,o,u;return Fe(this,function(l){switch(l.label){case 0:return t=function(p){var d=Ze({},p??ni);if(d.enableSmoothing==null&&(d.enableSmoothing=ni.enableSmoothing),d.enableSegmentation==null&&(d.enableSegmentation=ni.enableSegmentation),d.smoothSegmentation==null&&(d.smoothSegmentation=ni.smoothSegmentation),d.modelType==null&&(d.modelType=ni.modelType),d.detectorModelUrl==null&&(d.detectorModelUrl=ni.detectorModelUrl),d.landmarkModelUrl==null)switch(d.modelType){case"lite":d.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":d.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:d.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return d}(r),e=typeof t.detectorModelUrl=="string"&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof t.landmarkModelUrl=="string"&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([li(t.detectorModelUrl,{fromTFHub:e}),li(t.landmarkModelUrl,{fromTFHub:s})])];case 1:return i=l.sent(),o=i[0],u=i[1],[2,new OL(o,u,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var ps,Dr,em=function(){function r(t){(function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(e.keypointTrackerParams!==void 0){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,i=e.keypointTrackerParams.keypointFalloff;s<i.length;s++){var o=i[s];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return r.prototype.apply=function(t,e){this.filterOldTracks(e);var s=this.computeSimilarity(t);return this.assignTracks(t,s,e),this.updateTracks(e),t},r.prototype.getTracks=function(){return this.tracks.slice()},r.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(t){return t.id}))},r.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter(function(s){return t-s.lastTimestamp<=e.maxAge})},r.prototype.assignTracks=function(t,e,s){for(var i=Array.from(Array(e[0].length).keys()),o=[],u=0,l=Array.from(Array(t.length).keys());u<l.length;u++){var p=l[u];if(i.length!==0){for(var d=-1,f=-1,m=0,w=i;m<w.length;m++){var x=w[m],C=e[p][x];C>=this.minSimilarity&&C>f&&(d=x,f=C)}if(d>=0){var I=this.tracks[d];I=Object.assign(I,this.createTrack(t[p],s,I.id)),t[p].id=I.id;var k=i.indexOf(d);i.splice(k,1)}else o.push(p)}else o.push(p)}for(var P=0,O=o;P<O.length;P++){p=O[P];var z=this.createTrack(t[p],s);this.tracks.push(z),t[p].id=z.id}},r.prototype.updateTracks=function(t){this.tracks.sort(function(e,s){return s.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},r.prototype.createTrack=function(t,e,s){var i={id:s||this.nextTrackID(),lastTimestamp:e,keypoints:us([],t.keypoints,!0).map(function(o){return Ze({},o)})};return t.box!==void 0&&(i.box=Ze({},t.box)),i},r.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},r.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter(function(s){return!t.includes(s.id)})},r.prototype.reset=function(){this.tracks=[]},r}(),LL=function(r){function t(e){return r.call(this,e)||this}return Hf(t,r),t.prototype.computeSimilarity=function(e){var s=this;return e.length===0||this.tracks.length===0?[[]]:e.map(function(i){return s.tracks.map(function(o){return s.iou(i,o)})})},t.prototype.iou=function(e,s){var i=Math.max(e.box.xMin,s.box.xMin),o=Math.max(e.box.yMin,s.box.yMin),u=Math.min(e.box.xMax,s.box.xMax),l=Math.min(e.box.yMax,s.box.yMax);if(i>=u||o>=l)return 0;var p=(u-i)*(l-o);return p/(e.box.width*e.box.height+s.box.width*s.box.height-p)},t}(em),zL=function(r){function t(e){var s=r.call(this,e)||this;return s.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=e.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,s}return Hf(t,r),t.prototype.computeSimilarity=function(e){if(e.length===0||this.tracks.length===0)return[[]];for(var s=[],i=0,o=e;i<o.length;i++){for(var u=o[i],l=[],p=0,d=this.tracks;p<d.length;p++){var f=d[p];l.push(this.oks(u,f))}s.push(l)}return s},t.prototype.oks=function(e,s){for(var i=this.area(s.keypoints)+1e-6,o=0,u=0,l=0;l<e.keypoints.length;++l){var p=e.keypoints[l],d=s.keypoints[l];if(!(p.score<this.keypointThreshold||d.score<this.keypointThreshold)){u+=1;var f=Math.pow(p.x-d.x,2)+Math.pow(p.y-d.y,2),m=2*this.keypointFalloff[l];o+=Math.exp(-1*f/(2*i*Math.pow(m,2)))}}return u<this.minNumKeyoints?0:o/u},t.prototype.area=function(e){var s=this,i=e.filter(function(p){return p.score>s.keypointThreshold}),o=Math.min.apply(Math,us([1],i.map(function(p){return p.x}),!1)),u=Math.max.apply(Math,us([0],i.map(function(p){return p.x}),!1)),l=Math.min.apply(Math,us([1],i.map(function(p){return p.y}),!1));return(u-o)*(Math.max.apply(Math,us([0],i.map(function(p){return p.y}),!1))-l)},t}(em);function BL(r){switch(r){case Dr.BlazePose:return va.reduce(function(t,e,s){return t[e]=s,t},{});case Dr.PoseNet:case Dr.MoveNet:return Lr.reduce(function(t,e,s){return t[e]=s,t},{});default:throw new Error("Model ".concat(r," is not supported."))}}(function(r){r.Keypoint="keypoint",r.BoundingBox="boundingBox"})(ps||(ps={})),function(r){r.MoveNet="MoveNet",r.BlazePose="BlazePose",r.PoseNet="PoseNet"}(Dr||(Dr={}));var id=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],tm={modelType:"SinglePose.Lightning",enableSmoothing:!0},ad={},od={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},_l={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},ud={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function WL(r,t,e,s){for(var i={},o=0,u=Lr;o<u.length;o++){var l=u[o];i[l]=[t[e[l]].y*s.height,t[e[l]].x*s.width]}if(function(O,z){return(O[z.left_hip].score>.2||O[z.right_hip].score>.2)&&(O[z.left_shoulder].score>.2||O[z.right_shoulder].score>.2)}(t,e)){var p=(i.left_hip[0]+i.right_hip[0])/2,d=(i.left_hip[1]+i.right_hip[1])/2,f=function(O,z,F,V,G){for(var M=["left_shoulder","right_shoulder","left_hip","right_hip"],Y=0,K=0,J=0;J<M.length;J++)(Ne=Math.abs(V-F[M[J]][0]))>Y&&(Y=Ne),(Ae=Math.abs(G-F[M[J]][1]))>K&&(K=Ae);for(var ne=0,me=0,ce=0,ye=Object.keys(F);ce<ye.length;ce++){var Ne,Ae,rt=ye[ce];O[z[rt]].score<.2||((Ne=Math.abs(V-F[rt][0]))>ne&&(ne=Ne),(Ae=Math.abs(G-F[rt][1]))>me&&(me=Ae))}return[Y,K,ne,me]}(t,e,i,p,d),m=f[0],w=f[1],x=f[2],C=f[3],I=Math.max(1.9*w,1.9*m,1.2*x,1.2*C),k=[p-(I=Math.min(I,Math.max(d,s.width-d,p,s.height-p))),d-I];if(I>Math.max(s.width,s.height)/2)return Jl(r==null,s);var P=2*I;return{yMin:k[0]/s.height,xMin:k[1]/s.width,yMax:(k[0]+P)/s.height,xMax:(k[1]+P)/s.width,height:(k[0]+P)/s.height-k[0]/s.height,width:(k[1]+P)/s.width-k[1]/s.width}}return Jl(r==null,s)}function Jl(r,t){var e,s,i,o;return r?t.width>t.height?(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width):(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):t.width>t.height?(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:o,yMax:i+e,xMax:o+s,height:e,width:s}}function VL(r){var t,e=r==null?tm:Ze({},r);if(e.modelType==null)e.modelType="SinglePose.Lightning";else if(id.indexOf(e.modelType)<0)throw new Error("Invalid architecture ".concat(e.modelType,". ")+"Should be one of ".concat(id));if(e.enableSmoothing==null&&(e.enableSmoothing=!0),e.minPoseScore!=null&&(e.minPoseScore<0||e.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(e.multiPoseMaxDimension!=null&&(e.multiPoseMaxDimension%32!=0||e.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(e.modelType==="MultiPose.Lightning"&&e.enableTracking==null&&(e.enableTracking=!0),e.modelType==="MultiPose.Lightning"&&e.enableTracking===!0)if(e.trackerType==null&&(e.trackerType=ps.BoundingBox),e.trackerType===ps.Keypoint)e.trackerConfig!=null?e.trackerConfig=function(s){var i=ld(_l,s);return i.keypointTrackerParams=Ze({},_l.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),i}(e.trackerConfig):e.trackerConfig=_l;else{if(e.trackerType!==ps.BoundingBox)throw new Error("Tracker type not supported by MoveNet");e.trackerConfig!=null?e.trackerConfig=(t=e.trackerConfig,ld(ud,t)):e.trackerConfig=ud}return e}function ld(r,t){var e={maxTracks:r.maxTracks,maxAge:r.maxAge,minSimilarity:r.minSimilarity};return t.maxTracks!=null&&(e.maxTracks=t.maxTracks),t.maxAge!=null&&(e.maxAge=t.maxAge),t.minSimilarity!=null&&(e.minSimilarity=t.minSimilarity),e}var UL=function(){function r(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=BL(Dr.MoveNet),e.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):e.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=e.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Zl(od),this.cropRegionFilterYMin=new Tn(.9),this.cropRegionFilterXMin=new Tn(.9),this.cropRegionFilterYMax=new Tn(.9),this.cropRegionFilterXMax=new Tn(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===ps.Keypoint?this.tracker=new zL(e.trackerConfig):e.trackerType===ps.BoundingBox&&(this.tracker=new LL(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return r.prototype.runSinglePersonPoseModel=function(t){return Oe(this,void 0,void 0,function(){var e,s,i,o,u;return Fe(this,function(l){switch(l.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==4||e.shape[0]!==1||e.shape[1]!==1||e.shape[2]!==17||e.shape[3]!==3)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Uo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=l.sent(),l.label=3;case 3:for(e.dispose(),i={keypoints:[],score:0},o=0,u=0;u<17;++u)i.keypoints[u]={y:s[3*u],x:s[3*u+1],score:s[3*u+2]},i.keypoints[u].score>.2&&(++o,i.score+=i.keypoints[u].score);return o>0&&(i.score/=o),[2,i]}})})},r.prototype.runMultiPersonPoseModel=function(t){return Oe(this,void 0,void 0,function(){var e,s,i,o,u,l,p,d;return Fe(this,function(f){switch(f.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==3||e.shape[0]!==1||e.shape[2]!==56)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Uo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=f.sent(),f.label=3;case 3:for(e.dispose(),i=[],o=s.length/56,u=0;u<o;++u)for(i[u]={keypoints:[]},l=56*u+51,i[u].box={yMin:s[l],xMin:s[l+1],yMax:s[l+2],xMax:s[l+3],width:s[l+3]-s[l+1],height:s[l+2]-s[l]},p=56*u+55,i[u].score=s[p],i[u].keypoints=[],d=0;d<17;++d)i[u].keypoints[d]={y:s[56*u+3*d],x:s[56*u+3*d+1],score:s[56*u+3*d+2]};return[2,i]}})})},r.prototype.estimatePoses=function(t,e,s){return e===void 0&&(e=ad),Oe(this,void 0,void 0,function(){var i,o,u,l,p,d;return Fe(this,function(f){switch(f.label){case 0:return e=function(m){return m==null?ad:Ze({},m)}(e),t==null?(this.reset(),[2,[]]):(s==null?Zf(t)&&(s=1e6*t.currentTime):s*=1e3,i=Ic(t),o=hi(i),u=ui(i,0),t instanceof Or||i.dispose(),l=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(u,o,s)]);case 1:return l=f.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(u,o,s)];case 3:l=f.sent(),f.label=4;case 4:for(p=0;p<l.length;++p)for(d=0;d<l[p].keypoints.length;++d)l[p].keypoints[d].name=Lr[d],l[p].keypoints[d].y*=o.height,l[p].keypoints[d].x*=o.width;return[2,l]}})})},r.prototype.estimateSinglePose=function(t,e,s){return Oe(this,void 0,void 0,function(){var i,o,u,l,p=this;return Fe(this,function(d){switch(d.label){case 0:return this.cropRegion||(this.cropRegion=Jl(this.cropRegion==null,e)),i=tt(function(){var f=Rn([[p.cropRegion.yMin,p.cropRegion.xMin,p.cropRegion.yMax,p.cropRegion.xMax]]),m=lc([1],"int32"),w=[p.modelInputResolution.height,p.modelInputResolution.width];return fs(cs.cropAndResize(t,f,m,w,"bilinear",0),"int32")}),t.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(o=d.sent(),i.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(u=0;u<o.keypoints.length;++u)o.keypoints[u].y=this.cropRegion.yMin+o.keypoints[u].y*this.cropRegion.height,o.keypoints[u].x=this.cropRegion.xMin+o.keypoints[u].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,s,1)),l=WL(this.cropRegion,o.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(l),[2,[o]]}})})},r.prototype.estimateMultiplePoses=function(t,e,s){return Oe(this,void 0,void 0,function(){var i,o,u,l,p,d,f,m,w,x,C,I=this;return Fe(this,function(k){switch(k.label){case 0:return e.width>e.height?(o=this.multiPoseMaxDimension,u=Math.round(this.multiPoseMaxDimension*e.height/e.width),i=cs.resizeBilinear(t,[u,o]),p=o,d=32*Math.ceil(u/32),l=An(i,[[0,0],[0,d-u],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*e.width/e.height),u=this.multiPoseMaxDimension,i=cs.resizeBilinear(t,[u,o]),p=32*Math.ceil(o/32),d=u,l=An(i,[[0,0],[0,0],[0,p-o],[0,0]])),i.dispose(),t.dispose(),f=fs(l,"int32"),l.dispose(),[4,this.runMultiPersonPoseModel(f)];case 1:for(m=k.sent(),f.dispose(),m=m.filter(function(P){return P.score>=I.minPoseScore}),x=0;x<m.length;++x)for(w=0;w<m[x].keypoints.length;++w)m[x].keypoints[w].y*=d/u,m[x].keypoints[w].x*=p/o;if(this.enableTracking&&(this.tracker.apply(m,s),this.enableSmoothing)){for(x=0;x<m.length;++x)this.keypointFilterMap.has(m[x].id)||this.keypointFilterMap.set(m[x].id,new Zl(od)),m[x].keypoints=this.keypointFilterMap.get(m[x].id).apply(m[x].keypoints,s,1);C=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(P,O){C.has(O)||I.keypointFilterMap.delete(O)})}return[2,m]}})})},r.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),s=this.cropRegionFilterXMin.apply(t.xMin),i=this.cropRegionFilterYMax.apply(t.yMax),o=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:s,yMax:i,xMax:o,height:i-e,width:o-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},r.prototype.dispose=function(){this.moveNetModel.dispose()},r.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},r.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},r}();function ML(r){return r===void 0&&(r=tm),Oe(this,void 0,void 0,function(){var t,e,s,i;return Fe(this,function(o){switch(o.label){case 0:return t=VL(r),s=!0,t.modelUrl?(s=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,li(t.modelUrl,{fromTFHub:s})]):[3,2];case 1:return e=o.sent(),[3,4];case 2:return i=void 0,t.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":t.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":t.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,li(i,{fromTFHub:s})];case 3:e=o.sent(),o.label=4;case 4:return Uo()==="webgl"&&Qe().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new UL(e,t)]}})})}var cd={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},hd=["MobileNetV1","ResNet50"],pd={MobileNetV1:[8,16],ResNet50:[16]},HL=[8,16,32],dd={MobileNetV1:[.5,.75,1],ResNet50:[1]},fd=[1,2,4],md={maxPoses:1,flipHorizontal:!1},GL={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},jL=[-123.15,-115.9,-103.06];function Tl(r){return Math.floor(r/2)}var KL=function(){function r(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return r.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},r.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},r.prototype.empty=function(){return this.numberOfElements===-1},r.prototype.size=function(){return this.numberOfElements+1},r.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},r.prototype.max=function(){return this.priorityQueue[0]},r.prototype.swim=function(t){for(;t>0&&this.less(Tl(t),t);)this.exchange(t,Tl(t)),t=Tl(t)},r.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},r.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},r.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},r.prototype.exchange=function(t,e){var s=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=s},r}();function qL(r,t,e,s,i,o){for(var u=o.shape,l=u[0],p=u[1],d=!0,f=Math.max(e-i,0),m=Math.min(e+i+1,l),w=f;w<m;++w){for(var x=Math.max(s-i,0),C=Math.min(s+i+1,p),I=x;I<C;++I)if(o.get(w,I,r)>t){d=!1;break}if(!d)break}return d}function XL(r){return Oe(this,void 0,void 0,function(){return Fe(this,function(t){return[2,Promise.all(r.map(function(e){return e.buffer()}))]})})}function rm(r,t,e,s){return{y:s.get(r,t,e),x:s.get(r,t,e+17)}}function nm(r,t,e){var s=rm(r.heatmapY,r.heatmapX,r.id,e),i=s.y,o=s.x;return{x:r.heatmapX*t+o,y:r.heatmapY*t+i}}function sm(r,t,e,s){var i=e.x,o=e.y;return r.some(function(u){var l,p,d,f,m,w,x=u.keypoints;return l=o,p=i,d=x[s].y,f=x[s].x,(m=d-l)*m+(w=f-p)*w<=t})}var gd=Lr.reduce(function(r,t,e){return r[t]=e,r},{}),im=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(r){var t=r[0],e=r[1];return[gd[t],gd[e]]}),Rl=im.map(function(r){return r[1]}),yd=im.map(function(r){return r[0]});function wd(r,t,e){return r<t?t:r>e?e:r}function Al(r,t,e,s){return{y:wd(Math.round(r.y/t),0,e-1),x:wd(Math.round(r.x/t),0,s-1)}}function vd(r,t){return{x:r.x+t.x,y:r.y+t.y}}function bd(r,t,e,s,i,o,u,l){l===void 0&&(l=2);for(var p=s.shape,d=p[0],f=p[1],m={y:t.y,x:t.x},w=vd(m,function(O,z,F){var V=F.shape[2]/2;return{y:F.get(z.y,z.x,O),x:F.get(z.y,z.x,V+O)}}(r,Al(m,o,d,f),u)),x=0;x<l;x++){var C=Al(w,o,d,f),I=rm(C.y,C.x,e,i);w=vd({x:C.x*o,y:C.y*o},{x:I.x,y:I.y})}var k=Al(w,o,d,f),P=s.get(k.y,k.x,e);return{y:w.y,x:w.x,name:Lr[e],score:P}}function YL(r,t,e,s,i,o){var u=t.shape[2],l=Rl.length,p=new Array(u),d=r.part,f=r.score,m=nm(d,s,e);p[d.id]={score:f,name:Lr[d.id],y:m.y,x:m.x};for(var w=l-1;w>=0;--w){var x=Rl[w],C=yd[w];p[x]&&!p[C]&&(p[C]=bd(w,p[x],C,t,e,s,o))}for(w=0;w<l;++w)x=yd[w],C=Rl[w],p[x]&&!p[C]&&(p[C]=bd(w,p[x],C,t,e,s,i));return p}function QL(r,t,e){return e.reduce(function(s,i,o){var u=i.y,l=i.x,p=i.score;return sm(r,t,{y:u,x:l},o)||(s+=p),s},0)/e.length}function ZL(r,t,e,s,i,o,u,l){return u===void 0&&(u=.5),l===void 0&&(l=20),Oe(this,void 0,void 0,function(){var p,d,f,m,w,x,C,I,k,P,O,z;return Fe(this,function(F){switch(F.label){case 0:return[4,XL([r,t,e,s])];case 1:for(p=F.sent(),d=p[0],f=p[1],m=p[2],w=p[3],x=[],C=function(V,G,M){for(var Y=M.shape,K=Y[0],J=Y[1],ne=Y[2],me=new KL(K*J*ne,function(rt){return rt.score}),ce=0;ce<K;++ce)for(var ye=0;ye<J;++ye)for(var Ne=0;Ne<ne;++Ne){var Ae=M.get(ce,ye,Ne);Ae<V||qL(Ne,Ae,ce,ye,G,M)&&me.enqueue({score:Ae,part:{heatmapY:ce,heatmapX:ye,id:Ne}})}return me}(u,1,d),I=l*l;x.length<o&&!C.empty();)k=C.dequeue(),P=nm(k.part,i,f),sm(x,I,P,k.part.id)||(O=YL(k,d,f,i,m,w),z=QL(x,I,O),x.push({keypoints:O,score:z}));return[2,x]}})})}function am(){for(var r,t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];switch(t.length){case 0:r="fn main() ";break;case 1:r="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return r}var JL=function(){function r(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=ae(this.outputShape),this.dispatch=re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return r.prototype.getUserCode=function(){return`
        `.concat(am("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},r}();function ez(r,t){if(ga()instanceof pi)return function(e,s){var i=ga(),o=new JL(s.shape),u=i.runWebGPUProgram(o,[e,s],"float32");return ai().makeTensorFromTensorInfo(u)}(r,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var tz=function(){function r(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,t.length!==2||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=ae(e),this.dispatch=re(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return r.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(am("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},r}();function rz(r,t){if(ga()instanceof pi)return function(e,s){var i=ga(),o=new tz(e.shape),u=i.runWebGPUProgram(o,[e,s],"float32");return ai().makeTensorFromTensorInfo(u)}(r,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function om(r){var t=r.shape,e=t[0],s=t[1],i=t[2];return tt(function(){var o,u,l=We(r,[e*s,i]),p=qd(l,0),d=ui(Et(p,Yt(s,"int32")),1),f=ui((o=p,u=s,tt(function(){var m=Et(o,Yt(u,"int32"));return Er(o,it(m,Yt(u,"int32")))})),1);return ds([d,f],1)})}function nz(r,t,e){return tt(function(){var s=function(i,o){for(var u=[],l=0;l<Lr.length;l++){var p=i.get(l,0).valueOf(),d=i.get(l,1).valueOf(),f=sz(p,d,l,o),m=f.x,w=f.y;u.push(w),u.push(m)}return Rn(u,[Lr.length,2])}(r,e);return gt(fs(it(r.toTensor(),Yt(t,"int32")),"float32"),s)})}function sz(r,t,e,s){return{y:s.get(r,t,e),x:s.get(r,t,e+Lr.length)}}function iz(r,t,e){return Oe(this,void 0,void 0,function(){var s,i,o,u,l,p,d,f,m,w;return Fe(this,function(x){switch(x.label){case 0:return s=0,i=om(r),[4,Promise.all([r.buffer(),t.buffer(),i.buffer()])];case 1:return o=x.sent(),u=o[0],l=o[1],p=o[2],[4,(d=nz(p,e,l)).buffer()];case 2:return f=x.sent(),m=Array.from(function(C,I){for(var k=I.shape[0],P=new Float32Array(k),O=0;O<k;O++){var z=I.get(O,0),F=I.get(O,1);P[O]=C.get(z,F,O)}return P}(u,p)),w=m.map(function(C,I){return s+=C,{y:f.get(I,0),x:f.get(I,1),score:C,name:Lr[I]}}),i.dispose(),d.dispose(),[2,{keypoints:w,score:s/w.length}]}})})}function az(r,t,e){return Oe(this,void 0,void 0,function(){var s,i,o;return Fe(this,function(u){return s=om(r),i=function(l,p,d){return tt(function(){var f=rz(l,d);return gt(fs(it(l,Yt(p,"int32")),"float32"),f)})}(s,e,t),o=ez(r,s),[2,[i,o]]})})}function xd(r,t){return(r-1)%t==0}var Sd="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Cd="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Nd(r,t){return function(e,s){return(e-1)%s==0}(r,t)?r:Math.floor(r/t)*t+1}var Id=function(){function r(t,e){this.posenetModel=t;var s=this.posenetModel.inputs[0].shape;le(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var i,o,u=(i=e.inputResolution,o=e.outputStride,{height:Nd(i.height,o),width:Nd(i.width,o)});(function(l){le(HL.indexOf(l)>=0,function(){return"outputStride of ".concat(l," is invalid. ")+"It must be either 8 or 16."})})(e.outputStride),function(l,p){le(xd(l.height,p),function(){return"height of ".concat(l.height," is invalid for output stride ")+"".concat(p,".")}),le(xd(l.width,p),function(){return"width of ".concat(l.width," is invalid for output stride ")+"".concat(p,".")})}(u,e.outputStride),this.inputResolution=u,this.outputStride=e.outputStride,this.architecture=e.architecture}return r.prototype.estimatePoses=function(t,e){return e===void 0&&(e=md),Oe(this,void 0,void 0,function(){return Fe(this,function(s){return[2,this.estimatePosesGPU(t,e,!1)]})})},r.prototype.estimatePosesGPU=function(t,e,s){return e===void 0&&(e=md),s===void 0&&(s=!1),Oe(this,void 0,void 0,function(){var i,o,u,l,p,d,f,m,w,x,C,I,k,P,O,z,F,V;return Fe(this,function(G){switch(G.label){case 0:return i=function(M){var Y=M;if(Y.maxPoses==null&&(Y.maxPoses=1),Y.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(Y.maxPoses,". Should be > 0."));if(Y.maxPoses>1){if((Y=Ze(Ze({},GL),Y)).scoreThreshold<0||Y.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(Y.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(Y.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(Y.nmsRadius,"."))}return Y}(e),t==null?[2,s?[[],[]]:[]]:(this.maxPoses=i.maxPoses,o=Ql(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),u=o.imageTensor,l=o.padding,p=this.architecture==="ResNet50"?gt(u,jL):Qf(u,[-1,1]),d=this.posenetModel.predict(p),this.architecture==="ResNet50"?(f=Ye(d[2],[0]),m=Ye(d[3],[0]),w=Ye(d[0],[0]),x=Ye(d[1],[0])):(f=Ye(d[0],[0]),m=Ye(d[1],[0]),w=Ye(d[2],[0]),x=Ye(d[3],[0])),C=ls(m),this.maxPoses!==1?[3,5]:s?[4,az(C,f,this.outputStride)]:[3,2]);case 1:return k=G.sent(),O=k[0],P=k[1],I=[O,P],[3,4];case 2:return[4,iz(C,f,this.outputStride)];case 3:O=G.sent(),I=[O],G.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,ZL(C,f,w,x,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:I=G.sent(),G.label=7;case 7:if(s){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");z=this.getCanvasInfo(hi(t),this.inputResolution,l)}else V=hi(t),F=function(M,Y,K,J){var ne=Y.height,me=Y.width,ce=ne/(K.height*(1-J.top-J.bottom)),ye=me/(K.width*(1-J.left-J.right)),Ne=-J.top*K.height,Ae=-J.left*K.width;if(ye===1&&ce===1&&Ne===0&&Ae===0)return M;for(var rt=0,nt=M;rt<nt.length;rt++)for(var pt=0,Ot=nt[rt].keypoints;pt<Ot.length;pt++){var ut=Ot[pt];ut.x=(ut.x+Ae)*ye,ut.y=(ut.y+Ne)*ce}return M}(I,V,this.inputResolution,l),i.flipHorizontal&&(F=function(M,Y){for(var K=0,J=M;K<J.length;K++)for(var ne=0,me=J[K].keypoints;ne<me.length;ne++){var ce=me[ne];ce.x=Y.width-1-ce.x}return M}(F,V));return u.dispose(),p.dispose(),Dt(d),f.dispose(),m.dispose(),w.dispose(),x.dispose(),C.dispose(),[2,s?[I,z]:F]}})})},r.prototype.getCanvasInfo=function(t,e,s){var i=t.height,o=t.width,u=i/(e.height*(1-s.top-s.bottom)),l=o/(e.width*(1-s.left-s.right)),p=-s.top*e.height;return[-s.left*e.width,p,l,u,t.width,t.height]},r.prototype.dispose=function(){this.posenetModel.dispose()},r.prototype.reset=function(){},r}();function oz(r){return r===void 0&&(r=cd),Oe(this,void 0,void 0,function(){var t,e,s,i,o;return Fe(this,function(u){switch(u.label){case 0:return(t=function(f){var m=f||cd;if(m.architecture==null&&(m.architecture="MobileNetV1"),hd.indexOf(m.architecture)<0)throw new Error("Invalid architecture ".concat(m.architecture,". ")+"Should be one of ".concat(hd));if(m.inputResolution==null&&(m.inputResolution={height:257,width:257}),m.outputStride==null&&(m.outputStride=16),pd[m.architecture].indexOf(m.outputStride)<0)throw new Error("Invalid outputStride ".concat(m.outputStride,". ")+"Should be one of ".concat(pd[m.architecture]," ")+"for architecture ".concat(m.architecture,"."));if(m.multiplier==null&&(m.multiplier=1),dd[m.architecture].indexOf(m.multiplier)<0)throw new Error("Invalid multiplier ".concat(m.multiplier,". ")+"Should be one of ".concat(dd[m.architecture]," ")+"for architecture ".concat(m.architecture,"."));if(m.quantBytes==null&&(m.quantBytes=4),fd.indexOf(m.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(m.quantBytes,". ")+"Should be one of ".concat(fd," ")+"for architecture ".concat(m.architecture,"."));if(m.architecture==="MobileNetV1"&&m.outputStride===32&&m.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return m}(r)).architecture!=="ResNet50"?[3,2]:(l=t.outputStride,p=t.quantBytes,d="model-stride".concat(l,".json"),e=p===4?Cd+"float/"+d:Cd+"quant".concat(p,"/")+d,[4,li(t.modelUrl||e)]);case 1:return s=u.sent(),[2,new Id(s,t)];case 2:return i=function(f,m,w){var x={1:"100",.75:"075",.5:"050"},C="model-stride".concat(f,".json");return w===4?Sd+"float/".concat(x[m],"/")+C:Sd+"quant".concat(w,"/").concat(x[m],"/")+C}(t.outputStride,t.multiplier,t.quantBytes),[4,li(t.modelUrl||i)];case 3:return o=u.sent(),[2,new Id(o,t)]}var l,p,d})})}function uz(r,t){return Oe(this,void 0,void 0,function(){var e,s;return Fe(this,function(i){switch(r){case Dr.PoseNet:return[2,oz(t)];case Dr.BlazePose:if(s=void 0,(e=t)!=null){if(e.runtime==="tfjs")return[2,FL(t)];if(e.runtime==="mediapipe")return[2,uL(t)];s=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case Dr.MoveNet:return[2,ML(t)];default:throw new Error("".concat(r," is not a supported model name."))}})})}var ca={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */var lz=ca.exports,kd;function cz(){return kd||(kd=1,function(r,t){(function(){var e,s="4.17.21",i=200,o="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",u="Expected a function",l="Invalid `variable` option passed into `_.template`",p="__lodash_hash_undefined__",d=500,f="__lodash_placeholder__",m=1,w=2,x=4,C=1,I=2,k=1,P=2,O=4,z=8,F=16,V=32,G=64,M=128,Y=256,K=512,J=30,ne="...",me=800,ce=16,ye=1,Ne=2,Ae=3,rt=1/0,nt=9007199254740991,pt=17976931348623157e292,Ot=NaN,ut=4294967295,En=ut-1,Dn=ut>>>1,xs=[["ary",M],["bind",k],["bindKey",P],["curry",z],["curryRight",F],["flip",K],["partial",V],["partialRight",G],["rearg",Y]],zr="[object Arguments]",On="[object Array]",ru="[object AsyncFunction]",hn="[object Boolean]",pn="[object Date]",mi="[object DOMException]",Nr="[object Error]",Ss="[object Function]",lt="[object GeneratorFunction]",Je="[object Map]",dn="[object Number]",nu="[object Null]",or="[object Object]",gi="[object Promise]",_a="[object Proxy]",fn="[object RegExp]",Ut="[object Set]",Br="[object String]",Fn="[object Symbol]",Wr="[object Undefined]",mn="[object WeakMap]",Cs="[object WeakSet]",Vr="[object ArrayBuffer]",gn="[object DataView]",Ns="[object Float32Array]",yi="[object Float64Array]",Is="[object Int8Array]",ks="[object Int16Array]",Ur="[object Int32Array]",Ln="[object Uint8Array]",_s="[object Uint8ClampedArray]",wi="[object Uint16Array]",Ts="[object Uint32Array]",vi=/\b__p \+= '';/g,Mr=/\b(__p \+=) '' \+/g,zn=/(__e\(.*?\)|\b__t\)) \+\n'';/g,bi=/&(?:amp|lt|gt|quot|#39);/g,xi=/[&<>"']/g,Si=RegExp(bi.source),Ta=RegExp(xi.source),Hr=/<%-([\s\S]+?)%>/g,Ci=/<%([\s\S]+?)%>/g,Ni=/<%=([\s\S]+?)%>/g,Rs=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,As=/^\w*$/,su=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Ir=/[\\^$.*+?()[\]{}|]/g,iu=RegExp(Ir.source),Zt=/^\s+/,Gr=/\s/,Ra=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,at=/\{\n\/\* \[wrapped with (.+)\] \*/,ur=/,? & /,Ii=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,au=/[()=,{}\[\]\/\s]/,Ps=/\\(\\)?/g,ki=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Bn=/\w*$/,Wn=/^[-+]0x[0-9a-f]+$/i,Aa=/^0b[01]+$/i,_i=/^\[object .+?Constructor\]$/,Ti=/^0o[0-7]+$/i,Pa=/^(?:0|[1-9]\d*)$/,Jt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ft=/($^)/,Vn=/['\n\r\u2028\u2029\\]/g,yn="\\ud800-\\udfff",Ri="\\u0300-\\u036f",$a="\\ufe20-\\ufe2f",Ai="\\u20d0-\\u20ff",er=Ri+$a+Ai,Pi="\\u2700-\\u27bf",Un="a-z\\xdf-\\xf6\\xf8-\\xff",lr="\\xac\\xb1\\xd7\\xf7",$s="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",ou="\\u2000-\\u206f",Ea=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Es="A-Z\\xc0-\\xd6\\xd8-\\xde",Da="\\ufe0e\\ufe0f",Oa=lr+$s+ou+Ea,Ds="['’]",Fa="["+yn+"]",$i="["+Oa+"]",Mn="["+er+"]",kt="\\d+",La="["+Pi+"]",Ei="["+Un+"]",Hn="[^"+yn+Oa+kt+Pi+Un+Es+"]",Os="\\ud83c[\\udffb-\\udfff]",za="(?:"+Mn+"|"+Os+")",Ba="[^"+yn+"]",Di="(?:\\ud83c[\\udde6-\\uddff]){2}",Fs="[\\ud800-\\udbff][\\udc00-\\udfff]",jr="["+Es+"]",Gn="\\u200d",Oi="(?:"+Ei+"|"+Hn+")",Wa="(?:"+jr+"|"+Hn+")",wn="(?:"+Ds+"(?:d|ll|m|re|s|t|ve))?",Va="(?:"+Ds+"(?:D|LL|M|RE|S|T|VE))?",Ua=za+"?",Ma="["+Da+"]?",uu="(?:"+Gn+"(?:"+[Ba,Di,Fs].join("|")+")"+Ma+Ua+")*",Fi="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",jn="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",Ha=Ma+Ua+uu,lu="(?:"+[La,Di,Fs].join("|")+")"+Ha,cu="(?:"+[Ba+Mn+"?",Mn,Di,Fs,Fa].join("|")+")",hu=RegExp(Ds,"g"),Li=RegExp(Mn,"g"),Ls=RegExp(Os+"(?="+Os+")|"+cu+Ha,"g"),Ga=RegExp([jr+"?"+Ei+"+"+wn+"(?="+[$i,jr,"$"].join("|")+")",Wa+"+"+Va+"(?="+[$i,jr+Oi,"$"].join("|")+")",jr+"?"+Oi+"+"+wn,jr+"+"+Va,jn,Fi,kt,lu].join("|"),"g"),Kn=RegExp("["+Gn+yn+er+Da+"]"),tr=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,pu=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],du=-1,je={};je[Ns]=je[yi]=je[Is]=je[ks]=je[Ur]=je[Ln]=je[_s]=je[wi]=je[Ts]=!0,je[zr]=je[On]=je[Vr]=je[hn]=je[gn]=je[pn]=je[Nr]=je[Ss]=je[Je]=je[dn]=je[or]=je[fn]=je[Ut]=je[Br]=je[mn]=!1;var He={};He[zr]=He[On]=He[Vr]=He[gn]=He[hn]=He[pn]=He[Ns]=He[yi]=He[Is]=He[ks]=He[Ur]=He[Je]=He[dn]=He[or]=He[fn]=He[Ut]=He[Br]=He[Fn]=He[Ln]=He[_s]=He[wi]=He[Ts]=!0,He[Nr]=He[Ss]=He[mn]=!1;var zi={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},Bi={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},vn={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},ja={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Wi=parseFloat,fu=parseInt,Ka=typeof ii=="object"&&ii&&ii.Object===Object&&ii,qn=typeof self=="object"&&self&&self.Object===Object&&self,yt=Ka||qn||Function("return this")(),zs=t&&!t.nodeType&&t,Kr=zs&&!0&&r&&!r.nodeType&&r,qa=Kr&&Kr.exports===zs,bn=qa&&Ka.process,Lt=function(){try{var B=Kr&&Kr.require&&Kr.require("util").types;return B||bn&&bn.binding&&bn.binding("util")}catch{}}(),Xa=Lt&&Lt.isArrayBuffer,Vi=Lt&&Lt.isDate,Ya=Lt&&Lt.isMap,Qa=Lt&&Lt.isRegExp,Bs=Lt&&Lt.isSet,Ws=Lt&&Lt.isTypedArray;function Tt(B,j,H){switch(H.length){case 0:return B.call(j);case 1:return B.call(j,H[0]);case 2:return B.call(j,H[0],H[1]);case 3:return B.call(j,H[0],H[1],H[2])}return B.apply(j,H)}function mu(B,j,H,he){for(var Ie=-1,Ue=B==null?0:B.length;++Ie<Ue;){var vt=B[Ie];j(he,vt,H(vt),B)}return he}function Mt(B,j){for(var H=-1,he=B==null?0:B.length;++H<he&&j(B[H],H,B)!==!1;);return B}function gu(B,j){for(var H=B==null?0:B.length;H--&&j(B[H],H,B)!==!1;);return B}function Za(B,j){for(var H=-1,he=B==null?0:B.length;++H<he;)if(!j(B[H],H,B))return!1;return!0}function wr(B,j){for(var H=-1,he=B==null?0:B.length,Ie=0,Ue=[];++H<he;){var vt=B[H];j(vt,H,B)&&(Ue[Ie++]=vt)}return Ue}function Vs(B,j){var H=B==null?0:B.length;return!!H&&c(B,j,0)>-1}function Ui(B,j,H){for(var he=-1,Ie=B==null?0:B.length;++he<Ie;)if(H(j,B[he]))return!0;return!1}function Ke(B,j){for(var H=-1,he=B==null?0:B.length,Ie=Array(he);++H<he;)Ie[H]=j(B[H],H,B);return Ie}function kr(B,j){for(var H=-1,he=j.length,Ie=B.length;++H<he;)B[Ie+H]=j[H];return B}function Mi(B,j,H,he){var Ie=-1,Ue=B==null?0:B.length;for(he&&Ue&&(H=B[++Ie]);++Ie<Ue;)H=j(H,B[Ie],Ie,B);return H}function yu(B,j,H,he){var Ie=B==null?0:B.length;for(he&&Ie&&(H=B[--Ie]);Ie--;)H=j(H,B[Ie],Ie,B);return H}function xn(B,j){for(var H=-1,he=B==null?0:B.length;++H<he;)if(j(B[H],H,B))return!0;return!1}var wu=R("length");function vu(B){return B.split("")}function bu(B){return B.match(Ii)||[]}function Hi(B,j,H){var he;return H(B,function(Ie,Ue,vt){if(j(Ie,Ue,vt))return he=Ue,!1}),he}function Xn(B,j,H,he){for(var Ie=B.length,Ue=H+(he?1:-1);he?Ue--:++Ue<Ie;)if(j(B[Ue],Ue,B))return Ue;return-1}function c(B,j,H){return j===j?um(B,j,H):Xn(B,b,H)}function g(B,j,H,he){for(var Ie=H-1,Ue=B.length;++Ie<Ue;)if(he(B[Ie],j))return Ie;return-1}function b(B){return B!==B}function N(B,j){var H=B==null?0:B.length;return H?U(B,j)/H:Ot}function R(B){return function(j){return j==null?e:j[B]}}function $(B){return function(j){return B==null?e:B[j]}}function A(B,j,H,he,Ie){return Ie(B,function(Ue,vt,et){H=he?(he=!1,Ue):j(H,Ue,vt,et)}),H}function L(B,j){var H=B.length;for(B.sort(j);H--;)B[H]=B[H].value;return B}function U(B,j){for(var H,he=-1,Ie=B.length;++he<Ie;){var Ue=j(B[he]);Ue!==e&&(H=H===e?Ue:H+Ue)}return H}function Z(B,j){for(var H=-1,he=Array(B);++H<B;)he[H]=j(H);return he}function se(B,j){return Ke(j,function(H){return[H,B[H]]})}function we(B){return B&&B.slice(0,kc(B)+1).replace(Zt,"")}function ue(B){return function(j){return B(j)}}function ie(B,j){return Ke(j,function(H){return B[H]})}function ge(B,j){return B.has(j)}function _e(B,j){for(var H=-1,he=B.length;++H<he&&c(j,B[H],0)>-1;);return H}function qe(B,j){for(var H=B.length;H--&&c(j,B[H],0)>-1;);return H}function Xe(B,j){for(var H=B.length,he=0;H--;)B[H]===j&&++he;return he}var wt=$(zi),Ht=$(Bi);function Rt(B){return"\\"+ja[B]}function Be(B,j){return B==null?e:B[j]}function st(B){return Kn.test(B)}function _r(B){return tr.test(B)}function xu(B){for(var j,H=[];!(j=B.next()).done;)H.push(j.value);return H}function Gi(B){var j=-1,H=Array(B.size);return B.forEach(function(he,Ie){H[++j]=[Ie,he]}),H}function Ja(B,j){return function(H){return B(j(H))}}function Tr(B,j){for(var H=-1,he=B.length,Ie=0,Ue=[];++H<he;){var vt=B[H];(vt===j||vt===f)&&(B[H]=f,Ue[Ie++]=H)}return Ue}function Us(B){var j=-1,H=Array(B.size);return B.forEach(function(he){H[++j]=he}),H}function Ms(B){var j=-1,H=Array(B.size);return B.forEach(function(he){H[++j]=[he,he]}),H}function um(B,j,H){for(var he=H-1,Ie=B.length;++he<Ie;)if(B[he]===j)return he;return-1}function lm(B,j,H){for(var he=H+1;he--;)if(B[he]===j)return he;return he}function Hs(B){return st(B)?hm(B):wu(B)}function vr(B){return st(B)?pm(B):vu(B)}function kc(B){for(var j=B.length;j--&&Gr.test(B.charAt(j)););return j}var cm=$(vn);function hm(B){for(var j=Ls.lastIndex=0;Ls.test(B);)++j;return j}function pm(B){return B.match(Ls)||[]}function dm(B){return B.match(Ga)||[]}var fm=function B(j){j=j==null?yt:Gs.defaults(yt.Object(),j,Gs.pick(yt,pu));var H=j.Array,he=j.Date,Ie=j.Error,Ue=j.Function,vt=j.Math,et=j.Object,Su=j.RegExp,mm=j.String,cr=j.TypeError,eo=H.prototype,gm=Ue.prototype,js=et.prototype,to=j["__core-js_shared__"],ro=gm.toString,Ge=js.hasOwnProperty,ym=0,_c=function(){var n=/[^.]+$/.exec(to&&to.keys&&to.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),no=js.toString,wm=ro.call(et),vm=yt._,bm=Su("^"+ro.call(Ge).replace(Ir,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),so=qa?j.Buffer:e,Sn=j.Symbol,io=j.Uint8Array,Tc=so?so.allocUnsafe:e,ao=Ja(et.getPrototypeOf,et),Rc=et.create,Ac=js.propertyIsEnumerable,oo=eo.splice,Pc=Sn?Sn.isConcatSpreadable:e,ji=Sn?Sn.iterator:e,Yn=Sn?Sn.toStringTag:e,uo=function(){try{var n=ts(et,"defineProperty");return n({},"",{}),n}catch{}}(),xm=j.clearTimeout!==yt.clearTimeout&&j.clearTimeout,Sm=he&&he.now!==yt.Date.now&&he.now,Cm=j.setTimeout!==yt.setTimeout&&j.setTimeout,lo=vt.ceil,co=vt.floor,Cu=et.getOwnPropertySymbols,Nm=so?so.isBuffer:e,$c=j.isFinite,Im=eo.join,km=Ja(et.keys,et),bt=vt.max,At=vt.min,_m=he.now,Tm=j.parseInt,Ec=vt.random,Rm=eo.reverse,Nu=ts(j,"DataView"),Ki=ts(j,"Map"),Iu=ts(j,"Promise"),Ks=ts(j,"Set"),qi=ts(j,"WeakMap"),Xi=ts(et,"create"),ho=qi&&new qi,qs={},Am=rs(Nu),Pm=rs(Ki),$m=rs(Iu),Em=rs(Ks),Dm=rs(qi),po=Sn?Sn.prototype:e,Yi=po?po.valueOf:e,Dc=po?po.toString:e;function _(n){if(ct(n)&&!ke(n)&&!(n instanceof De)){if(n instanceof hr)return n;if(Ge.call(n,"__wrapped__"))return Oh(n)}return new hr(n)}var Xs=function(){function n(){}return function(a){if(!ot(a))return{};if(Rc)return Rc(a);n.prototype=a;var h=new n;return n.prototype=e,h}}();function fo(){}function hr(n,a){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!a,this.__index__=0,this.__values__=e}_.templateSettings={escape:Hr,evaluate:Ci,interpolate:Ni,variable:"",imports:{_}},_.prototype=fo.prototype,_.prototype.constructor=_,hr.prototype=Xs(fo.prototype),hr.prototype.constructor=hr;function De(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=ut,this.__views__=[]}function Om(){var n=new De(this.__wrapped__);return n.__actions__=Gt(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Gt(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Gt(this.__views__),n}function Fm(){if(this.__filtered__){var n=new De(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Lm(){var n=this.__wrapped__.value(),a=this.__dir__,h=ke(n),y=a<0,S=h?n.length:0,T=Xg(0,S,this.__views__),E=T.start,D=T.end,W=D-E,q=y?D:E-1,X=this.__iteratees__,Q=X.length,oe=0,fe=At(W,this.__takeCount__);if(!h||!y&&S==W&&fe==W)return sh(n,this.__actions__);var be=[];e:for(;W--&&oe<fe;){q+=a;for(var Pe=-1,xe=n[q];++Pe<Q;){var Ee=X[Pe],Le=Ee.iteratee,sr=Ee.type,Wt=Le(xe);if(sr==Ne)xe=Wt;else if(!Wt){if(sr==ye)continue e;break e}}be[oe++]=xe}return be}De.prototype=Xs(fo.prototype),De.prototype.constructor=De;function Qn(n){var a=-1,h=n==null?0:n.length;for(this.clear();++a<h;){var y=n[a];this.set(y[0],y[1])}}function zm(){this.__data__=Xi?Xi(null):{},this.size=0}function Bm(n){var a=this.has(n)&&delete this.__data__[n];return this.size-=a?1:0,a}function Wm(n){var a=this.__data__;if(Xi){var h=a[n];return h===p?e:h}return Ge.call(a,n)?a[n]:e}function Vm(n){var a=this.__data__;return Xi?a[n]!==e:Ge.call(a,n)}function Um(n,a){var h=this.__data__;return this.size+=this.has(n)?0:1,h[n]=Xi&&a===e?p:a,this}Qn.prototype.clear=zm,Qn.prototype.delete=Bm,Qn.prototype.get=Wm,Qn.prototype.has=Vm,Qn.prototype.set=Um;function qr(n){var a=-1,h=n==null?0:n.length;for(this.clear();++a<h;){var y=n[a];this.set(y[0],y[1])}}function Mm(){this.__data__=[],this.size=0}function Hm(n){var a=this.__data__,h=mo(a,n);if(h<0)return!1;var y=a.length-1;return h==y?a.pop():oo.call(a,h,1),--this.size,!0}function Gm(n){var a=this.__data__,h=mo(a,n);return h<0?e:a[h][1]}function jm(n){return mo(this.__data__,n)>-1}function Km(n,a){var h=this.__data__,y=mo(h,n);return y<0?(++this.size,h.push([n,a])):h[y][1]=a,this}qr.prototype.clear=Mm,qr.prototype.delete=Hm,qr.prototype.get=Gm,qr.prototype.has=jm,qr.prototype.set=Km;function Xr(n){var a=-1,h=n==null?0:n.length;for(this.clear();++a<h;){var y=n[a];this.set(y[0],y[1])}}function qm(){this.size=0,this.__data__={hash:new Qn,map:new(Ki||qr),string:new Qn}}function Xm(n){var a=_o(this,n).delete(n);return this.size-=a?1:0,a}function Ym(n){return _o(this,n).get(n)}function Qm(n){return _o(this,n).has(n)}function Zm(n,a){var h=_o(this,n),y=h.size;return h.set(n,a),this.size+=h.size==y?0:1,this}Xr.prototype.clear=qm,Xr.prototype.delete=Xm,Xr.prototype.get=Ym,Xr.prototype.has=Qm,Xr.prototype.set=Zm;function Zn(n){var a=-1,h=n==null?0:n.length;for(this.__data__=new Xr;++a<h;)this.add(n[a])}function Jm(n){return this.__data__.set(n,p),this}function eg(n){return this.__data__.has(n)}Zn.prototype.add=Zn.prototype.push=Jm,Zn.prototype.has=eg;function br(n){var a=this.__data__=new qr(n);this.size=a.size}function tg(){this.__data__=new qr,this.size=0}function rg(n){var a=this.__data__,h=a.delete(n);return this.size=a.size,h}function ng(n){return this.__data__.get(n)}function sg(n){return this.__data__.has(n)}function ig(n,a){var h=this.__data__;if(h instanceof qr){var y=h.__data__;if(!Ki||y.length<i-1)return y.push([n,a]),this.size=++h.size,this;h=this.__data__=new Xr(y)}return h.set(n,a),this.size=h.size,this}br.prototype.clear=tg,br.prototype.delete=rg,br.prototype.get=ng,br.prototype.has=sg,br.prototype.set=ig;function Oc(n,a){var h=ke(n),y=!h&&ns(n),S=!h&&!y&&_n(n),T=!h&&!y&&!S&&Js(n),E=h||y||S||T,D=E?Z(n.length,mm):[],W=D.length;for(var q in n)(a||Ge.call(n,q))&&!(E&&(q=="length"||S&&(q=="offset"||q=="parent")||T&&(q=="buffer"||q=="byteLength"||q=="byteOffset")||Jr(q,W)))&&D.push(q);return D}function Fc(n){var a=n.length;return a?n[Fu(0,a-1)]:e}function ag(n,a){return To(Gt(n),Jn(a,0,n.length))}function og(n){return To(Gt(n))}function ku(n,a,h){(h!==e&&!xr(n[a],h)||h===e&&!(a in n))&&Yr(n,a,h)}function Qi(n,a,h){var y=n[a];(!(Ge.call(n,a)&&xr(y,h))||h===e&&!(a in n))&&Yr(n,a,h)}function mo(n,a){for(var h=n.length;h--;)if(xr(n[h][0],a))return h;return-1}function ug(n,a,h,y){return Cn(n,function(S,T,E){a(y,S,h(S),E)}),y}function Lc(n,a){return n&&Ar(a,Ct(a),n)}function lg(n,a){return n&&Ar(a,Kt(a),n)}function Yr(n,a,h){a=="__proto__"&&uo?uo(n,a,{configurable:!0,enumerable:!0,value:h,writable:!0}):n[a]=h}function _u(n,a){for(var h=-1,y=a.length,S=H(y),T=n==null;++h<y;)S[h]=T?e:ol(n,a[h]);return S}function Jn(n,a,h){return n===n&&(h!==e&&(n=n<=h?n:h),a!==e&&(n=n>=a?n:a)),n}function pr(n,a,h,y,S,T){var E,D=a&m,W=a&w,q=a&x;if(h&&(E=S?h(n,y,S,T):h(n)),E!==e)return E;if(!ot(n))return n;var X=ke(n);if(X){if(E=Qg(n),!D)return Gt(n,E)}else{var Q=Pt(n),oe=Q==Ss||Q==lt;if(_n(n))return oh(n,D);if(Q==or||Q==zr||oe&&!S){if(E=W||oe?{}:kh(n),!D)return W?Wg(n,lg(E,n)):Bg(n,Lc(E,n))}else{if(!He[Q])return S?n:{};E=Zg(n,Q,D)}}T||(T=new br);var fe=T.get(n);if(fe)return fe;T.set(n,E),tp(n)?n.forEach(function(xe){E.add(pr(xe,a,h,xe,n,T))}):Jh(n)&&n.forEach(function(xe,Ee){E.set(Ee,pr(xe,a,h,Ee,n,T))});var be=q?W?Ku:ju:W?Kt:Ct,Pe=X?e:be(n);return Mt(Pe||n,function(xe,Ee){Pe&&(Ee=xe,xe=n[Ee]),Qi(E,Ee,pr(xe,a,h,Ee,n,T))}),E}function cg(n){var a=Ct(n);return function(h){return zc(h,n,a)}}function zc(n,a,h){var y=h.length;if(n==null)return!y;for(n=et(n);y--;){var S=h[y],T=a[S],E=n[S];if(E===e&&!(S in n)||!T(E))return!1}return!0}function Bc(n,a,h){if(typeof n!="function")throw new cr(u);return sa(function(){n.apply(e,h)},a)}function Zi(n,a,h,y){var S=-1,T=Vs,E=!0,D=n.length,W=[],q=a.length;if(!D)return W;h&&(a=Ke(a,ue(h))),y?(T=Ui,E=!1):a.length>=i&&(T=ge,E=!1,a=new Zn(a));e:for(;++S<D;){var X=n[S],Q=h==null?X:h(X);if(X=y||X!==0?X:0,E&&Q===Q){for(var oe=q;oe--;)if(a[oe]===Q)continue e;W.push(X)}else T(a,Q,y)||W.push(X)}return W}var Cn=ph(Rr),Wc=ph(Ru,!0);function hg(n,a){var h=!0;return Cn(n,function(y,S,T){return h=!!a(y,S,T),h}),h}function go(n,a,h){for(var y=-1,S=n.length;++y<S;){var T=n[y],E=a(T);if(E!=null&&(D===e?E===E&&!nr(E):h(E,D)))var D=E,W=T}return W}function pg(n,a,h,y){var S=n.length;for(h=Re(h),h<0&&(h=-h>S?0:S+h),y=y===e||y>S?S:Re(y),y<0&&(y+=S),y=h>y?0:np(y);h<y;)n[h++]=a;return n}function Vc(n,a){var h=[];return Cn(n,function(y,S,T){a(y,S,T)&&h.push(y)}),h}function _t(n,a,h,y,S){var T=-1,E=n.length;for(h||(h=ey),S||(S=[]);++T<E;){var D=n[T];a>0&&h(D)?a>1?_t(D,a-1,h,y,S):kr(S,D):y||(S[S.length]=D)}return S}var Tu=dh(),Uc=dh(!0);function Rr(n,a){return n&&Tu(n,a,Ct)}function Ru(n,a){return n&&Uc(n,a,Ct)}function yo(n,a){return wr(a,function(h){return en(n[h])})}function es(n,a){a=In(a,n);for(var h=0,y=a.length;n!=null&&h<y;)n=n[Pr(a[h++])];return h&&h==y?n:e}function Mc(n,a,h){var y=a(n);return ke(n)?y:kr(y,h(n))}function zt(n){return n==null?n===e?Wr:nu:Yn&&Yn in et(n)?qg(n):oy(n)}function Au(n,a){return n>a}function dg(n,a){return n!=null&&Ge.call(n,a)}function fg(n,a){return n!=null&&a in et(n)}function mg(n,a,h){return n>=At(a,h)&&n<bt(a,h)}function Pu(n,a,h){for(var y=h?Ui:Vs,S=n[0].length,T=n.length,E=T,D=H(T),W=1/0,q=[];E--;){var X=n[E];E&&a&&(X=Ke(X,ue(a))),W=At(X.length,W),D[E]=!h&&(a||S>=120&&X.length>=120)?new Zn(E&&X):e}X=n[0];var Q=-1,oe=D[0];e:for(;++Q<S&&q.length<W;){var fe=X[Q],be=a?a(fe):fe;if(fe=h||fe!==0?fe:0,!(oe?ge(oe,be):y(q,be,h))){for(E=T;--E;){var Pe=D[E];if(!(Pe?ge(Pe,be):y(n[E],be,h)))continue e}oe&&oe.push(be),q.push(fe)}}return q}function gg(n,a,h,y){return Rr(n,function(S,T,E){a(y,h(S),T,E)}),y}function Ji(n,a,h){a=In(a,n),n=Ah(n,a);var y=n==null?n:n[Pr(fr(a))];return y==null?e:Tt(y,n,h)}function Hc(n){return ct(n)&&zt(n)==zr}function yg(n){return ct(n)&&zt(n)==Vr}function wg(n){return ct(n)&&zt(n)==pn}function ea(n,a,h,y,S){return n===a?!0:n==null||a==null||!ct(n)&&!ct(a)?n!==n&&a!==a:vg(n,a,h,y,ea,S)}function vg(n,a,h,y,S,T){var E=ke(n),D=ke(a),W=E?On:Pt(n),q=D?On:Pt(a);W=W==zr?or:W,q=q==zr?or:q;var X=W==or,Q=q==or,oe=W==q;if(oe&&_n(n)){if(!_n(a))return!1;E=!0,X=!1}if(oe&&!X)return T||(T=new br),E||Js(n)?Ch(n,a,h,y,S,T):jg(n,a,W,h,y,S,T);if(!(h&C)){var fe=X&&Ge.call(n,"__wrapped__"),be=Q&&Ge.call(a,"__wrapped__");if(fe||be){var Pe=fe?n.value():n,xe=be?a.value():a;return T||(T=new br),S(Pe,xe,h,y,T)}}return oe?(T||(T=new br),Kg(n,a,h,y,S,T)):!1}function bg(n){return ct(n)&&Pt(n)==Je}function $u(n,a,h,y){var S=h.length,T=S,E=!y;if(n==null)return!T;for(n=et(n);S--;){var D=h[S];if(E&&D[2]?D[1]!==n[D[0]]:!(D[0]in n))return!1}for(;++S<T;){D=h[S];var W=D[0],q=n[W],X=D[1];if(E&&D[2]){if(q===e&&!(W in n))return!1}else{var Q=new br;if(y)var oe=y(q,X,W,n,a,Q);if(!(oe===e?ea(X,q,C|I,y,Q):oe))return!1}}return!0}function Gc(n){if(!ot(n)||ry(n))return!1;var a=en(n)?bm:_i;return a.test(rs(n))}function xg(n){return ct(n)&&zt(n)==fn}function Sg(n){return ct(n)&&Pt(n)==Ut}function Cg(n){return ct(n)&&Do(n.length)&&!!je[zt(n)]}function jc(n){return typeof n=="function"?n:n==null?qt:typeof n=="object"?ke(n)?Xc(n[0],n[1]):qc(n):fp(n)}function Eu(n){if(!na(n))return km(n);var a=[];for(var h in et(n))Ge.call(n,h)&&h!="constructor"&&a.push(h);return a}function Ng(n){if(!ot(n))return ay(n);var a=na(n),h=[];for(var y in n)y=="constructor"&&(a||!Ge.call(n,y))||h.push(y);return h}function Du(n,a){return n<a}function Kc(n,a){var h=-1,y=jt(n)?H(n.length):[];return Cn(n,function(S,T,E){y[++h]=a(S,T,E)}),y}function qc(n){var a=Xu(n);return a.length==1&&a[0][2]?Th(a[0][0],a[0][1]):function(h){return h===n||$u(h,n,a)}}function Xc(n,a){return Qu(n)&&_h(a)?Th(Pr(n),a):function(h){var y=ol(h,n);return y===e&&y===a?ul(h,n):ea(a,y,C|I)}}function wo(n,a,h,y,S){n!==a&&Tu(a,function(T,E){if(S||(S=new br),ot(T))Ig(n,a,E,h,wo,y,S);else{var D=y?y(Ju(n,E),T,E+"",n,a,S):e;D===e&&(D=T),ku(n,E,D)}},Kt)}function Ig(n,a,h,y,S,T,E){var D=Ju(n,h),W=Ju(a,h),q=E.get(W);if(q){ku(n,h,q);return}var X=T?T(D,W,h+"",n,a,E):e,Q=X===e;if(Q){var oe=ke(W),fe=!oe&&_n(W),be=!oe&&!fe&&Js(W);X=W,oe||fe||be?ke(D)?X=D:dt(D)?X=Gt(D):fe?(Q=!1,X=oh(W,!0)):be?(Q=!1,X=uh(W,!0)):X=[]:ia(W)||ns(W)?(X=D,ns(D)?X=sp(D):(!ot(D)||en(D))&&(X=kh(W))):Q=!1}Q&&(E.set(W,X),S(X,W,y,T,E),E.delete(W)),ku(n,h,X)}function Yc(n,a){var h=n.length;if(h)return a+=a<0?h:0,Jr(a,h)?n[a]:e}function Qc(n,a,h){a.length?a=Ke(a,function(T){return ke(T)?function(E){return es(E,T.length===1?T[0]:T)}:T}):a=[qt];var y=-1;a=Ke(a,ue(ve()));var S=Kc(n,function(T,E,D){var W=Ke(a,function(q){return q(T)});return{criteria:W,index:++y,value:T}});return L(S,function(T,E){return zg(T,E,h)})}function kg(n,a){return Zc(n,a,function(h,y){return ul(n,y)})}function Zc(n,a,h){for(var y=-1,S=a.length,T={};++y<S;){var E=a[y],D=es(n,E);h(D,E)&&ta(T,In(E,n),D)}return T}function _g(n){return function(a){return es(a,n)}}function Ou(n,a,h,y){var S=y?g:c,T=-1,E=a.length,D=n;for(n===a&&(a=Gt(a)),h&&(D=Ke(n,ue(h)));++T<E;)for(var W=0,q=a[T],X=h?h(q):q;(W=S(D,X,W,y))>-1;)D!==n&&oo.call(D,W,1),oo.call(n,W,1);return n}function Jc(n,a){for(var h=n?a.length:0,y=h-1;h--;){var S=a[h];if(h==y||S!==T){var T=S;Jr(S)?oo.call(n,S,1):Bu(n,S)}}return n}function Fu(n,a){return n+co(Ec()*(a-n+1))}function Tg(n,a,h,y){for(var S=-1,T=bt(lo((a-n)/(h||1)),0),E=H(T);T--;)E[y?T:++S]=n,n+=h;return E}function Lu(n,a){var h="";if(!n||a<1||a>nt)return h;do a%2&&(h+=n),a=co(a/2),a&&(n+=n);while(a);return h}function $e(n,a){return el(Rh(n,a,qt),n+"")}function Rg(n){return Fc(ei(n))}function Ag(n,a){var h=ei(n);return To(h,Jn(a,0,h.length))}function ta(n,a,h,y){if(!ot(n))return n;a=In(a,n);for(var S=-1,T=a.length,E=T-1,D=n;D!=null&&++S<T;){var W=Pr(a[S]),q=h;if(W==="__proto__"||W==="constructor"||W==="prototype")return n;if(S!=E){var X=D[W];q=y?y(X,W,D):e,q===e&&(q=ot(X)?X:Jr(a[S+1])?[]:{})}Qi(D,W,q),D=D[W]}return n}var eh=ho?function(n,a){return ho.set(n,a),n}:qt,Pg=uo?function(n,a){return uo(n,"toString",{configurable:!0,enumerable:!1,value:cl(a),writable:!0})}:qt;function $g(n){return To(ei(n))}function dr(n,a,h){var y=-1,S=n.length;a<0&&(a=-a>S?0:S+a),h=h>S?S:h,h<0&&(h+=S),S=a>h?0:h-a>>>0,a>>>=0;for(var T=H(S);++y<S;)T[y]=n[y+a];return T}function Eg(n,a){var h;return Cn(n,function(y,S,T){return h=a(y,S,T),!h}),!!h}function vo(n,a,h){var y=0,S=n==null?y:n.length;if(typeof a=="number"&&a===a&&S<=Dn){for(;y<S;){var T=y+S>>>1,E=n[T];E!==null&&!nr(E)&&(h?E<=a:E<a)?y=T+1:S=T}return S}return zu(n,a,qt,h)}function zu(n,a,h,y){var S=0,T=n==null?0:n.length;if(T===0)return 0;a=h(a);for(var E=a!==a,D=a===null,W=nr(a),q=a===e;S<T;){var X=co((S+T)/2),Q=h(n[X]),oe=Q!==e,fe=Q===null,be=Q===Q,Pe=nr(Q);if(E)var xe=y||be;else q?xe=be&&(y||oe):D?xe=be&&oe&&(y||!fe):W?xe=be&&oe&&!fe&&(y||!Pe):fe||Pe?xe=!1:xe=y?Q<=a:Q<a;xe?S=X+1:T=X}return At(T,En)}function th(n,a){for(var h=-1,y=n.length,S=0,T=[];++h<y;){var E=n[h],D=a?a(E):E;if(!h||!xr(D,W)){var W=D;T[S++]=E===0?0:E}}return T}function rh(n){return typeof n=="number"?n:nr(n)?Ot:+n}function rr(n){if(typeof n=="string")return n;if(ke(n))return Ke(n,rr)+"";if(nr(n))return Dc?Dc.call(n):"";var a=n+"";return a=="0"&&1/n==-rt?"-0":a}function Nn(n,a,h){var y=-1,S=Vs,T=n.length,E=!0,D=[],W=D;if(h)E=!1,S=Ui;else if(T>=i){var q=a?null:Hg(n);if(q)return Us(q);E=!1,S=ge,W=new Zn}else W=a?[]:D;e:for(;++y<T;){var X=n[y],Q=a?a(X):X;if(X=h||X!==0?X:0,E&&Q===Q){for(var oe=W.length;oe--;)if(W[oe]===Q)continue e;a&&W.push(Q),D.push(X)}else S(W,Q,h)||(W!==D&&W.push(Q),D.push(X))}return D}function Bu(n,a){return a=In(a,n),n=Ah(n,a),n==null||delete n[Pr(fr(a))]}function nh(n,a,h,y){return ta(n,a,h(es(n,a)),y)}function bo(n,a,h,y){for(var S=n.length,T=y?S:-1;(y?T--:++T<S)&&a(n[T],T,n););return h?dr(n,y?0:T,y?T+1:S):dr(n,y?T+1:0,y?S:T)}function sh(n,a){var h=n;return h instanceof De&&(h=h.value()),Mi(a,function(y,S){return S.func.apply(S.thisArg,kr([y],S.args))},h)}function Wu(n,a,h){var y=n.length;if(y<2)return y?Nn(n[0]):[];for(var S=-1,T=H(y);++S<y;)for(var E=n[S],D=-1;++D<y;)D!=S&&(T[S]=Zi(T[S]||E,n[D],a,h));return Nn(_t(T,1),a,h)}function ih(n,a,h){for(var y=-1,S=n.length,T=a.length,E={};++y<S;){var D=y<T?a[y]:e;h(E,n[y],D)}return E}function Vu(n){return dt(n)?n:[]}function Uu(n){return typeof n=="function"?n:qt}function In(n,a){return ke(n)?n:Qu(n,a)?[n]:Dh(Me(n))}var Dg=$e;function kn(n,a,h){var y=n.length;return h=h===e?y:h,!a&&h>=y?n:dr(n,a,h)}var ah=xm||function(n){return yt.clearTimeout(n)};function oh(n,a){if(a)return n.slice();var h=n.length,y=Tc?Tc(h):new n.constructor(h);return n.copy(y),y}function Mu(n){var a=new n.constructor(n.byteLength);return new io(a).set(new io(n)),a}function Og(n,a){var h=a?Mu(n.buffer):n.buffer;return new n.constructor(h,n.byteOffset,n.byteLength)}function Fg(n){var a=new n.constructor(n.source,Bn.exec(n));return a.lastIndex=n.lastIndex,a}function Lg(n){return Yi?et(Yi.call(n)):{}}function uh(n,a){var h=a?Mu(n.buffer):n.buffer;return new n.constructor(h,n.byteOffset,n.length)}function lh(n,a){if(n!==a){var h=n!==e,y=n===null,S=n===n,T=nr(n),E=a!==e,D=a===null,W=a===a,q=nr(a);if(!D&&!q&&!T&&n>a||T&&E&&W&&!D&&!q||y&&E&&W||!h&&W||!S)return 1;if(!y&&!T&&!q&&n<a||q&&h&&S&&!y&&!T||D&&h&&S||!E&&S||!W)return-1}return 0}function zg(n,a,h){for(var y=-1,S=n.criteria,T=a.criteria,E=S.length,D=h.length;++y<E;){var W=lh(S[y],T[y]);if(W){if(y>=D)return W;var q=h[y];return W*(q=="desc"?-1:1)}}return n.index-a.index}function ch(n,a,h,y){for(var S=-1,T=n.length,E=h.length,D=-1,W=a.length,q=bt(T-E,0),X=H(W+q),Q=!y;++D<W;)X[D]=a[D];for(;++S<E;)(Q||S<T)&&(X[h[S]]=n[S]);for(;q--;)X[D++]=n[S++];return X}function hh(n,a,h,y){for(var S=-1,T=n.length,E=-1,D=h.length,W=-1,q=a.length,X=bt(T-D,0),Q=H(X+q),oe=!y;++S<X;)Q[S]=n[S];for(var fe=S;++W<q;)Q[fe+W]=a[W];for(;++E<D;)(oe||S<T)&&(Q[fe+h[E]]=n[S++]);return Q}function Gt(n,a){var h=-1,y=n.length;for(a||(a=H(y));++h<y;)a[h]=n[h];return a}function Ar(n,a,h,y){var S=!h;h||(h={});for(var T=-1,E=a.length;++T<E;){var D=a[T],W=y?y(h[D],n[D],D,h,n):e;W===e&&(W=n[D]),S?Yr(h,D,W):Qi(h,D,W)}return h}function Bg(n,a){return Ar(n,Yu(n),a)}function Wg(n,a){return Ar(n,Nh(n),a)}function xo(n,a){return function(h,y){var S=ke(h)?mu:ug,T=a?a():{};return S(h,n,ve(y,2),T)}}function Ys(n){return $e(function(a,h){var y=-1,S=h.length,T=S>1?h[S-1]:e,E=S>2?h[2]:e;for(T=n.length>3&&typeof T=="function"?(S--,T):e,E&&Bt(h[0],h[1],E)&&(T=S<3?e:T,S=1),a=et(a);++y<S;){var D=h[y];D&&n(a,D,y,T)}return a})}function ph(n,a){return function(h,y){if(h==null)return h;if(!jt(h))return n(h,y);for(var S=h.length,T=a?S:-1,E=et(h);(a?T--:++T<S)&&y(E[T],T,E)!==!1;);return h}}function dh(n){return function(a,h,y){for(var S=-1,T=et(a),E=y(a),D=E.length;D--;){var W=E[n?D:++S];if(h(T[W],W,T)===!1)break}return a}}function Vg(n,a,h){var y=a&k,S=ra(n);function T(){var E=this&&this!==yt&&this instanceof T?S:n;return E.apply(y?h:this,arguments)}return T}function fh(n){return function(a){a=Me(a);var h=st(a)?vr(a):e,y=h?h[0]:a.charAt(0),S=h?kn(h,1).join(""):a.slice(1);return y[n]()+S}}function Qs(n){return function(a){return Mi(pp(hp(a).replace(hu,"")),n,"")}}function ra(n){return function(){var a=arguments;switch(a.length){case 0:return new n;case 1:return new n(a[0]);case 2:return new n(a[0],a[1]);case 3:return new n(a[0],a[1],a[2]);case 4:return new n(a[0],a[1],a[2],a[3]);case 5:return new n(a[0],a[1],a[2],a[3],a[4]);case 6:return new n(a[0],a[1],a[2],a[3],a[4],a[5]);case 7:return new n(a[0],a[1],a[2],a[3],a[4],a[5],a[6])}var h=Xs(n.prototype),y=n.apply(h,a);return ot(y)?y:h}}function Ug(n,a,h){var y=ra(n);function S(){for(var T=arguments.length,E=H(T),D=T,W=Zs(S);D--;)E[D]=arguments[D];var q=T<3&&E[0]!==W&&E[T-1]!==W?[]:Tr(E,W);if(T-=q.length,T<h)return vh(n,a,So,S.placeholder,e,E,q,e,e,h-T);var X=this&&this!==yt&&this instanceof S?y:n;return Tt(X,this,E)}return S}function mh(n){return function(a,h,y){var S=et(a);if(!jt(a)){var T=ve(h,3);a=Ct(a),h=function(D){return T(S[D],D,S)}}var E=n(a,h,y);return E>-1?S[T?a[E]:E]:e}}function gh(n){return Zr(function(a){var h=a.length,y=h,S=hr.prototype.thru;for(n&&a.reverse();y--;){var T=a[y];if(typeof T!="function")throw new cr(u);if(S&&!E&&ko(T)=="wrapper")var E=new hr([],!0)}for(y=E?y:h;++y<h;){T=a[y];var D=ko(T),W=D=="wrapper"?qu(T):e;W&&Zu(W[0])&&W[1]==(M|z|V|Y)&&!W[4].length&&W[9]==1?E=E[ko(W[0])].apply(E,W[3]):E=T.length==1&&Zu(T)?E[D]():E.thru(T)}return function(){var q=arguments,X=q[0];if(E&&q.length==1&&ke(X))return E.plant(X).value();for(var Q=0,oe=h?a[Q].apply(this,q):X;++Q<h;)oe=a[Q].call(this,oe);return oe}})}function So(n,a,h,y,S,T,E,D,W,q){var X=a&M,Q=a&k,oe=a&P,fe=a&(z|F),be=a&K,Pe=oe?e:ra(n);function xe(){for(var Ee=arguments.length,Le=H(Ee),sr=Ee;sr--;)Le[sr]=arguments[sr];if(fe)var Wt=Zs(xe),ir=Xe(Le,Wt);if(y&&(Le=ch(Le,y,S,fe)),T&&(Le=hh(Le,T,E,fe)),Ee-=ir,fe&&Ee<q){var ft=Tr(Le,Wt);return vh(n,a,So,xe.placeholder,h,Le,ft,D,W,q-Ee)}var Sr=Q?h:this,rn=oe?Sr[n]:n;return Ee=Le.length,D?Le=uy(Le,D):be&&Ee>1&&Le.reverse(),X&&W<Ee&&(Le.length=W),this&&this!==yt&&this instanceof xe&&(rn=Pe||ra(rn)),rn.apply(Sr,Le)}return xe}function yh(n,a){return function(h,y){return gg(h,n,a(y),{})}}function Co(n,a){return function(h,y){var S;if(h===e&&y===e)return a;if(h!==e&&(S=h),y!==e){if(S===e)return y;typeof h=="string"||typeof y=="string"?(h=rr(h),y=rr(y)):(h=rh(h),y=rh(y)),S=n(h,y)}return S}}function Hu(n){return Zr(function(a){return a=Ke(a,ue(ve())),$e(function(h){var y=this;return n(a,function(S){return Tt(S,y,h)})})})}function No(n,a){a=a===e?" ":rr(a);var h=a.length;if(h<2)return h?Lu(a,n):a;var y=Lu(a,lo(n/Hs(a)));return st(a)?kn(vr(y),0,n).join(""):y.slice(0,n)}function Mg(n,a,h,y){var S=a&k,T=ra(n);function E(){for(var D=-1,W=arguments.length,q=-1,X=y.length,Q=H(X+W),oe=this&&this!==yt&&this instanceof E?T:n;++q<X;)Q[q]=y[q];for(;W--;)Q[q++]=arguments[++D];return Tt(oe,S?h:this,Q)}return E}function wh(n){return function(a,h,y){return y&&typeof y!="number"&&Bt(a,h,y)&&(h=y=e),a=tn(a),h===e?(h=a,a=0):h=tn(h),y=y===e?a<h?1:-1:tn(y),Tg(a,h,y,n)}}function Io(n){return function(a,h){return typeof a=="string"&&typeof h=="string"||(a=mr(a),h=mr(h)),n(a,h)}}function vh(n,a,h,y,S,T,E,D,W,q){var X=a&z,Q=X?E:e,oe=X?e:E,fe=X?T:e,be=X?e:T;a|=X?V:G,a&=~(X?G:V),a&O||(a&=-4);var Pe=[n,a,S,fe,Q,be,oe,D,W,q],xe=h.apply(e,Pe);return Zu(n)&&Ph(xe,Pe),xe.placeholder=y,$h(xe,n,a)}function Gu(n){var a=vt[n];return function(h,y){if(h=mr(h),y=y==null?0:At(Re(y),292),y&&$c(h)){var S=(Me(h)+"e").split("e"),T=a(S[0]+"e"+(+S[1]+y));return S=(Me(T)+"e").split("e"),+(S[0]+"e"+(+S[1]-y))}return a(h)}}var Hg=Ks&&1/Us(new Ks([,-0]))[1]==rt?function(n){return new Ks(n)}:dl;function bh(n){return function(a){var h=Pt(a);return h==Je?Gi(a):h==Ut?Ms(a):se(a,n(a))}}function Qr(n,a,h,y,S,T,E,D){var W=a&P;if(!W&&typeof n!="function")throw new cr(u);var q=y?y.length:0;if(q||(a&=-97,y=S=e),E=E===e?E:bt(Re(E),0),D=D===e?D:Re(D),q-=S?S.length:0,a&G){var X=y,Q=S;y=S=e}var oe=W?e:qu(n),fe=[n,a,h,y,S,X,Q,T,E,D];if(oe&&iy(fe,oe),n=fe[0],a=fe[1],h=fe[2],y=fe[3],S=fe[4],D=fe[9]=fe[9]===e?W?0:n.length:bt(fe[9]-q,0),!D&&a&(z|F)&&(a&=-25),!a||a==k)var be=Vg(n,a,h);else a==z||a==F?be=Ug(n,a,D):(a==V||a==(k|V))&&!S.length?be=Mg(n,a,h,y):be=So.apply(e,fe);var Pe=oe?eh:Ph;return $h(Pe(be,fe),n,a)}function xh(n,a,h,y){return n===e||xr(n,js[h])&&!Ge.call(y,h)?a:n}function Sh(n,a,h,y,S,T){return ot(n)&&ot(a)&&(T.set(a,n),wo(n,a,e,Sh,T),T.delete(a)),n}function Gg(n){return ia(n)?e:n}function Ch(n,a,h,y,S,T){var E=h&C,D=n.length,W=a.length;if(D!=W&&!(E&&W>D))return!1;var q=T.get(n),X=T.get(a);if(q&&X)return q==a&&X==n;var Q=-1,oe=!0,fe=h&I?new Zn:e;for(T.set(n,a),T.set(a,n);++Q<D;){var be=n[Q],Pe=a[Q];if(y)var xe=E?y(Pe,be,Q,a,n,T):y(be,Pe,Q,n,a,T);if(xe!==e){if(xe)continue;oe=!1;break}if(fe){if(!xn(a,function(Ee,Le){if(!ge(fe,Le)&&(be===Ee||S(be,Ee,h,y,T)))return fe.push(Le)})){oe=!1;break}}else if(!(be===Pe||S(be,Pe,h,y,T))){oe=!1;break}}return T.delete(n),T.delete(a),oe}function jg(n,a,h,y,S,T,E){switch(h){case gn:if(n.byteLength!=a.byteLength||n.byteOffset!=a.byteOffset)return!1;n=n.buffer,a=a.buffer;case Vr:return!(n.byteLength!=a.byteLength||!T(new io(n),new io(a)));case hn:case pn:case dn:return xr(+n,+a);case Nr:return n.name==a.name&&n.message==a.message;case fn:case Br:return n==a+"";case Je:var D=Gi;case Ut:var W=y&C;if(D||(D=Us),n.size!=a.size&&!W)return!1;var q=E.get(n);if(q)return q==a;y|=I,E.set(n,a);var X=Ch(D(n),D(a),y,S,T,E);return E.delete(n),X;case Fn:if(Yi)return Yi.call(n)==Yi.call(a)}return!1}function Kg(n,a,h,y,S,T){var E=h&C,D=ju(n),W=D.length,q=ju(a),X=q.length;if(W!=X&&!E)return!1;for(var Q=W;Q--;){var oe=D[Q];if(!(E?oe in a:Ge.call(a,oe)))return!1}var fe=T.get(n),be=T.get(a);if(fe&&be)return fe==a&&be==n;var Pe=!0;T.set(n,a),T.set(a,n);for(var xe=E;++Q<W;){oe=D[Q];var Ee=n[oe],Le=a[oe];if(y)var sr=E?y(Le,Ee,oe,a,n,T):y(Ee,Le,oe,n,a,T);if(!(sr===e?Ee===Le||S(Ee,Le,h,y,T):sr)){Pe=!1;break}xe||(xe=oe=="constructor")}if(Pe&&!xe){var Wt=n.constructor,ir=a.constructor;Wt!=ir&&"constructor"in n&&"constructor"in a&&!(typeof Wt=="function"&&Wt instanceof Wt&&typeof ir=="function"&&ir instanceof ir)&&(Pe=!1)}return T.delete(n),T.delete(a),Pe}function Zr(n){return el(Rh(n,e,zh),n+"")}function ju(n){return Mc(n,Ct,Yu)}function Ku(n){return Mc(n,Kt,Nh)}var qu=ho?function(n){return ho.get(n)}:dl;function ko(n){for(var a=n.name+"",h=qs[a],y=Ge.call(qs,a)?h.length:0;y--;){var S=h[y],T=S.func;if(T==null||T==n)return S.name}return a}function Zs(n){var a=Ge.call(_,"placeholder")?_:n;return a.placeholder}function ve(){var n=_.iteratee||hl;return n=n===hl?jc:n,arguments.length?n(arguments[0],arguments[1]):n}function _o(n,a){var h=n.__data__;return ty(a)?h[typeof a=="string"?"string":"hash"]:h.map}function Xu(n){for(var a=Ct(n),h=a.length;h--;){var y=a[h],S=n[y];a[h]=[y,S,_h(S)]}return a}function ts(n,a){var h=Be(n,a);return Gc(h)?h:e}function qg(n){var a=Ge.call(n,Yn),h=n[Yn];try{n[Yn]=e;var y=!0}catch{}var S=no.call(n);return y&&(a?n[Yn]=h:delete n[Yn]),S}var Yu=Cu?function(n){return n==null?[]:(n=et(n),wr(Cu(n),function(a){return Ac.call(n,a)}))}:fl,Nh=Cu?function(n){for(var a=[];n;)kr(a,Yu(n)),n=ao(n);return a}:fl,Pt=zt;(Nu&&Pt(new Nu(new ArrayBuffer(1)))!=gn||Ki&&Pt(new Ki)!=Je||Iu&&Pt(Iu.resolve())!=gi||Ks&&Pt(new Ks)!=Ut||qi&&Pt(new qi)!=mn)&&(Pt=function(n){var a=zt(n),h=a==or?n.constructor:e,y=h?rs(h):"";if(y)switch(y){case Am:return gn;case Pm:return Je;case $m:return gi;case Em:return Ut;case Dm:return mn}return a});function Xg(n,a,h){for(var y=-1,S=h.length;++y<S;){var T=h[y],E=T.size;switch(T.type){case"drop":n+=E;break;case"dropRight":a-=E;break;case"take":a=At(a,n+E);break;case"takeRight":n=bt(n,a-E);break}}return{start:n,end:a}}function Yg(n){var a=n.match(at);return a?a[1].split(ur):[]}function Ih(n,a,h){a=In(a,n);for(var y=-1,S=a.length,T=!1;++y<S;){var E=Pr(a[y]);if(!(T=n!=null&&h(n,E)))break;n=n[E]}return T||++y!=S?T:(S=n==null?0:n.length,!!S&&Do(S)&&Jr(E,S)&&(ke(n)||ns(n)))}function Qg(n){var a=n.length,h=new n.constructor(a);return a&&typeof n[0]=="string"&&Ge.call(n,"index")&&(h.index=n.index,h.input=n.input),h}function kh(n){return typeof n.constructor=="function"&&!na(n)?Xs(ao(n)):{}}function Zg(n,a,h){var y=n.constructor;switch(a){case Vr:return Mu(n);case hn:case pn:return new y(+n);case gn:return Og(n,h);case Ns:case yi:case Is:case ks:case Ur:case Ln:case _s:case wi:case Ts:return uh(n,h);case Je:return new y;case dn:case Br:return new y(n);case fn:return Fg(n);case Ut:return new y;case Fn:return Lg(n)}}function Jg(n,a){var h=a.length;if(!h)return n;var y=h-1;return a[y]=(h>1?"& ":"")+a[y],a=a.join(h>2?", ":" "),n.replace(Ra,`{
/* [wrapped with `+a+`] */
`)}function ey(n){return ke(n)||ns(n)||!!(Pc&&n&&n[Pc])}function Jr(n,a){var h=typeof n;return a=a??nt,!!a&&(h=="number"||h!="symbol"&&Pa.test(n))&&n>-1&&n%1==0&&n<a}function Bt(n,a,h){if(!ot(h))return!1;var y=typeof a;return(y=="number"?jt(h)&&Jr(a,h.length):y=="string"&&a in h)?xr(h[a],n):!1}function Qu(n,a){if(ke(n))return!1;var h=typeof n;return h=="number"||h=="symbol"||h=="boolean"||n==null||nr(n)?!0:As.test(n)||!Rs.test(n)||a!=null&&n in et(a)}function ty(n){var a=typeof n;return a=="string"||a=="number"||a=="symbol"||a=="boolean"?n!=="__proto__":n===null}function Zu(n){var a=ko(n),h=_[a];if(typeof h!="function"||!(a in De.prototype))return!1;if(n===h)return!0;var y=qu(h);return!!y&&n===y[0]}function ry(n){return!!_c&&_c in n}var ny=to?en:ml;function na(n){var a=n&&n.constructor,h=typeof a=="function"&&a.prototype||js;return n===h}function _h(n){return n===n&&!ot(n)}function Th(n,a){return function(h){return h==null?!1:h[n]===a&&(a!==e||n in et(h))}}function sy(n){var a=$o(n,function(y){return h.size===d&&h.clear(),y}),h=a.cache;return a}function iy(n,a){var h=n[1],y=a[1],S=h|y,T=S<(k|P|M),E=y==M&&h==z||y==M&&h==Y&&n[7].length<=a[8]||y==(M|Y)&&a[7].length<=a[8]&&h==z;if(!(T||E))return n;y&k&&(n[2]=a[2],S|=h&k?0:O);var D=a[3];if(D){var W=n[3];n[3]=W?ch(W,D,a[4]):D,n[4]=W?Tr(n[3],f):a[4]}return D=a[5],D&&(W=n[5],n[5]=W?hh(W,D,a[6]):D,n[6]=W?Tr(n[5],f):a[6]),D=a[7],D&&(n[7]=D),y&M&&(n[8]=n[8]==null?a[8]:At(n[8],a[8])),n[9]==null&&(n[9]=a[9]),n[0]=a[0],n[1]=S,n}function ay(n){var a=[];if(n!=null)for(var h in et(n))a.push(h);return a}function oy(n){return no.call(n)}function Rh(n,a,h){return a=bt(a===e?n.length-1:a,0),function(){for(var y=arguments,S=-1,T=bt(y.length-a,0),E=H(T);++S<T;)E[S]=y[a+S];S=-1;for(var D=H(a+1);++S<a;)D[S]=y[S];return D[a]=h(E),Tt(n,this,D)}}function Ah(n,a){return a.length<2?n:es(n,dr(a,0,-1))}function uy(n,a){for(var h=n.length,y=At(a.length,h),S=Gt(n);y--;){var T=a[y];n[y]=Jr(T,h)?S[T]:e}return n}function Ju(n,a){if(!(a==="constructor"&&typeof n[a]=="function")&&a!="__proto__")return n[a]}var Ph=Eh(eh),sa=Cm||function(n,a){return yt.setTimeout(n,a)},el=Eh(Pg);function $h(n,a,h){var y=a+"";return el(n,Jg(y,ly(Yg(y),h)))}function Eh(n){var a=0,h=0;return function(){var y=_m(),S=ce-(y-h);if(h=y,S>0){if(++a>=me)return arguments[0]}else a=0;return n.apply(e,arguments)}}function To(n,a){var h=-1,y=n.length,S=y-1;for(a=a===e?y:a;++h<a;){var T=Fu(h,S),E=n[T];n[T]=n[h],n[h]=E}return n.length=a,n}var Dh=sy(function(n){var a=[];return n.charCodeAt(0)===46&&a.push(""),n.replace(su,function(h,y,S,T){a.push(S?T.replace(Ps,"$1"):y||h)}),a});function Pr(n){if(typeof n=="string"||nr(n))return n;var a=n+"";return a=="0"&&1/n==-rt?"-0":a}function rs(n){if(n!=null){try{return ro.call(n)}catch{}try{return n+""}catch{}}return""}function ly(n,a){return Mt(xs,function(h){var y="_."+h[0];a&h[1]&&!Vs(n,y)&&n.push(y)}),n.sort()}function Oh(n){if(n instanceof De)return n.clone();var a=new hr(n.__wrapped__,n.__chain__);return a.__actions__=Gt(n.__actions__),a.__index__=n.__index__,a.__values__=n.__values__,a}function cy(n,a,h){(h?Bt(n,a,h):a===e)?a=1:a=bt(Re(a),0);var y=n==null?0:n.length;if(!y||a<1)return[];for(var S=0,T=0,E=H(lo(y/a));S<y;)E[T++]=dr(n,S,S+=a);return E}function hy(n){for(var a=-1,h=n==null?0:n.length,y=0,S=[];++a<h;){var T=n[a];T&&(S[y++]=T)}return S}function py(){var n=arguments.length;if(!n)return[];for(var a=H(n-1),h=arguments[0],y=n;y--;)a[y-1]=arguments[y];return kr(ke(h)?Gt(h):[h],_t(a,1))}var dy=$e(function(n,a){return dt(n)?Zi(n,_t(a,1,dt,!0)):[]}),fy=$e(function(n,a){var h=fr(a);return dt(h)&&(h=e),dt(n)?Zi(n,_t(a,1,dt,!0),ve(h,2)):[]}),my=$e(function(n,a){var h=fr(a);return dt(h)&&(h=e),dt(n)?Zi(n,_t(a,1,dt,!0),e,h):[]});function gy(n,a,h){var y=n==null?0:n.length;return y?(a=h||a===e?1:Re(a),dr(n,a<0?0:a,y)):[]}function yy(n,a,h){var y=n==null?0:n.length;return y?(a=h||a===e?1:Re(a),a=y-a,dr(n,0,a<0?0:a)):[]}function wy(n,a){return n&&n.length?bo(n,ve(a,3),!0,!0):[]}function vy(n,a){return n&&n.length?bo(n,ve(a,3),!0):[]}function by(n,a,h,y){var S=n==null?0:n.length;return S?(h&&typeof h!="number"&&Bt(n,a,h)&&(h=0,y=S),pg(n,a,h,y)):[]}function Fh(n,a,h){var y=n==null?0:n.length;if(!y)return-1;var S=h==null?0:Re(h);return S<0&&(S=bt(y+S,0)),Xn(n,ve(a,3),S)}function Lh(n,a,h){var y=n==null?0:n.length;if(!y)return-1;var S=y-1;return h!==e&&(S=Re(h),S=h<0?bt(y+S,0):At(S,y-1)),Xn(n,ve(a,3),S,!0)}function zh(n){var a=n==null?0:n.length;return a?_t(n,1):[]}function xy(n){var a=n==null?0:n.length;return a?_t(n,rt):[]}function Sy(n,a){var h=n==null?0:n.length;return h?(a=a===e?1:Re(a),_t(n,a)):[]}function Cy(n){for(var a=-1,h=n==null?0:n.length,y={};++a<h;){var S=n[a];y[S[0]]=S[1]}return y}function Bh(n){return n&&n.length?n[0]:e}function Ny(n,a,h){var y=n==null?0:n.length;if(!y)return-1;var S=h==null?0:Re(h);return S<0&&(S=bt(y+S,0)),c(n,a,S)}function Iy(n){var a=n==null?0:n.length;return a?dr(n,0,-1):[]}var ky=$e(function(n){var a=Ke(n,Vu);return a.length&&a[0]===n[0]?Pu(a):[]}),_y=$e(function(n){var a=fr(n),h=Ke(n,Vu);return a===fr(h)?a=e:h.pop(),h.length&&h[0]===n[0]?Pu(h,ve(a,2)):[]}),Ty=$e(function(n){var a=fr(n),h=Ke(n,Vu);return a=typeof a=="function"?a:e,a&&h.pop(),h.length&&h[0]===n[0]?Pu(h,e,a):[]});function Ry(n,a){return n==null?"":Im.call(n,a)}function fr(n){var a=n==null?0:n.length;return a?n[a-1]:e}function Ay(n,a,h){var y=n==null?0:n.length;if(!y)return-1;var S=y;return h!==e&&(S=Re(h),S=S<0?bt(y+S,0):At(S,y-1)),a===a?lm(n,a,S):Xn(n,b,S,!0)}function Py(n,a){return n&&n.length?Yc(n,Re(a)):e}var $y=$e(Wh);function Wh(n,a){return n&&n.length&&a&&a.length?Ou(n,a):n}function Ey(n,a,h){return n&&n.length&&a&&a.length?Ou(n,a,ve(h,2)):n}function Dy(n,a,h){return n&&n.length&&a&&a.length?Ou(n,a,e,h):n}var Oy=Zr(function(n,a){var h=n==null?0:n.length,y=_u(n,a);return Jc(n,Ke(a,function(S){return Jr(S,h)?+S:S}).sort(lh)),y});function Fy(n,a){var h=[];if(!(n&&n.length))return h;var y=-1,S=[],T=n.length;for(a=ve(a,3);++y<T;){var E=n[y];a(E,y,n)&&(h.push(E),S.push(y))}return Jc(n,S),h}function tl(n){return n==null?n:Rm.call(n)}function Ly(n,a,h){var y=n==null?0:n.length;return y?(h&&typeof h!="number"&&Bt(n,a,h)?(a=0,h=y):(a=a==null?0:Re(a),h=h===e?y:Re(h)),dr(n,a,h)):[]}function zy(n,a){return vo(n,a)}function By(n,a,h){return zu(n,a,ve(h,2))}function Wy(n,a){var h=n==null?0:n.length;if(h){var y=vo(n,a);if(y<h&&xr(n[y],a))return y}return-1}function Vy(n,a){return vo(n,a,!0)}function Uy(n,a,h){return zu(n,a,ve(h,2),!0)}function My(n,a){var h=n==null?0:n.length;if(h){var y=vo(n,a,!0)-1;if(xr(n[y],a))return y}return-1}function Hy(n){return n&&n.length?th(n):[]}function Gy(n,a){return n&&n.length?th(n,ve(a,2)):[]}function jy(n){var a=n==null?0:n.length;return a?dr(n,1,a):[]}function Ky(n,a,h){return n&&n.length?(a=h||a===e?1:Re(a),dr(n,0,a<0?0:a)):[]}function qy(n,a,h){var y=n==null?0:n.length;return y?(a=h||a===e?1:Re(a),a=y-a,dr(n,a<0?0:a,y)):[]}function Xy(n,a){return n&&n.length?bo(n,ve(a,3),!1,!0):[]}function Yy(n,a){return n&&n.length?bo(n,ve(a,3)):[]}var Qy=$e(function(n){return Nn(_t(n,1,dt,!0))}),Zy=$e(function(n){var a=fr(n);return dt(a)&&(a=e),Nn(_t(n,1,dt,!0),ve(a,2))}),Jy=$e(function(n){var a=fr(n);return a=typeof a=="function"?a:e,Nn(_t(n,1,dt,!0),e,a)});function e0(n){return n&&n.length?Nn(n):[]}function t0(n,a){return n&&n.length?Nn(n,ve(a,2)):[]}function r0(n,a){return a=typeof a=="function"?a:e,n&&n.length?Nn(n,e,a):[]}function rl(n){if(!(n&&n.length))return[];var a=0;return n=wr(n,function(h){if(dt(h))return a=bt(h.length,a),!0}),Z(a,function(h){return Ke(n,R(h))})}function Vh(n,a){if(!(n&&n.length))return[];var h=rl(n);return a==null?h:Ke(h,function(y){return Tt(a,e,y)})}var n0=$e(function(n,a){return dt(n)?Zi(n,a):[]}),s0=$e(function(n){return Wu(wr(n,dt))}),i0=$e(function(n){var a=fr(n);return dt(a)&&(a=e),Wu(wr(n,dt),ve(a,2))}),a0=$e(function(n){var a=fr(n);return a=typeof a=="function"?a:e,Wu(wr(n,dt),e,a)}),o0=$e(rl);function u0(n,a){return ih(n||[],a||[],Qi)}function l0(n,a){return ih(n||[],a||[],ta)}var c0=$e(function(n){var a=n.length,h=a>1?n[a-1]:e;return h=typeof h=="function"?(n.pop(),h):e,Vh(n,h)});function Uh(n){var a=_(n);return a.__chain__=!0,a}function h0(n,a){return a(n),n}function Ro(n,a){return a(n)}var p0=Zr(function(n){var a=n.length,h=a?n[0]:0,y=this.__wrapped__,S=function(T){return _u(T,n)};return a>1||this.__actions__.length||!(y instanceof De)||!Jr(h)?this.thru(S):(y=y.slice(h,+h+(a?1:0)),y.__actions__.push({func:Ro,args:[S],thisArg:e}),new hr(y,this.__chain__).thru(function(T){return a&&!T.length&&T.push(e),T}))});function d0(){return Uh(this)}function f0(){return new hr(this.value(),this.__chain__)}function m0(){this.__values__===e&&(this.__values__=rp(this.value()));var n=this.__index__>=this.__values__.length,a=n?e:this.__values__[this.__index__++];return{done:n,value:a}}function g0(){return this}function y0(n){for(var a,h=this;h instanceof fo;){var y=Oh(h);y.__index__=0,y.__values__=e,a?S.__wrapped__=y:a=y;var S=y;h=h.__wrapped__}return S.__wrapped__=n,a}function w0(){var n=this.__wrapped__;if(n instanceof De){var a=n;return this.__actions__.length&&(a=new De(this)),a=a.reverse(),a.__actions__.push({func:Ro,args:[tl],thisArg:e}),new hr(a,this.__chain__)}return this.thru(tl)}function v0(){return sh(this.__wrapped__,this.__actions__)}var b0=xo(function(n,a,h){Ge.call(n,h)?++n[h]:Yr(n,h,1)});function x0(n,a,h){var y=ke(n)?Za:hg;return h&&Bt(n,a,h)&&(a=e),y(n,ve(a,3))}function S0(n,a){var h=ke(n)?wr:Vc;return h(n,ve(a,3))}var C0=mh(Fh),N0=mh(Lh);function I0(n,a){return _t(Ao(n,a),1)}function k0(n,a){return _t(Ao(n,a),rt)}function _0(n,a,h){return h=h===e?1:Re(h),_t(Ao(n,a),h)}function Mh(n,a){var h=ke(n)?Mt:Cn;return h(n,ve(a,3))}function Hh(n,a){var h=ke(n)?gu:Wc;return h(n,ve(a,3))}var T0=xo(function(n,a,h){Ge.call(n,h)?n[h].push(a):Yr(n,h,[a])});function R0(n,a,h,y){n=jt(n)?n:ei(n),h=h&&!y?Re(h):0;var S=n.length;return h<0&&(h=bt(S+h,0)),Oo(n)?h<=S&&n.indexOf(a,h)>-1:!!S&&c(n,a,h)>-1}var A0=$e(function(n,a,h){var y=-1,S=typeof a=="function",T=jt(n)?H(n.length):[];return Cn(n,function(E){T[++y]=S?Tt(a,E,h):Ji(E,a,h)}),T}),P0=xo(function(n,a,h){Yr(n,h,a)});function Ao(n,a){var h=ke(n)?Ke:Kc;return h(n,ve(a,3))}function $0(n,a,h,y){return n==null?[]:(ke(a)||(a=a==null?[]:[a]),h=y?e:h,ke(h)||(h=h==null?[]:[h]),Qc(n,a,h))}var E0=xo(function(n,a,h){n[h?0:1].push(a)},function(){return[[],[]]});function D0(n,a,h){var y=ke(n)?Mi:A,S=arguments.length<3;return y(n,ve(a,4),h,S,Cn)}function O0(n,a,h){var y=ke(n)?yu:A,S=arguments.length<3;return y(n,ve(a,4),h,S,Wc)}function F0(n,a){var h=ke(n)?wr:Vc;return h(n,Eo(ve(a,3)))}function L0(n){var a=ke(n)?Fc:Rg;return a(n)}function z0(n,a,h){(h?Bt(n,a,h):a===e)?a=1:a=Re(a);var y=ke(n)?ag:Ag;return y(n,a)}function B0(n){var a=ke(n)?og:$g;return a(n)}function W0(n){if(n==null)return 0;if(jt(n))return Oo(n)?Hs(n):n.length;var a=Pt(n);return a==Je||a==Ut?n.size:Eu(n).length}function V0(n,a,h){var y=ke(n)?xn:Eg;return h&&Bt(n,a,h)&&(a=e),y(n,ve(a,3))}var U0=$e(function(n,a){if(n==null)return[];var h=a.length;return h>1&&Bt(n,a[0],a[1])?a=[]:h>2&&Bt(a[0],a[1],a[2])&&(a=[a[0]]),Qc(n,_t(a,1),[])}),Po=Sm||function(){return yt.Date.now()};function M0(n,a){if(typeof a!="function")throw new cr(u);return n=Re(n),function(){if(--n<1)return a.apply(this,arguments)}}function Gh(n,a,h){return a=h?e:a,a=n&&a==null?n.length:a,Qr(n,M,e,e,e,e,a)}function jh(n,a){var h;if(typeof a!="function")throw new cr(u);return n=Re(n),function(){return--n>0&&(h=a.apply(this,arguments)),n<=1&&(a=e),h}}var nl=$e(function(n,a,h){var y=k;if(h.length){var S=Tr(h,Zs(nl));y|=V}return Qr(n,y,a,h,S)}),Kh=$e(function(n,a,h){var y=k|P;if(h.length){var S=Tr(h,Zs(Kh));y|=V}return Qr(a,y,n,h,S)});function qh(n,a,h){a=h?e:a;var y=Qr(n,z,e,e,e,e,e,a);return y.placeholder=qh.placeholder,y}function Xh(n,a,h){a=h?e:a;var y=Qr(n,F,e,e,e,e,e,a);return y.placeholder=Xh.placeholder,y}function Yh(n,a,h){var y,S,T,E,D,W,q=0,X=!1,Q=!1,oe=!0;if(typeof n!="function")throw new cr(u);a=mr(a)||0,ot(h)&&(X=!!h.leading,Q="maxWait"in h,T=Q?bt(mr(h.maxWait)||0,a):T,oe="trailing"in h?!!h.trailing:oe);function fe(ft){var Sr=y,rn=S;return y=S=e,q=ft,E=n.apply(rn,Sr),E}function be(ft){return q=ft,D=sa(Ee,a),X?fe(ft):E}function Pe(ft){var Sr=ft-W,rn=ft-q,mp=a-Sr;return Q?At(mp,T-rn):mp}function xe(ft){var Sr=ft-W,rn=ft-q;return W===e||Sr>=a||Sr<0||Q&&rn>=T}function Ee(){var ft=Po();if(xe(ft))return Le(ft);D=sa(Ee,Pe(ft))}function Le(ft){return D=e,oe&&y?fe(ft):(y=S=e,E)}function sr(){D!==e&&ah(D),q=0,y=W=S=D=e}function Wt(){return D===e?E:Le(Po())}function ir(){var ft=Po(),Sr=xe(ft);if(y=arguments,S=this,W=ft,Sr){if(D===e)return be(W);if(Q)return ah(D),D=sa(Ee,a),fe(W)}return D===e&&(D=sa(Ee,a)),E}return ir.cancel=sr,ir.flush=Wt,ir}var H0=$e(function(n,a){return Bc(n,1,a)}),G0=$e(function(n,a,h){return Bc(n,mr(a)||0,h)});function j0(n){return Qr(n,K)}function $o(n,a){if(typeof n!="function"||a!=null&&typeof a!="function")throw new cr(u);var h=function(){var y=arguments,S=a?a.apply(this,y):y[0],T=h.cache;if(T.has(S))return T.get(S);var E=n.apply(this,y);return h.cache=T.set(S,E)||T,E};return h.cache=new($o.Cache||Xr),h}$o.Cache=Xr;function Eo(n){if(typeof n!="function")throw new cr(u);return function(){var a=arguments;switch(a.length){case 0:return!n.call(this);case 1:return!n.call(this,a[0]);case 2:return!n.call(this,a[0],a[1]);case 3:return!n.call(this,a[0],a[1],a[2])}return!n.apply(this,a)}}function K0(n){return jh(2,n)}var q0=Dg(function(n,a){a=a.length==1&&ke(a[0])?Ke(a[0],ue(ve())):Ke(_t(a,1),ue(ve()));var h=a.length;return $e(function(y){for(var S=-1,T=At(y.length,h);++S<T;)y[S]=a[S].call(this,y[S]);return Tt(n,this,y)})}),sl=$e(function(n,a){var h=Tr(a,Zs(sl));return Qr(n,V,e,a,h)}),Qh=$e(function(n,a){var h=Tr(a,Zs(Qh));return Qr(n,G,e,a,h)}),X0=Zr(function(n,a){return Qr(n,Y,e,e,e,a)});function Y0(n,a){if(typeof n!="function")throw new cr(u);return a=a===e?a:Re(a),$e(n,a)}function Q0(n,a){if(typeof n!="function")throw new cr(u);return a=a==null?0:bt(Re(a),0),$e(function(h){var y=h[a],S=kn(h,0,a);return y&&kr(S,y),Tt(n,this,S)})}function Z0(n,a,h){var y=!0,S=!0;if(typeof n!="function")throw new cr(u);return ot(h)&&(y="leading"in h?!!h.leading:y,S="trailing"in h?!!h.trailing:S),Yh(n,a,{leading:y,maxWait:a,trailing:S})}function J0(n){return Gh(n,1)}function ew(n,a){return sl(Uu(a),n)}function tw(){if(!arguments.length)return[];var n=arguments[0];return ke(n)?n:[n]}function rw(n){return pr(n,x)}function nw(n,a){return a=typeof a=="function"?a:e,pr(n,x,a)}function sw(n){return pr(n,m|x)}function iw(n,a){return a=typeof a=="function"?a:e,pr(n,m|x,a)}function aw(n,a){return a==null||zc(n,a,Ct(a))}function xr(n,a){return n===a||n!==n&&a!==a}var ow=Io(Au),uw=Io(function(n,a){return n>=a}),ns=Hc(function(){return arguments}())?Hc:function(n){return ct(n)&&Ge.call(n,"callee")&&!Ac.call(n,"callee")},ke=H.isArray,lw=Xa?ue(Xa):yg;function jt(n){return n!=null&&Do(n.length)&&!en(n)}function dt(n){return ct(n)&&jt(n)}function cw(n){return n===!0||n===!1||ct(n)&&zt(n)==hn}var _n=Nm||ml,hw=Vi?ue(Vi):wg;function pw(n){return ct(n)&&n.nodeType===1&&!ia(n)}function dw(n){if(n==null)return!0;if(jt(n)&&(ke(n)||typeof n=="string"||typeof n.splice=="function"||_n(n)||Js(n)||ns(n)))return!n.length;var a=Pt(n);if(a==Je||a==Ut)return!n.size;if(na(n))return!Eu(n).length;for(var h in n)if(Ge.call(n,h))return!1;return!0}function fw(n,a){return ea(n,a)}function mw(n,a,h){h=typeof h=="function"?h:e;var y=h?h(n,a):e;return y===e?ea(n,a,e,h):!!y}function il(n){if(!ct(n))return!1;var a=zt(n);return a==Nr||a==mi||typeof n.message=="string"&&typeof n.name=="string"&&!ia(n)}function gw(n){return typeof n=="number"&&$c(n)}function en(n){if(!ot(n))return!1;var a=zt(n);return a==Ss||a==lt||a==ru||a==_a}function Zh(n){return typeof n=="number"&&n==Re(n)}function Do(n){return typeof n=="number"&&n>-1&&n%1==0&&n<=nt}function ot(n){var a=typeof n;return n!=null&&(a=="object"||a=="function")}function ct(n){return n!=null&&typeof n=="object"}var Jh=Ya?ue(Ya):bg;function yw(n,a){return n===a||$u(n,a,Xu(a))}function ww(n,a,h){return h=typeof h=="function"?h:e,$u(n,a,Xu(a),h)}function vw(n){return ep(n)&&n!=+n}function bw(n){if(ny(n))throw new Ie(o);return Gc(n)}function xw(n){return n===null}function Sw(n){return n==null}function ep(n){return typeof n=="number"||ct(n)&&zt(n)==dn}function ia(n){if(!ct(n)||zt(n)!=or)return!1;var a=ao(n);if(a===null)return!0;var h=Ge.call(a,"constructor")&&a.constructor;return typeof h=="function"&&h instanceof h&&ro.call(h)==wm}var al=Qa?ue(Qa):xg;function Cw(n){return Zh(n)&&n>=-nt&&n<=nt}var tp=Bs?ue(Bs):Sg;function Oo(n){return typeof n=="string"||!ke(n)&&ct(n)&&zt(n)==Br}function nr(n){return typeof n=="symbol"||ct(n)&&zt(n)==Fn}var Js=Ws?ue(Ws):Cg;function Nw(n){return n===e}function Iw(n){return ct(n)&&Pt(n)==mn}function kw(n){return ct(n)&&zt(n)==Cs}var _w=Io(Du),Tw=Io(function(n,a){return n<=a});function rp(n){if(!n)return[];if(jt(n))return Oo(n)?vr(n):Gt(n);if(ji&&n[ji])return xu(n[ji]());var a=Pt(n),h=a==Je?Gi:a==Ut?Us:ei;return h(n)}function tn(n){if(!n)return n===0?n:0;if(n=mr(n),n===rt||n===-rt){var a=n<0?-1:1;return a*pt}return n===n?n:0}function Re(n){var a=tn(n),h=a%1;return a===a?h?a-h:a:0}function np(n){return n?Jn(Re(n),0,ut):0}function mr(n){if(typeof n=="number")return n;if(nr(n))return Ot;if(ot(n)){var a=typeof n.valueOf=="function"?n.valueOf():n;n=ot(a)?a+"":a}if(typeof n!="string")return n===0?n:+n;n=we(n);var h=Aa.test(n);return h||Ti.test(n)?fu(n.slice(2),h?2:8):Wn.test(n)?Ot:+n}function sp(n){return Ar(n,Kt(n))}function Rw(n){return n?Jn(Re(n),-nt,nt):n===0?n:0}function Me(n){return n==null?"":rr(n)}var Aw=Ys(function(n,a){if(na(a)||jt(a)){Ar(a,Ct(a),n);return}for(var h in a)Ge.call(a,h)&&Qi(n,h,a[h])}),ip=Ys(function(n,a){Ar(a,Kt(a),n)}),Fo=Ys(function(n,a,h,y){Ar(a,Kt(a),n,y)}),Pw=Ys(function(n,a,h,y){Ar(a,Ct(a),n,y)}),$w=Zr(_u);function Ew(n,a){var h=Xs(n);return a==null?h:Lc(h,a)}var Dw=$e(function(n,a){n=et(n);var h=-1,y=a.length,S=y>2?a[2]:e;for(S&&Bt(a[0],a[1],S)&&(y=1);++h<y;)for(var T=a[h],E=Kt(T),D=-1,W=E.length;++D<W;){var q=E[D],X=n[q];(X===e||xr(X,js[q])&&!Ge.call(n,q))&&(n[q]=T[q])}return n}),Ow=$e(function(n){return n.push(e,Sh),Tt(ap,e,n)});function Fw(n,a){return Hi(n,ve(a,3),Rr)}function Lw(n,a){return Hi(n,ve(a,3),Ru)}function zw(n,a){return n==null?n:Tu(n,ve(a,3),Kt)}function Bw(n,a){return n==null?n:Uc(n,ve(a,3),Kt)}function Ww(n,a){return n&&Rr(n,ve(a,3))}function Vw(n,a){return n&&Ru(n,ve(a,3))}function Uw(n){return n==null?[]:yo(n,Ct(n))}function Mw(n){return n==null?[]:yo(n,Kt(n))}function ol(n,a,h){var y=n==null?e:es(n,a);return y===e?h:y}function Hw(n,a){return n!=null&&Ih(n,a,dg)}function ul(n,a){return n!=null&&Ih(n,a,fg)}var Gw=yh(function(n,a,h){a!=null&&typeof a.toString!="function"&&(a=no.call(a)),n[a]=h},cl(qt)),jw=yh(function(n,a,h){a!=null&&typeof a.toString!="function"&&(a=no.call(a)),Ge.call(n,a)?n[a].push(h):n[a]=[h]},ve),Kw=$e(Ji);function Ct(n){return jt(n)?Oc(n):Eu(n)}function Kt(n){return jt(n)?Oc(n,!0):Ng(n)}function qw(n,a){var h={};return a=ve(a,3),Rr(n,function(y,S,T){Yr(h,a(y,S,T),y)}),h}function Xw(n,a){var h={};return a=ve(a,3),Rr(n,function(y,S,T){Yr(h,S,a(y,S,T))}),h}var Yw=Ys(function(n,a,h){wo(n,a,h)}),ap=Ys(function(n,a,h,y){wo(n,a,h,y)}),Qw=Zr(function(n,a){var h={};if(n==null)return h;var y=!1;a=Ke(a,function(T){return T=In(T,n),y||(y=T.length>1),T}),Ar(n,Ku(n),h),y&&(h=pr(h,m|w|x,Gg));for(var S=a.length;S--;)Bu(h,a[S]);return h});function Zw(n,a){return op(n,Eo(ve(a)))}var Jw=Zr(function(n,a){return n==null?{}:kg(n,a)});function op(n,a){if(n==null)return{};var h=Ke(Ku(n),function(y){return[y]});return a=ve(a),Zc(n,h,function(y,S){return a(y,S[0])})}function ev(n,a,h){a=In(a,n);var y=-1,S=a.length;for(S||(S=1,n=e);++y<S;){var T=n==null?e:n[Pr(a[y])];T===e&&(y=S,T=h),n=en(T)?T.call(n):T}return n}function tv(n,a,h){return n==null?n:ta(n,a,h)}function rv(n,a,h,y){return y=typeof y=="function"?y:e,n==null?n:ta(n,a,h,y)}var up=bh(Ct),lp=bh(Kt);function nv(n,a,h){var y=ke(n),S=y||_n(n)||Js(n);if(a=ve(a,4),h==null){var T=n&&n.constructor;S?h=y?new T:[]:ot(n)?h=en(T)?Xs(ao(n)):{}:h={}}return(S?Mt:Rr)(n,function(E,D,W){return a(h,E,D,W)}),h}function sv(n,a){return n==null?!0:Bu(n,a)}function iv(n,a,h){return n==null?n:nh(n,a,Uu(h))}function av(n,a,h,y){return y=typeof y=="function"?y:e,n==null?n:nh(n,a,Uu(h),y)}function ei(n){return n==null?[]:ie(n,Ct(n))}function ov(n){return n==null?[]:ie(n,Kt(n))}function uv(n,a,h){return h===e&&(h=a,a=e),h!==e&&(h=mr(h),h=h===h?h:0),a!==e&&(a=mr(a),a=a===a?a:0),Jn(mr(n),a,h)}function lv(n,a,h){return a=tn(a),h===e?(h=a,a=0):h=tn(h),n=mr(n),mg(n,a,h)}function cv(n,a,h){if(h&&typeof h!="boolean"&&Bt(n,a,h)&&(a=h=e),h===e&&(typeof a=="boolean"?(h=a,a=e):typeof n=="boolean"&&(h=n,n=e)),n===e&&a===e?(n=0,a=1):(n=tn(n),a===e?(a=n,n=0):a=tn(a)),n>a){var y=n;n=a,a=y}if(h||n%1||a%1){var S=Ec();return At(n+S*(a-n+Wi("1e-"+((S+"").length-1))),a)}return Fu(n,a)}var hv=Qs(function(n,a,h){return a=a.toLowerCase(),n+(h?cp(a):a)});function cp(n){return ll(Me(n).toLowerCase())}function hp(n){return n=Me(n),n&&n.replace(Jt,wt).replace(Li,"")}function pv(n,a,h){n=Me(n),a=rr(a);var y=n.length;h=h===e?y:Jn(Re(h),0,y);var S=h;return h-=a.length,h>=0&&n.slice(h,S)==a}function dv(n){return n=Me(n),n&&Ta.test(n)?n.replace(xi,Ht):n}function fv(n){return n=Me(n),n&&iu.test(n)?n.replace(Ir,"\\$&"):n}var mv=Qs(function(n,a,h){return n+(h?"-":"")+a.toLowerCase()}),gv=Qs(function(n,a,h){return n+(h?" ":"")+a.toLowerCase()}),yv=fh("toLowerCase");function wv(n,a,h){n=Me(n),a=Re(a);var y=a?Hs(n):0;if(!a||y>=a)return n;var S=(a-y)/2;return No(co(S),h)+n+No(lo(S),h)}function vv(n,a,h){n=Me(n),a=Re(a);var y=a?Hs(n):0;return a&&y<a?n+No(a-y,h):n}function bv(n,a,h){n=Me(n),a=Re(a);var y=a?Hs(n):0;return a&&y<a?No(a-y,h)+n:n}function xv(n,a,h){return h||a==null?a=0:a&&(a=+a),Tm(Me(n).replace(Zt,""),a||0)}function Sv(n,a,h){return(h?Bt(n,a,h):a===e)?a=1:a=Re(a),Lu(Me(n),a)}function Cv(){var n=arguments,a=Me(n[0]);return n.length<3?a:a.replace(n[1],n[2])}var Nv=Qs(function(n,a,h){return n+(h?"_":"")+a.toLowerCase()});function Iv(n,a,h){return h&&typeof h!="number"&&Bt(n,a,h)&&(a=h=e),h=h===e?ut:h>>>0,h?(n=Me(n),n&&(typeof a=="string"||a!=null&&!al(a))&&(a=rr(a),!a&&st(n))?kn(vr(n),0,h):n.split(a,h)):[]}var kv=Qs(function(n,a,h){return n+(h?" ":"")+ll(a)});function _v(n,a,h){return n=Me(n),h=h==null?0:Jn(Re(h),0,n.length),a=rr(a),n.slice(h,h+a.length)==a}function Tv(n,a,h){var y=_.templateSettings;h&&Bt(n,a,h)&&(a=e),n=Me(n),a=Fo({},a,y,xh);var S=Fo({},a.imports,y.imports,xh),T=Ct(S),E=ie(S,T),D,W,q=0,X=a.interpolate||Ft,Q="__p += '",oe=Su((a.escape||Ft).source+"|"+X.source+"|"+(X===Ni?ki:Ft).source+"|"+(a.evaluate||Ft).source+"|$","g"),fe="//# sourceURL="+(Ge.call(a,"sourceURL")?(a.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++du+"]")+`
`;n.replace(oe,function(xe,Ee,Le,sr,Wt,ir){return Le||(Le=sr),Q+=n.slice(q,ir).replace(Vn,Rt),Ee&&(D=!0,Q+=`' +
__e(`+Ee+`) +
'`),Wt&&(W=!0,Q+=`';
`+Wt+`;
__p += '`),Le&&(Q+=`' +
((__t = (`+Le+`)) == null ? '' : __t) +
'`),q=ir+xe.length,xe}),Q+=`';
`;var be=Ge.call(a,"variable")&&a.variable;if(!be)Q=`with (obj) {
`+Q+`
}
`;else if(au.test(be))throw new Ie(l);Q=(W?Q.replace(vi,""):Q).replace(Mr,"$1").replace(zn,"$1;"),Q="function("+(be||"obj")+`) {
`+(be?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(D?", __e = _.escape":"")+(W?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+Q+`return __p
}`;var Pe=dp(function(){return Ue(T,fe+"return "+Q).apply(e,E)});if(Pe.source=Q,il(Pe))throw Pe;return Pe}function Rv(n){return Me(n).toLowerCase()}function Av(n){return Me(n).toUpperCase()}function Pv(n,a,h){if(n=Me(n),n&&(h||a===e))return we(n);if(!n||!(a=rr(a)))return n;var y=vr(n),S=vr(a),T=_e(y,S),E=qe(y,S)+1;return kn(y,T,E).join("")}function $v(n,a,h){if(n=Me(n),n&&(h||a===e))return n.slice(0,kc(n)+1);if(!n||!(a=rr(a)))return n;var y=vr(n),S=qe(y,vr(a))+1;return kn(y,0,S).join("")}function Ev(n,a,h){if(n=Me(n),n&&(h||a===e))return n.replace(Zt,"");if(!n||!(a=rr(a)))return n;var y=vr(n),S=_e(y,vr(a));return kn(y,S).join("")}function Dv(n,a){var h=J,y=ne;if(ot(a)){var S="separator"in a?a.separator:S;h="length"in a?Re(a.length):h,y="omission"in a?rr(a.omission):y}n=Me(n);var T=n.length;if(st(n)){var E=vr(n);T=E.length}if(h>=T)return n;var D=h-Hs(y);if(D<1)return y;var W=E?kn(E,0,D).join(""):n.slice(0,D);if(S===e)return W+y;if(E&&(D+=W.length-D),al(S)){if(n.slice(D).search(S)){var q,X=W;for(S.global||(S=Su(S.source,Me(Bn.exec(S))+"g")),S.lastIndex=0;q=S.exec(X);)var Q=q.index;W=W.slice(0,Q===e?D:Q)}}else if(n.indexOf(rr(S),D)!=D){var oe=W.lastIndexOf(S);oe>-1&&(W=W.slice(0,oe))}return W+y}function Ov(n){return n=Me(n),n&&Si.test(n)?n.replace(bi,cm):n}var Fv=Qs(function(n,a,h){return n+(h?" ":"")+a.toUpperCase()}),ll=fh("toUpperCase");function pp(n,a,h){return n=Me(n),a=h?e:a,a===e?_r(n)?dm(n):bu(n):n.match(a)||[]}var dp=$e(function(n,a){try{return Tt(n,e,a)}catch(h){return il(h)?h:new Ie(h)}}),Lv=Zr(function(n,a){return Mt(a,function(h){h=Pr(h),Yr(n,h,nl(n[h],n))}),n});function zv(n){var a=n==null?0:n.length,h=ve();return n=a?Ke(n,function(y){if(typeof y[1]!="function")throw new cr(u);return[h(y[0]),y[1]]}):[],$e(function(y){for(var S=-1;++S<a;){var T=n[S];if(Tt(T[0],this,y))return Tt(T[1],this,y)}})}function Bv(n){return cg(pr(n,m))}function cl(n){return function(){return n}}function Wv(n,a){return n==null||n!==n?a:n}var Vv=gh(),Uv=gh(!0);function qt(n){return n}function hl(n){return jc(typeof n=="function"?n:pr(n,m))}function Mv(n){return qc(pr(n,m))}function Hv(n,a){return Xc(n,pr(a,m))}var Gv=$e(function(n,a){return function(h){return Ji(h,n,a)}}),jv=$e(function(n,a){return function(h){return Ji(n,h,a)}});function pl(n,a,h){var y=Ct(a),S=yo(a,y);h==null&&!(ot(a)&&(S.length||!y.length))&&(h=a,a=n,n=this,S=yo(a,Ct(a)));var T=!(ot(h)&&"chain"in h)||!!h.chain,E=en(n);return Mt(S,function(D){var W=a[D];n[D]=W,E&&(n.prototype[D]=function(){var q=this.__chain__;if(T||q){var X=n(this.__wrapped__),Q=X.__actions__=Gt(this.__actions__);return Q.push({func:W,args:arguments,thisArg:n}),X.__chain__=q,X}return W.apply(n,kr([this.value()],arguments))})}),n}function Kv(){return yt._===this&&(yt._=vm),this}function dl(){}function qv(n){return n=Re(n),$e(function(a){return Yc(a,n)})}var Xv=Hu(Ke),Yv=Hu(Za),Qv=Hu(xn);function fp(n){return Qu(n)?R(Pr(n)):_g(n)}function Zv(n){return function(a){return n==null?e:es(n,a)}}var Jv=wh(),eb=wh(!0);function fl(){return[]}function ml(){return!1}function tb(){return{}}function rb(){return""}function nb(){return!0}function sb(n,a){if(n=Re(n),n<1||n>nt)return[];var h=ut,y=At(n,ut);a=ve(a),n-=ut;for(var S=Z(y,a);++h<n;)a(h);return S}function ib(n){return ke(n)?Ke(n,Pr):nr(n)?[n]:Gt(Dh(Me(n)))}function ab(n){var a=++ym;return Me(n)+a}var ob=Co(function(n,a){return n+a},0),ub=Gu("ceil"),lb=Co(function(n,a){return n/a},1),cb=Gu("floor");function hb(n){return n&&n.length?go(n,qt,Au):e}function pb(n,a){return n&&n.length?go(n,ve(a,2),Au):e}function db(n){return N(n,qt)}function fb(n,a){return N(n,ve(a,2))}function mb(n){return n&&n.length?go(n,qt,Du):e}function gb(n,a){return n&&n.length?go(n,ve(a,2),Du):e}var yb=Co(function(n,a){return n*a},1),wb=Gu("round"),vb=Co(function(n,a){return n-a},0);function bb(n){return n&&n.length?U(n,qt):0}function xb(n,a){return n&&n.length?U(n,ve(a,2)):0}return _.after=M0,_.ary=Gh,_.assign=Aw,_.assignIn=ip,_.assignInWith=Fo,_.assignWith=Pw,_.at=$w,_.before=jh,_.bind=nl,_.bindAll=Lv,_.bindKey=Kh,_.castArray=tw,_.chain=Uh,_.chunk=cy,_.compact=hy,_.concat=py,_.cond=zv,_.conforms=Bv,_.constant=cl,_.countBy=b0,_.create=Ew,_.curry=qh,_.curryRight=Xh,_.debounce=Yh,_.defaults=Dw,_.defaultsDeep=Ow,_.defer=H0,_.delay=G0,_.difference=dy,_.differenceBy=fy,_.differenceWith=my,_.drop=gy,_.dropRight=yy,_.dropRightWhile=wy,_.dropWhile=vy,_.fill=by,_.filter=S0,_.flatMap=I0,_.flatMapDeep=k0,_.flatMapDepth=_0,_.flatten=zh,_.flattenDeep=xy,_.flattenDepth=Sy,_.flip=j0,_.flow=Vv,_.flowRight=Uv,_.fromPairs=Cy,_.functions=Uw,_.functionsIn=Mw,_.groupBy=T0,_.initial=Iy,_.intersection=ky,_.intersectionBy=_y,_.intersectionWith=Ty,_.invert=Gw,_.invertBy=jw,_.invokeMap=A0,_.iteratee=hl,_.keyBy=P0,_.keys=Ct,_.keysIn=Kt,_.map=Ao,_.mapKeys=qw,_.mapValues=Xw,_.matches=Mv,_.matchesProperty=Hv,_.memoize=$o,_.merge=Yw,_.mergeWith=ap,_.method=Gv,_.methodOf=jv,_.mixin=pl,_.negate=Eo,_.nthArg=qv,_.omit=Qw,_.omitBy=Zw,_.once=K0,_.orderBy=$0,_.over=Xv,_.overArgs=q0,_.overEvery=Yv,_.overSome=Qv,_.partial=sl,_.partialRight=Qh,_.partition=E0,_.pick=Jw,_.pickBy=op,_.property=fp,_.propertyOf=Zv,_.pull=$y,_.pullAll=Wh,_.pullAllBy=Ey,_.pullAllWith=Dy,_.pullAt=Oy,_.range=Jv,_.rangeRight=eb,_.rearg=X0,_.reject=F0,_.remove=Fy,_.rest=Y0,_.reverse=tl,_.sampleSize=z0,_.set=tv,_.setWith=rv,_.shuffle=B0,_.slice=Ly,_.sortBy=U0,_.sortedUniq=Hy,_.sortedUniqBy=Gy,_.split=Iv,_.spread=Q0,_.tail=jy,_.take=Ky,_.takeRight=qy,_.takeRightWhile=Xy,_.takeWhile=Yy,_.tap=h0,_.throttle=Z0,_.thru=Ro,_.toArray=rp,_.toPairs=up,_.toPairsIn=lp,_.toPath=ib,_.toPlainObject=sp,_.transform=nv,_.unary=J0,_.union=Qy,_.unionBy=Zy,_.unionWith=Jy,_.uniq=e0,_.uniqBy=t0,_.uniqWith=r0,_.unset=sv,_.unzip=rl,_.unzipWith=Vh,_.update=iv,_.updateWith=av,_.values=ei,_.valuesIn=ov,_.without=n0,_.words=pp,_.wrap=ew,_.xor=s0,_.xorBy=i0,_.xorWith=a0,_.zip=o0,_.zipObject=u0,_.zipObjectDeep=l0,_.zipWith=c0,_.entries=up,_.entriesIn=lp,_.extend=ip,_.extendWith=Fo,pl(_,_),_.add=ob,_.attempt=dp,_.camelCase=hv,_.capitalize=cp,_.ceil=ub,_.clamp=uv,_.clone=rw,_.cloneDeep=sw,_.cloneDeepWith=iw,_.cloneWith=nw,_.conformsTo=aw,_.deburr=hp,_.defaultTo=Wv,_.divide=lb,_.endsWith=pv,_.eq=xr,_.escape=dv,_.escapeRegExp=fv,_.every=x0,_.find=C0,_.findIndex=Fh,_.findKey=Fw,_.findLast=N0,_.findLastIndex=Lh,_.findLastKey=Lw,_.floor=cb,_.forEach=Mh,_.forEachRight=Hh,_.forIn=zw,_.forInRight=Bw,_.forOwn=Ww,_.forOwnRight=Vw,_.get=ol,_.gt=ow,_.gte=uw,_.has=Hw,_.hasIn=ul,_.head=Bh,_.identity=qt,_.includes=R0,_.indexOf=Ny,_.inRange=lv,_.invoke=Kw,_.isArguments=ns,_.isArray=ke,_.isArrayBuffer=lw,_.isArrayLike=jt,_.isArrayLikeObject=dt,_.isBoolean=cw,_.isBuffer=_n,_.isDate=hw,_.isElement=pw,_.isEmpty=dw,_.isEqual=fw,_.isEqualWith=mw,_.isError=il,_.isFinite=gw,_.isFunction=en,_.isInteger=Zh,_.isLength=Do,_.isMap=Jh,_.isMatch=yw,_.isMatchWith=ww,_.isNaN=vw,_.isNative=bw,_.isNil=Sw,_.isNull=xw,_.isNumber=ep,_.isObject=ot,_.isObjectLike=ct,_.isPlainObject=ia,_.isRegExp=al,_.isSafeInteger=Cw,_.isSet=tp,_.isString=Oo,_.isSymbol=nr,_.isTypedArray=Js,_.isUndefined=Nw,_.isWeakMap=Iw,_.isWeakSet=kw,_.join=Ry,_.kebabCase=mv,_.last=fr,_.lastIndexOf=Ay,_.lowerCase=gv,_.lowerFirst=yv,_.lt=_w,_.lte=Tw,_.max=hb,_.maxBy=pb,_.mean=db,_.meanBy=fb,_.min=mb,_.minBy=gb,_.stubArray=fl,_.stubFalse=ml,_.stubObject=tb,_.stubString=rb,_.stubTrue=nb,_.multiply=yb,_.nth=Py,_.noConflict=Kv,_.noop=dl,_.now=Po,_.pad=wv,_.padEnd=vv,_.padStart=bv,_.parseInt=xv,_.random=cv,_.reduce=D0,_.reduceRight=O0,_.repeat=Sv,_.replace=Cv,_.result=ev,_.round=wb,_.runInContext=B,_.sample=L0,_.size=W0,_.snakeCase=Nv,_.some=V0,_.sortedIndex=zy,_.sortedIndexBy=By,_.sortedIndexOf=Wy,_.sortedLastIndex=Vy,_.sortedLastIndexBy=Uy,_.sortedLastIndexOf=My,_.startCase=kv,_.startsWith=_v,_.subtract=vb,_.sum=bb,_.sumBy=xb,_.template=Tv,_.times=sb,_.toFinite=tn,_.toInteger=Re,_.toLength=np,_.toLower=Rv,_.toNumber=mr,_.toSafeInteger=Rw,_.toString=Me,_.toUpper=Av,_.trim=Pv,_.trimEnd=$v,_.trimStart=Ev,_.truncate=Dv,_.unescape=Ov,_.uniqueId=ab,_.upperCase=Fv,_.upperFirst=ll,_.each=Mh,_.eachRight=Hh,_.first=Bh,pl(_,function(){var n={};return Rr(_,function(a,h){Ge.call(_.prototype,h)||(n[h]=a)}),n}(),{chain:!1}),_.VERSION=s,Mt(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){_[n].placeholder=_}),Mt(["drop","take"],function(n,a){De.prototype[n]=function(h){h=h===e?1:bt(Re(h),0);var y=this.__filtered__&&!a?new De(this):this.clone();return y.__filtered__?y.__takeCount__=At(h,y.__takeCount__):y.__views__.push({size:At(h,ut),type:n+(y.__dir__<0?"Right":"")}),y},De.prototype[n+"Right"]=function(h){return this.reverse()[n](h).reverse()}}),Mt(["filter","map","takeWhile"],function(n,a){var h=a+1,y=h==ye||h==Ae;De.prototype[n]=function(S){var T=this.clone();return T.__iteratees__.push({iteratee:ve(S,3),type:h}),T.__filtered__=T.__filtered__||y,T}}),Mt(["head","last"],function(n,a){var h="take"+(a?"Right":"");De.prototype[n]=function(){return this[h](1).value()[0]}}),Mt(["initial","tail"],function(n,a){var h="drop"+(a?"":"Right");De.prototype[n]=function(){return this.__filtered__?new De(this):this[h](1)}}),De.prototype.compact=function(){return this.filter(qt)},De.prototype.find=function(n){return this.filter(n).head()},De.prototype.findLast=function(n){return this.reverse().find(n)},De.prototype.invokeMap=$e(function(n,a){return typeof n=="function"?new De(this):this.map(function(h){return Ji(h,n,a)})}),De.prototype.reject=function(n){return this.filter(Eo(ve(n)))},De.prototype.slice=function(n,a){n=Re(n);var h=this;return h.__filtered__&&(n>0||a<0)?new De(h):(n<0?h=h.takeRight(-n):n&&(h=h.drop(n)),a!==e&&(a=Re(a),h=a<0?h.dropRight(-a):h.take(a-n)),h)},De.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},De.prototype.toArray=function(){return this.take(ut)},Rr(De.prototype,function(n,a){var h=/^(?:filter|find|map|reject)|While$/.test(a),y=/^(?:head|last)$/.test(a),S=_[y?"take"+(a=="last"?"Right":""):a],T=y||/^find/.test(a);S&&(_.prototype[a]=function(){var E=this.__wrapped__,D=y?[1]:arguments,W=E instanceof De,q=D[0],X=W||ke(E),Q=function(Ee){var Le=S.apply(_,kr([Ee],D));return y&&oe?Le[0]:Le};X&&h&&typeof q=="function"&&q.length!=1&&(W=X=!1);var oe=this.__chain__,fe=!!this.__actions__.length,be=T&&!oe,Pe=W&&!fe;if(!T&&X){E=Pe?E:new De(this);var xe=n.apply(E,D);return xe.__actions__.push({func:Ro,args:[Q],thisArg:e}),new hr(xe,oe)}return be&&Pe?n.apply(this,D):(xe=this.thru(Q),be?y?xe.value()[0]:xe.value():xe)})}),Mt(["pop","push","shift","sort","splice","unshift"],function(n){var a=eo[n],h=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",y=/^(?:pop|shift)$/.test(n);_.prototype[n]=function(){var S=arguments;if(y&&!this.__chain__){var T=this.value();return a.apply(ke(T)?T:[],S)}return this[h](function(E){return a.apply(ke(E)?E:[],S)})}}),Rr(De.prototype,function(n,a){var h=_[a];if(h){var y=h.name+"";Ge.call(qs,y)||(qs[y]=[]),qs[y].push({name:a,func:h})}}),qs[So(e,P).name]=[{name:"wrapper",func:e}],De.prototype.clone=Om,De.prototype.reverse=Fm,De.prototype.value=Lm,_.prototype.at=p0,_.prototype.chain=d0,_.prototype.commit=f0,_.prototype.next=m0,_.prototype.plant=y0,_.prototype.reverse=w0,_.prototype.toJSON=_.prototype.valueOf=_.prototype.value=v0,_.prototype.first=_.prototype.head,ji&&(_.prototype[ji]=g0),_},Gs=fm();Kr?((Kr.exports=Gs)._=Gs,zs._=Gs):yt._=Gs}).call(lz)}(ca,ca.exports)),ca.exports}cz();const fz={__name:"tensorflow-pose",setup(r){const t={modelType:Dr.BlazePose,detectorConfig:{runtime:"tfjs",modelType:"lite",enableSmoothing:!0}};let e=null,s=null;const i=i3(null);a3(()=>{o()}),o3(()=>{});async function o(){try{await s3(),console.log("TensorFlow.js loaded"),e=await uz(t.modelType,t.detectorConfig),await u(),s=document.getElementById("canvas").getContext("2d"),l()}catch(f){console.error(f)}}async function u(){return new Promise((f,m)=>{navigator.mediaDevices.getUserMedia({video:!0,audio:!1}).then(w=>{i.value.srcObject=w,i.value.onloadedmetadata=()=>{i.value.play(),f()}}).catch(w=>{console.error("Error accessing camera:",w)})})}async function l(){for(;;){const f=await e.estimatePoses(i.value);s.clearRect(0,0,640,480),s.drawImage(i.value,0,0,640,480),f.length>0&&(p(f[0].keypoints),d(f[0].keypoints)),await new Promise(m=>requestAnimationFrame(m))}}function p(f){f.forEach(m=>{m.score>.3&&(s.beginPath(),s.arc(m.x,m.y,4,0,2*Math.PI),s.fillStyle="#FF0000",s.fill())})}function d(f){[["left_shoulder","right_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["left_hip","right_hip"],["left_shoulder","left_hip"],["right_shoulder","right_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["right_hip","right_knee"],["right_knee","right_ankle"]].forEach(([w,x])=>{const C=f.find(k=>k.name===w),I=f.find(k=>k.name===x);C?.score>.3&&I?.score>.3&&(s.beginPath(),s.moveTo(C.x,C.y),s.lineTo(I.x,I.y),s.lineWidth=2,s.strokeStyle="#00FF00",s.stroke())})}return(f,m)=>(l3(),u3("div",null,[m[0]||(m[0]=yl("h1",null,"姿态检测",-1)),yl("video",{ref_key:"video",ref:i,id:"video",width:"640",height:"480",autoplay:"",muted:"",playsinline:""},null,512),m[1]||(m[1]=yl("canvas",{id:"canvas",width:"640",height:"480"},null,-1))]))}};export{fz as default};
